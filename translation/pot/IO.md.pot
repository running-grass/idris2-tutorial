# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-08-02 23:16+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:622
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:842
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:871
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:903
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/IO.md:1
#, no-wrap
msgid "IO: Programming with Side Effects"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:7
msgid ""
"So far, all our examples and exercises dealt with pure, total functions.  We "
"didn't read or write content from or to files, nor did we write any messages "
"to the standard output. It is time to change that and learn, how we can "
"write effectful programs in Idris."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:8
#, no-wrap
msgid ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:20
#, no-wrap
msgid "Pure Side Effects?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:24
msgid ""
"If we once again look at the *hello world* example from the [introduction]"
"(Intro.md), it had the following type and implementation:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:25
#, no-wrap
msgid ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:32
msgid ""
"If you load this module in a REPL session and evaluate `hello`, you'll get "
"the following:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:33
#, no-wrap
msgid ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:41
msgid ""
"This might not be what you expected, given that we'd actually wanted the "
"program to just print \"Hello World!\". In order to explain what's going on "
"here, we need to quickly look at how evaluation at the REPL works."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:51
msgid ""
"When we evaluate some expression at the REPL, Idris tries to reduce it to a "
"value until it gets stuck somewhere. In the above case, Idris gets stuck at "
"function `prim__putStr`. This is a *foreign function* defined in the "
"*Prelude*, which has to be implemented by each backend in order to be "
"available there. At compile time (and at the REPL), Idris knows nothing "
"about the implementations of foreign functions and therefore can't reduce "
"foreign function calls, unless they are built into the compiler itself. But "
"even then, values of type `IO a` (`a` being a type parameter) are typically "
"not reduced."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:61
#, no-wrap
msgid ""
"It is important to understand that values of type `IO a` *describe*\n"
"a program, which, when being *executed*, will return a value of type `a`,\n"
"after performing arbitrary side effects along the way. For instance,\n"
"`putStrLn` has type `String -> IO ()`. Read this as: \"`putStrLn` is a function,\n"
"which, when given a `String` argument, will return a description of\n"
"an effectful program with an output type of `()`\".\n"
"(`()` is syntactic sugar for type `Unit`, the\n"
"empty tuple defined at the *Prelude*, which has only one value called `MkUnit`,\n"
"for which we can also use `()` in our code.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:72
#, no-wrap
msgid ""
"Since values of type `IO a` are mere descriptions of effectful computations,\n"
"functions returning such values or taking such values as\n"
"arguments are still *pure* and thus referentially transparent.\n"
"It is, however, not possible to extract a value of type `a` from\n"
"a value of type `IO a`, that is, there is no generic function `IO a -> a`,\n"
"as such a function would inadvertently execute the side\n"
"effects when extracting the result from its argument,\n"
"thus breaking referential transparency.\n"
"(Actually, there *is* such a function called `unsafePerformIO`.\n"
"Do not ever use it in your code unless you know what you are doing.)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:73
#, no-wrap
msgid "Do Blocks"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:83
#, no-wrap
msgid ""
"If you are new to pure functional programming, you might now - rightfully -\n"
"mumble something about how useless it is to\n"
"have descriptions of effectful programs without being able to run them.\n"
"So please, hear me out. While we are not able to run values of type\n"
"`IO a` when writing programs, that is, there is no function of\n"
"type `IO a -> a`, we are able to chain such computations and describe more\n"
"complex programs. Idris provides special syntax for this: *Do blocks*.\n"
"Here's an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:84
#, no-wrap
msgid ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:93
msgid ""
"Before we talk about what's going on here, let's give this a go at the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:94
#, no-wrap
msgid ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:104
msgid ""
"This is an interactive program, which will read a line from standard input "
"(`getLine`), assign the result to variable `name`, and then use `name` to "
"create a friendly greeting and write it to standard output."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:114
#, no-wrap
msgid ""
"Note the `do` keyword at the beginning of the implementation of `readHello`:\n"
"It starts a *do block*, where we can chain `IO` computations and bind\n"
"intermediary results to variables using arrows pointing\n"
"to the left (`<-`), which can then be used in later\n"
"`IO` actions. This concept is powerful enough to let us encapsulate arbitrary\n"
"programs with side effects in a single value of type `IO`. Such a\n"
"description can then be returned by function `main`, the main entry point\n"
"to an Idris program, which is being executed when we run a compiled\n"
"Idris binary.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:115
#, no-wrap
msgid "The Difference between Program Description and Execution"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:120
msgid ""
"In order to better understand the difference between *describing* an "
"effectful computation and *executing* or *running* it, here is a small "
"program:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:121
#, no-wrap
msgid ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:153
#, no-wrap
msgid ""
"Before I explain what the code above does, please note function\n"
"`pure` used in the implementation of `runActions`. It is\n"
"a constrained function, about which we will learn in the next\n"
"chapter. Specialized to `IO`, it has generic type `a -> IO a`:\n"
"It allows us to wrap a value in an `IO` action. The resulting\n"
"`IO` program will just return the wrapped value without performing\n"
"any side effects. We can now look at the big picture of what's\n"
"going on in `readHellos`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:160
msgid ""
"First, we define a friendlier version of `readHello`: When executed, this "
"will ask about our name explicitly. Since we will not use the result of "
"`putStrLn` any further, we can use an underscore as a catch-all pattern "
"here. Afterwards, `readHello` is invoked. We also define `launchMissiles`, "
"which, when being executed, will lead to the destruction of planet earth."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:169
msgid ""
"Now, `runActions` is the function we use to demonstrate that *describing* an "
"`IO` action is not the same as *running* it. It will drop the first action "
"from the non-empty vector it takes as its argument and return a new `IO` "
"action, which describes the execution of the remaining `IO` actions in "
"sequence. If this behaves as expected, the first `IO` action passed to "
"`runActions` should be silently dropped together with all its potential side "
"effects."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:174
msgid ""
"When we execute `readHellos` at the REPL, we will be asked for our name "
"twice, although `actions` also contains `launchMissiles` at the beginning. "
"Luckily, although we described how to destroy the planet, the action was not "
"executed, and we are (probably) still here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:176
msgid "From this example we learn several things:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:180
msgid ""
"Values of type `IO a` are *pure descriptions* of programs, which, when being "
"*executed*, perform arbitrary side effects before returning a value of type "
"`a`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:184
msgid ""
"Values of type `IO a` can be safely returned from functions and passed "
"around as arguments or in data structures, without the risk of them being "
"executed."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:187
msgid ""
"Values of type `IO a` can be safely combined in *do blocks* to *describe* "
"new `IO` actions."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:191
msgid ""
"An `IO` action will only ever get executed when it's passed to `:exec` at "
"the REPL, or when it is the `main` function of a compiled Idris program that "
"is being executed."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:196
msgid ""
"It is not possible to ever break out of the `IO` context: There is no "
"function of type `IO a -> a`, as such a function would need to execute its "
"argument in order to extract the final result, and this would break "
"referential transparency."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:197
#, no-wrap
msgid "Combining Pure Code with `IO` Actions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:202
msgid ""
"The title of this subsection is somewhat misleading. `IO` actions *are* pure "
"values, but what is typically meant here, is that we combine non-`IO` "
"functions with effectful computations."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:208
msgid ""
"As a demonstration, in this section we are going to write a small program "
"for evaluating arithmetic expressions. We are going to keep things simple "
"and allow only expressions with a single operator and two arguments, both of "
"which must be integers, for instance `12 + 13`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:216
msgid ""
"We are going to use function `split` from `Data.String` in *base* to "
"tokenize arithmetic expressions. We are then trying to parse the two integer "
"values and the operator. These operations might fail, since user input can "
"be invalid, so we also need an error type. We could actually just use "
"`String`, but I consider it to be good practice to use custom sum types for "
"erroneous conditions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:217
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:231
msgid ""
"In order to parse integer literals, we use function `parseInteger` from "
"`Data.String`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:232
#, no-wrap
msgid ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:239
msgid ""
"Likewise, we declare and implement a function for parsing arithmetic "
"operators:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:240
#, no-wrap
msgid ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:254
msgid ""
"We are now ready to parse and evaluate simple arithmetic expressions. This "
"consists of several steps (splitting the input string, parsing each "
"literal), each of which can fail.  Later, when we learn about monads, we "
"will see that do blocks can be used in such occasions just as well. However, "
"in this case we can use an alternative syntactic convenience: Pattern "
"matching in let bindings. Here is the code:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:255
#, no-wrap
msgid ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:280
msgid ""
"Let's break this down a bit. On the first line, we split the input string at "
"all whitespace occurrences. Since `split` returns a `List1` (a type for non-"
"empty lists exported from `Data.List1` in *base*) but pattern matching on "
"`List` is more convenient, we convert the result using `Data.List1.forget`. "
"Note, how we use a pattern match on the left hand side of the assignment "
"operator `:=`.  This is a partial pattern match (*partial* meaning, that it "
"doesn't cover all possible cases), therefore we have to deal with the other "
"possibilities as well, which is done after the vertical line. This can be "
"read as follows: \"If the pattern match on the left hand side is successful, "
"and we get a list of exactly three tokens, continue with the `let` "
"expression, otherwise return a `ParseError` in a `Left` immediately\"."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:286
msgid ""
"The other three lines behave exactly the same: Each has a partial pattern "
"match on the left hand side with instructions what to return in case of "
"invalid input after the vertical bar. We will later see, that this syntax is "
"also available in *do blocks*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:294
msgid ""
"Note, how all of the functionality implemented so far is *pure*, that is, it "
"does not describe computations with side effects. (One could argue that "
"already the possibility of failure is an observable *effect*, but even then, "
"the code above is still referentially transparent, can be easily tested at "
"the REPL, and evaluated at compile time, which is the important thing here.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:298
msgid ""
"Finally, we can wrap this functionality in an `IO` action, which reads a "
"string from standard input and tries to evaluate the arithmetic expression:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:299
#, no-wrap
msgid ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:316
msgid ""
"Note, how in `exprProg` we were forced to deal with the possibility of "
"failure and handle both constructors of `Either` differently in order to "
"print a result.  Note also, that *do blocks* are ordinary expressions, and "
"we can, for instance, start a new *do block* on the right hand side of a "
"case expression."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:329
msgid ""
"In these exercises, you are going to implement some small command-line "
"applications. Some of these will potentially run forever, as they will only "
"stop when the user enters a keyword for quitting the application. Such "
"programs are no longer provably total. If you added the `%default total` "
"pragma at the top of your source file, you'll need to annotate these "
"functions with `covering`, meaning that you covered all cases in all pattern "
"matches but your program might still loop due to unrestricted recursion."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:333
msgid ""
"Implement function `rep`, which will read a line of input from the terminal, "
"evaluate it using the given function, and print the result to standard "
"output:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:334
#, no-wrap
msgid "   rep : (String -> String) -> IO ()\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:341
msgid ""
"Implement function `repl`, which behaves just like `rep` but will repeat "
"itself forever (or until being forcefully terminated):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:342
#, no-wrap
msgid ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:351
msgid ""
"Implement function `replTill`, which behaves just like `repl` but will only "
"continue looping if the given function returns a `Right`. If it returns a "
"`Left`, `replTill` should print the final message wrapped in the `Left` and "
"then stop."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:352
#, no-wrap
msgid ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:364
msgid ""
"Write a program, which reads arithmetic expressions from standard input, "
"evaluates them using `eval`, and prints the result to standard output. The "
"program should loop until users stops it by entering \"done\", in which case "
"the program should terminate with a friendly greeting.  Use `replTill` in "
"your implementation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:373
msgid ""
"Implement function `replWith`, which behaves just like `repl` but uses some "
"internal state to accumulate values.  At each iteration (including the very "
"first one!), the current state should be printed to standard output using "
"function `dispState`, and the next state should be computed using function "
"`next`.  The loop should terminate in case of a `Left` and print a final "
"message using `dispResult`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:374
#, no-wrap
msgid ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/IO.md:388
msgid ""
"Use `replWith` from Exercise 5 to write a program for reading natural "
"numbers from standard input and printing the accumulated sum of these "
"numbers.  The program should terminate in case of invalid input and if a "
"user enters \"done\"."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:389
#, no-wrap
msgid "Do Blocks, Desugared"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:402
msgid ""
"Here's an important piece of information: There is nothing special about *do "
"blocks*. They are just syntactic sugar, which is converted to a sequence of "
"operator applications.  With [syntactic sugar](https://en.wikipedia.org/wiki/"
"Syntactic_sugar), we mean syntax in a programming language that makes it "
"easier to express certain things in that language without making the "
"language itself any more powerful or expressive.  Here, it means you could "
"write all the `IO` programs without using `do` notation, but the code you'll "
"write will sometimes be harder to read, so *do blocks* provide nicer syntax "
"for these occasions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:404
msgid "Consider the following example program:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:405
#, no-wrap
msgid ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:416
msgid ""
"The compiler will convert this to the following program *before "
"disambiguating function names and type checking*:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:417
#, no-wrap
msgid ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:432
#, no-wrap
msgid ""
"There is a new operator (`(>>=)`) called *bind* in the\n"
"implementation of `desugared1`. If you look at its type\n"
"at the REPL, you'll see the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:433
#, no-wrap
msgid ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:441
msgid ""
"This is a constrained function requiring an interface called `Monad`.  We "
"will talk about `Monad` and some of its friends in the next chapter. "
"Specialized to `IO`, *bind* has the following type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:442
#, no-wrap
msgid ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:451
msgid ""
"This describes a sequencing of `IO` actions. Upon execution, the first `IO` "
"action is being run and its result is being passed as an argument to the "
"function generating the second `IO` action, which is then also being "
"executed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:466
msgid ""
"You might remember, that you already implemented something similar in an "
"earlier exercise: In [Algebraic Data Types](DataTypes.md), you implemented "
"*bind* for `Maybe` and `Either e`. We will learn in the next chapter, that "
"`Maybe` and `Either e` too come with an implementation of `Monad`. For now, "
"suffice to say that `Monad` allows us to run computations with some kind of "
"effect in sequence by passing the *result* of the first computation to the "
"function returning the second computation. In `desugared1` you can see, how "
"we first perform an `IO` action and use its result to compute the next `IO` "
"action and so on. The code is somewhat hard to read, since we use several "
"layers of nested anonymous function, that's why in such cases, *do blocks* "
"are a nice alternative to express the same functionality."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:471
msgid ""
"Since *do block* are always desugared to sequences of applied *bind* "
"operators, we can use them to chain any monadic computation. For instance, "
"we can rewrite function `eval` by using a *do block* like so:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:472
#, no-wrap
msgid ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:488
msgid ""
"Don't worry, if this doesn't make too much sense yet. We will see many more "
"examples, and you'll get the hang of this soon enough. The important thing "
"to remember is how *do blocks* are always converted to sequences of *bind* "
"operators as shown in `desugared1`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:489
#, no-wrap
msgid "Binding Unit"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:492
msgid "Remember our implementation of `friendlyReadHello`? Here it is again:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:493
#, no-wrap
msgid ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:505
msgid ""
"The underscore in there is a bit ugly and unnecessary. In fact, a common use "
"case is to just chain effectful computations with result type `Unit` (`()`), "
"merely for the side effects they perform. For instance, we could repeat "
"`friendlyReadHello` three times, like so:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:506
#, no-wrap
msgid ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:516
msgid ""
"This is such a common thing to do, that Idris allows us to drop the bound "
"underscores altogether:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:517
#, no-wrap
msgid ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:527
msgid "Note, however, that the above gets desugared slightly differently:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:528
#, no-wrap
msgid ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:538
#, no-wrap
msgid "Operator `(>>)` has the following type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:539
#, no-wrap
msgid ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:550
msgid ""
"Note the `Lazy` keyword in the type signature. This means, that the wrapped "
"argument will be *lazily evaluated*. This makes sense in many occasions. For "
"instance, if the `Monad` in question is `Maybe` the result will be `Nothing` "
"if the first argument is `Nothing`, in which case there is no need to even "
"evaluate the second argument."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:551
#, no-wrap
msgid "Do, Overloaded"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:562
#, no-wrap
msgid ""
"Because Idris supports function and operator overloading, we\n"
"can write custom *bind* operators, which allows us to\n"
"use *do notation* for types without an implementation\n"
"of `Monad`. For instance, here is a custom implementation of\n"
"`(>>=)` for sequencing computations returning vectors.\n"
"Every value in the first vector (of length `m`)\n"
"will be converted to a vector of length `n`, and\n"
"the results will be concatenated leading to\n"
"a vector of length `m * n`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:563
#, no-wrap
msgid ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:580
#, no-wrap
msgid ""
"It is not possible to write an implementation of `Monad`,\n"
"which encapsulates this behavior, as the types wouldn't\n"
"match: Monadic *bind* specialized to `Vect` has\n"
"type `Vect k a -> (a -> Vect k b) -> Vect k b`. As you\n"
"see, the sizes of all three occurrences of `Vect`\n"
"have to be the same, which is not what we expressed\n"
"in our custom version of *bind*. Here is an example to\n"
"see this in action:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:581
#, no-wrap
msgid ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:601
msgid ""
"Try to figure out how `testDo` works by desugaring it manually and then "
"comparing its result with what you expected at the REPL. Note, how we helped "
"Idris disambiguate, which version of the *bind* operator to use by prefixing "
"the `do` keyword with part of the operator's namespace.  In this case, this "
"wasn't strictly necessary, although `Vect k` does have an implementation of "
"`Monad`, but it is still good to know that it is possible to help the "
"compiler with disambiguating do blocks."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:605
#, no-wrap
msgid ""
"Of course, we can (and should!) overload `(>>)` in the\n"
"same manner as `(>>=)`, if we want to overload the\n"
"behavior of *do blocks*.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/IO.md:606
#, no-wrap
msgid "Modules and Namespaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:614
msgid ""
"Every data type, function, or operator can be unambiguously identified by "
"prefixing it with its *namespace*. A function's namespace typically is the "
"same as the module where it was defined.  For instance, the fully qualified "
"name of function `eval` would be `Tutorial.IO.eval`. Function and operator "
"names must be unique in their namespace."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:620
msgid ""
"As we already learned, Idris can often disambiguate between functions with "
"the same name but defined in different namespaces based on the types "
"involved. If this is not possible, we can help the compiler by *prefixing* "
"the function or operator name with a *suffix* of the full namespace. Let's "
"demonstrate this at the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:621
#, no-wrap
msgid ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:633
#, no-wrap
msgid ""
"As you can see, if we load this module in a REPL session and\n"
"inspect the type of `(>>=)`, we get two results as two\n"
"operators with this name are in scope. If we only want\n"
"the REPL to print the type of our custom *bind* operator,\n"
"is is sufficient to prefix it with `IO`, although we could\n"
"also prefix it with its full namespace:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:634
#, no-wrap
msgid ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:649
msgid ""
"Since function names must be unique in their namespace and we still may want "
"to define two overloaded versions of a function in an Idris module, Idris "
"makes it possible to add additional namespaces to modules. For instance, in "
"order to define another function called `eval`, we need to add it to its own "
"namespace (note, that all definitions in a namespace must be indented by the "
"same amount of white space):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:650
#, no-wrap
msgid ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:665
msgid ""
"Now, here is an important thing: For functions and data types to be "
"accessible from outside their namespace or module, they need to be "
"*exported* by annotating them with the `export` or `public export` keywords."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:674
msgid ""
"The difference between `export` and `public export` is the following: A "
"function annotated with `export` exports its type and can be called from "
"other namespaces. A data type annotated with `export` exports its type "
"constructor but not its data constructors.  A function annotated with "
"`public export` also exports its implementation. This is necessary to use "
"the function in compile-time computations. A data type annotated with "
"`public export` exports its data constructors as well."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:680
msgid ""
"In general, consider annotating data types with `public export`, since "
"otherwise you will not be able to create values of these types or "
"deconstruct them in pattern matches. Likewise, unless you plan to use your "
"functions in compile-time computations, annotate them with `export`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:681
#, no-wrap
msgid "Bind, with a Bang"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:688
msgid ""
"Sometimes, even *do blocks* are too noisy to express a combination of "
"effectful computations. In this case, we can prefix the effectful parts with "
"an exclamation mark (wrapping them in parentheses if they contain additional "
"white space), while leaving pure expressions unmodified:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:689
#, no-wrap
msgid ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:695
msgid "The above gets desugared to the following *do block*:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:696
#, no-wrap
msgid ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:704
msgid "Here is another example:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:705
#, no-wrap
msgid ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:712
msgid "And here is the desugared *do block*:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:713
#, no-wrap
msgid ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:727
msgid ""
"Please remember the following: Syntactic sugar has been introduced to make "
"code more readable or more convenient to write. If it is abused just to show "
"how clever you are, you make things harder for other people (including your "
"future self!)  reading and trying to understand your code."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:733
msgid ""
"Reimplement the following *do blocks*, once by using *bang notation*, and "
"once by writing them in their desugared form with nested *bind*s:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:734
#, no-wrap
msgid ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:752
msgid ""
"Below is the definition of an indexed family of types, the index of which "
"keeps track of whether the value in question is possibly empty or provably "
"non-empty:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:766
#, no-wrap
msgid ""
"   Please note, that the `Nil` case *must* have the `nonEmpty`\n"
"   tag set to `False`, while with the *cons* case, this is\n"
"   optional. So, a `List01 False a` can be empty or non-empty,\n"
"   and we'll only find out, which is the case, by pattern\n"
"   matching on it. A `List01 True a` on the other hand *must*\n"
"   be a *cons*, as for the `Nil` case the `nonEmpty` tag is\n"
"   always set to `False`.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/IO.md:768
msgid "Declare and implement function `head` for non-empty lists:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:772
#, no-wrap
msgid ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/IO.md:776
msgid ""
"Declare and implement function `weaken` for converting any `List01 ne a` to "
"a `List01 False a` of the same length and order of values."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/IO.md:779
msgid ""
"Declare and implement function `tail` for extracting the possibly empty tail "
"from a non-empty list."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/IO.md:784
msgid ""
"Implement function `(++)` for concatenating two values of type `List01`. "
"Note, how we use a type-level computation to make sure the result is non-"
"empty if and only if at least one of the two arguments is non-empty:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:788
#, no-wrap
msgid ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/IO.md:794
msgid ""
"Implement utility function `concat'` and use it in the implementation of "
"`concat`. Note, that in `concat` the two boolean tags are passed as "
"unrestricted implicits, since you will need to pattern match on these to "
"determine whether the result is provably non-empty or not:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:797
#, no-wrap
msgid ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:802
#, no-wrap
msgid ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/IO.md:804
msgid "Implement `map01`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:808
#, no-wrap
msgid ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/IO.md:811
msgid ""
"Implement a custom *bind* operator in namespace `List01` for sequencing "
"computations returning `List01`s."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:814
#, no-wrap
msgid ""
"      Hint: Use `map01` and `concat` in your implementation and\n"
"      make sure to use unrestricted implicits where necessary.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:817
#, no-wrap
msgid ""
"      You can use the following examples to test your\n"
"      custom *bind* operator:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:823
#, no-wrap
msgid ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:826
#, no-wrap
msgid ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:833
#, no-wrap
msgid ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:841
#, no-wrap
msgid ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:857
msgid ""
"Some notes on Exercise 2: Here, we combined the capabilities of `List` and "
"`Data.List1` in a single indexed type family.  This allowed us to treat list "
"concatenation correctly: If at least one of the arguments is provably non-"
"empty, the result is also non-empty. To tackle this correctly with `List` "
"and `List1`, a total of four concatenation functions would have to be "
"written. So, while it is often possible to define distinct data types "
"instead of indexed families, the latter allow us to perform type-level "
"computations to be more precise about the pre- and postconditions of the "
"functions we write, at the cost of more-complex type signatures.  In "
"addition, sometimes it's not possible to derive the values of the indices "
"from pattern matching on the data values alone, so they have to be passed as "
"unerased (possibly implicit) arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:864
msgid ""
"Please remember, that *do blocks* are first desugared, before type-checking, "
"disambiguating which *bind* operator to use, and filling in implicit "
"arguments. It is therefore perfectly fine to define *bind* operators with "
"arbitrary constraints or implicit arguments as was shown above. Idris will "
"handle all the details, *after* desugaring the *do blocks*."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:865
#, no-wrap
msgid "Working with Files"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:872
msgid ""
"Module `System.File` from the *base* library exports utilities necessary to "
"work with file handles and read and write from and to files. When you have a "
"file path (for instance \"/home/hock/idris/tutorial/tutorial.ipkg\"), the "
"first thing we will typically do is to try and create a file handle (of type "
"`System.File.File` by calling `fileOpen`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:874
msgid "Here is a program for counting all empty lines in a Unix/Linux-file:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:875
#, no-wrap
msgid ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:894
#, no-wrap
msgid ""
"In the example above, I invoked `(>>=)` without starting a *do block*.\n"
"Make sure you understand what's going on here. Reading concise functional\n"
"code is important in order to understand other people's code.\n"
"Have a look at function `either` at the REPL, try figuring out what\n"
"`(pure . Left)` does, and note how we use a curried version of `go`\n"
"as the second argument to `either`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:905
msgid ""
"Function `go` calls for some additional explanations. First, note how we "
"used the same syntax for pattern matching intermediary results as we also "
"saw for `let` bindings. As you can see, we can use several vertical bars to "
"handle more than one additional pattern. In order to read a single line from "
"a file, we use function `fGetLine`. As with most operations working with the "
"file system, this function might fail with a `FileError`, which we have to "
"handle correctly. Note also, that `fGetLine` will return the line including "
"its trailing newline character `'\\n'`, so in order to check for empty "
"lines, we have to match against `\"\\n\"` instead of the empty string `\"\"`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:910
msgid ""
"Finally, `go` is not provably total and rightfully so.  Files like `/dev/"
"urandom` or `/dev/zero` provide infinite streams of data, so `countEmpty` "
"will never terminate when invoked with such a file path."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:911
#, no-wrap
msgid "Safe Resource Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:919
msgid ""
"Note, how we had to manually open and close the file handle in `countEmpty`. "
"This is error-prone and tedious. Resource handling is a big topic, and we "
"definitely won't be going into the details here, but there is a convenient "
"function exported from `System.File`: `withFile`, which handles the opening, "
"closing and handling of file errors for us."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:920
#, no-wrap
msgid ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:937
msgid ""
"Go ahead, and have a look at the type of `withFile`, then have a look how we "
"use it to simplify the implementation of `countEmpty'`. Reading and "
"understanding slightly more complex function types is important when "
"learning to program in Idris."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/IO.md:938
#, no-wrap
msgid "Interface `HasIO`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:948
msgid ""
"When you look at the `IO` functions we used so far, you'll notice that most "
"if not all of them actually don't work with `IO` itself but with a type "
"parameter `io` with a constraint of `HasIO`. This interface allows us to "
"*lift* a value of type `IO a` into another context. We will see use cases "
"for this in later chapters, especially when we talk about monad "
"transformers. For now, you can treat these `io` parameters as being "
"specialized to `IO`."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:959
msgid ""
"As we have seen in the examples above, `IO` actions working with file "
"handles often come with the risk of failure. We can therefore simplify "
"things by writing some utility functions and a custom *bind* operator to "
"work with these nested effects. In a new namespace `IOErr`, implement the "
"following utility functions and use these to further cleanup the "
"implementation of `countEmpty'`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:960
#, no-wrap
msgid ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:977
msgid ""
"Write a function `countWords` for counting the words in a file.  Consider "
"using `Data.String.words` and the utilities from exercise 1 in your "
"implementation."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:983
msgid ""
"We can generalize the functionality used in `countEmpty` and `countWords`, "
"by implementing a helper function for iterating over the lines in a file and "
"accumulating some state along the way. Implement `withLines` and use it to "
"reimplement `countEmpty` and `countWords`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:984
#, no-wrap
msgid ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:996
msgid ""
"We often use a `Monoid` for accumulating values.  It is therefore convenient "
"to specialize `withLines` for this case. Use `withLines` to implement "
"`foldLines` according to the type given below:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:997
#, no-wrap
msgid ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:1012
msgid ""
"Implement function `wordCount` for counting the number of lines, words, and "
"characters in a text document. Define a custom record type together with an "
"implementation of `Monoid` for storing and accumulating these values and use "
"`foldLines` in your implementation of `wordCount`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:1013
#, no-wrap
msgid "How `IO` is Implemented"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1019
msgid ""
"In this final section of an already lengthy chapter, we will risk a glance "
"at how `IO` is implemented in Idris. It is interesting to note, that `IO` is "
"not a built-in type but a regular data type with only one minor speciality. "
"Let's learn about it at the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1020
#, no-wrap
msgid ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1037
msgid ""
"Here, we learn that `IO` has a single data constructor called `MkIO`, which "
"takes a single argument of type `PrimIO a` with quantity *1*. We are not "
"going to talk about the quantities here, as in fact they are not important "
"to understand how `IO` works."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1039
msgid "Now, `PrimIO a` is a type alias for the following function:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1040
#, no-wrap
msgid ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1049
msgid ""
"Again, don't mind the quantities. There is only one piece of the puzzle "
"missing: `IORes a`, which is a publicly exported record type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1050
#, no-wrap
msgid ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1059
msgid ""
"So, to put this all together, `IO` is a wrapper around something similar to "
"the following function type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1060
#, no-wrap
msgid "%World -> (a, %World)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1072
msgid ""
"You can think of type `%World` as a placeholder for the state of the outside "
"world of a program (file system, memory, network connections, and so on). "
"Conceptually, to execute an `IO a` action, we pass it the current state of "
"the world, and in return get an updated world state plus a result of type "
"`a`. The world state being updated represents all the side effects "
"describable in a computer program."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1088
msgid ""
"Now, it is important to understand that there is no such thing as the *state "
"of the world*. The `%World` type is just a placeholder, which is converted "
"to some kind of constant that's passed around and never inspected at "
"runtime. So, if we had a value of type `%World`, we could pass it to an `IO "
"a` action and execute it, and this is exactly what happens at runtime: A "
"single value of type `%World` (an uninteresting placeholder like `null`, "
"`0`, or - in case of the JavaScript backends - `undefined`)  is passed to "
"the `main` function, thus setting the whole program in motion. However, it "
"is impossible to programmatically create a value of type `%World` (it is an "
"abstract, primitive type), and therefore we cannot ever extract a value of "
"type `a` from an `IO a` action (modulo `unsafePerformIO`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1094
msgid ""
"Once we will talk about monad transformers and the state monad, you will see "
"that `IO` is nothing else but a state monad in disguise but with an abstract "
"state type, which makes it impossible for us to run the stateful computation."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1099
msgid ""
"Values of type `IO a` describe programs with side effects, which will "
"eventually result in a value of type `a`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1104
msgid ""
"While we cannot safely extract a value of type `a` from an `IO a`, we can "
"use several combinators and syntactic constructs to combine `IO` actions and "
"build more-complex programs."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1107
msgid ""
"*Do blocks* offer a convenient way to run and combine `IO` actions "
"sequentially."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1110
msgid ""
"*Do blocks* are desugared to nested applications of *bind* operators "
"(`(>>=)`)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1114
msgid ""
"*Bind* operators, and thus *do blocks*, can be overloaded to achieve custom "
"behavior instead of the default (monadic) *bind*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1117
msgid ""
"Under the hood, `IO` actions are stateful computations operating on a "
"symbolic `%World` state."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1123
msgid ""
"Now, that we had a glimpse at *monads* and the *bind* operator, it is time "
"to in the [next chapter](Functor.md) introduce `Monad` and some related "
"interfaces for real."
msgstr ""
