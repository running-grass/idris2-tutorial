# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-03 13:26+0800\n"
"PO-Revision-Date: 2022-08-03 05:18+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2-tutorial/io/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr "idris"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr "repl"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, fuzzy, no-wrap
msgid "Exercises part 1"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:622
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, fuzzy, no-wrap
msgid "Exercises part 2"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:842
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, fuzzy, no-wrap
msgid "Exercises part 3"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:871
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:903
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr "下一步是什么"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, fuzzy, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"   ```伊德里斯\n"
"   数据 List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     无：List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
"   ```\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Title #
#: ../src/Tutorial/IO.md:1
#, fuzzy, no-wrap
msgid "IO: Programming with Side Effects"
msgstr "# IO：有副作用的编程"

#. type: Plain text
#: ../src/Tutorial/IO.md:7
#, fuzzy, no-wrap
msgid ""
"So far, all our examples and exercises dealt with pure, total functions.\n"
"We didn't read or write content from or to files, nor did\n"
"we write any messages to the standard output. It is time to change\n"
"that and learn, how we can write effectful programs in Idris.\n"
msgstr "到目前为止，我们所有的例子和练习都是关于纯函数的。我们没有从文件读取或写入内容，也没有将任何消息写入标准输出。是时候改变这一点并学习如何在 Idris 中编写有效的程序了。"

#. type: Plain text
#: ../src/Tutorial/IO.md:8
#, fuzzy, no-wrap
msgid ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr "导入 Data.Either 导入 Data.List1 导入 Data.String 导入 Data.Vect 导入 Data.HList 导入 Decidable.Equality"

#. type: Title ##
#: ../src/Tutorial/IO.md:20
#, fuzzy, no-wrap
msgid "Pure Side Effects?"
msgstr "## 纯副作用？"

#. type: Plain text
#: ../src/Tutorial/IO.md:24
#, fuzzy, no-wrap
msgid ""
"If we once again look at the *hello world* example from the\n"
"[introduction](Intro.md), it had the following type and implementation:\n"
msgstr "如果我们再次查看 [introduction](Intro.md) 中的 *hello world* 示例，它具有以下类型和实现："

#. type: Plain text
#: ../src/Tutorial/IO.md:25
#, fuzzy, no-wrap
msgid ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"
msgstr "```idris hello : IO () hello = putStrLn \"Hello World!\" ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:32
#, fuzzy, no-wrap
msgid ""
"If you load this module in a REPL session and evaluate `hello`,\n"
"you'll get the following:\n"
msgstr "如果您在 REPL 会话中加载此模块并评估 `hello`，您将获得以下信息："

#. type: Plain text
#: ../src/Tutorial/IO.md:33
#, fuzzy, no-wrap
msgid ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"
msgstr "```repl Tutorial.IO> hello MkIO (prim__putStr \"Hello World!\") ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:41
#, fuzzy, no-wrap
msgid ""
"This might not be what you expected, given that we'd actually wanted the\n"
"program to just print \"Hello World!\". In order to explain what's going\n"
"on here, we need to quickly look at how evaluation at the REPL works.\n"
msgstr "这可能不是您所期望的，因为我们实际上希望程序只打印“Hello World！”。为了解释这里发生了什么，我们需要快速了解 REPL 的评估是如何工作的。"

#. type: Plain text
#: ../src/Tutorial/IO.md:51
#, fuzzy, no-wrap
msgid ""
"When we evaluate some expression at the REPL, Idris tries to\n"
"reduce it to a value until it gets stuck somewhere. In the above case,\n"
"Idris gets stuck at function `prim__putStr`. This is\n"
"a *foreign function* defined in the *Prelude*, which has to be implemented\n"
"by each backend in order to be available there. At compile time (and at the REPL),\n"
"Idris knows nothing about the implementations of foreign functions\n"
"and therefore can't reduce foreign function calls, unless they are\n"
"built into the compiler itself. But even then, values of type `IO a`\n"
"(`a` being a type parameter) are typically not reduced.\n"
msgstr "当我们在 REPL 中评估某个表达式时，Idris 会尝试将其减少为一个值，直到它卡在某个地方。在上述情况下，Idris 卡在函数 `prim__putStr` 上。这是在 *Prelude* 中定义的 * 外部函数*，必须由每个后端实现才能在那里可用。在编译时（以及在 REPL 中），Idris 对外部函数的实现一无所知，因此无法减少外部函数调用，除非它们内置于编译器本身中。但即便如此，`IO a` 类型的值（`a` 是一个类型参数）通常不会减少。"

#. type: Plain text
#: ../src/Tutorial/IO.md:61
#, fuzzy, no-wrap
msgid ""
"It is important to understand that values of type `IO a` *describe*\n"
"a program, which, when being *executed*, will return a value of type `a`,\n"
"after performing arbitrary side effects along the way. For instance,\n"
"`putStrLn` has type `String -> IO ()`. Read this as: \"`putStrLn` is a function,\n"
"which, when given a `String` argument, will return a description of\n"
"an effectful program with an output type of `()`\".\n"
"(`()` is syntactic sugar for type `Unit`, the\n"
"empty tuple defined at the *Prelude*, which has only one value called `MkUnit`,\n"
"for which we can also use `()` in our code.)\n"
msgstr "重要的是要理解 `IO a` * 类型的值描述 * 一个程序，当 * 执行 * 时，将返回 `a[ 类型的值X139X]，在一路执行任意副作用之后。例如，`putStrLn` 的类型为 `String -> IO ()`。将其读作：“`putStrLn` 是一个函数，当给定一个 `String` 参数时，它将返回一个输出类型为 `()` 的有效程序的描述]”。 (`()` 是 `Unit` 类型的语法糖，在 *Prelude* 中定义的空元组，它只有一个值称为 `MkUnit`，我们也可以在我们的代码中使用 `()`。）"

#. type: Plain text
#: ../src/Tutorial/IO.md:72
#, fuzzy, no-wrap
msgid ""
"Since values of type `IO a` are mere descriptions of effectful computations,\n"
"functions returning such values or taking such values as\n"
"arguments are still *pure* and thus referentially transparent.\n"
"It is, however, not possible to extract a value of type `a` from\n"
"a value of type `IO a`, that is, there is no generic function `IO a -> a`,\n"
"as such a function would inadvertently execute the side\n"
"effects when extracting the result from its argument,\n"
"thus breaking referential transparency.\n"
"(Actually, there *is* such a function called `unsafePerformIO`.\n"
"Do not ever use it in your code unless you know what you are doing.)\n"
msgstr "由于 `IO a` 类型的值仅仅是对有效计算的描述，因此返回此类值或将此类值作为参数的函数仍然是 * 纯 * 并且因此是引用透明的。但是，不可能从 `IO a` 类型的值中提取 `a` 类型的值，也就是说，没有通用函数 `IO a -> a `，因为这样的函数在从其参数中提取结果时会无意中执行副作用，从而破坏引用透明度。 （实际上，有 * 是 * 这样一个名为 `unsafePerformIO` 的函数。除非您知道自己在做什么，否则不要在代码中使用它。）"

#. type: Title ###
#: ../src/Tutorial/IO.md:73
#, fuzzy, no-wrap
msgid "Do Blocks"
msgstr "### 做积木"

#. type: Plain text
#: ../src/Tutorial/IO.md:83
#, fuzzy, no-wrap
msgid ""
"If you are new to pure functional programming, you might now - rightfully -\n"
"mumble something about how useless it is to\n"
"have descriptions of effectful programs without being able to run them.\n"
"So please, hear me out. While we are not able to run values of type\n"
"`IO a` when writing programs, that is, there is no function of\n"
"type `IO a -> a`, we are able to chain such computations and describe more\n"
"complex programs. Idris provides special syntax for this: *Do blocks*.\n"
"Here's an example:\n"
msgstr "如果您是纯函数式编程的新手，那么您现在可能会——理所当然地——咕哝一些关于如果无法运行有效程序的描述是多么无用的话。所以，请听我说完。虽然我们在编写程序时无法运行 `IO a` 类型的值，也就是说，没有 `IO a -> a` 类型的函数，但我们能够链接这样的计算并描述更复杂的程序。 Idris 为此提供了特殊语法：*Do blocks*。这是一个例子："

#. type: Plain text
#: ../src/Tutorial/IO.md:84
#, fuzzy, no-wrap
msgid ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"
msgstr ""
"```伊德里斯\n"
"读你好：IO（）\n"
"读你好=做\n"
"  名称<-getLine\n"
"  putStrLn $“你好”++名字++“！”\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:93
#, fuzzy, no-wrap
msgid ""
"Before we talk about what's going on here, let's give this a go at\n"
"the REPL:\n"
msgstr "在我们谈论这里发生的事情之前，让我们在 REPL 上试一试："

#. type: Plain text
#: ../src/Tutorial/IO.md:94
#, fuzzy, no-wrap
msgid ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"
msgstr "```repl Tutorial.IO> :exec readHello Stefan 你好 Stefan！ ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:104
#, fuzzy, no-wrap
msgid ""
"This is an interactive program, which will read a line from standard\n"
"input (`getLine`), assign the result to variable `name`, and then\n"
"use `name` to create a friendly greeting and write it to\n"
"standard output.\n"
msgstr "这是一个交互式程序，它将从标准输入 (`getLine`) 中读取一行，将结果赋值给变量 `name`，然后使用 `name` 创建一个友好的问候并将其写入标准输出。"

#. type: Plain text
#: ../src/Tutorial/IO.md:114
#, fuzzy, no-wrap
msgid ""
"Note the `do` keyword at the beginning of the implementation of `readHello`:\n"
"It starts a *do block*, where we can chain `IO` computations and bind\n"
"intermediary results to variables using arrows pointing\n"
"to the left (`<-`), which can then be used in later\n"
"`IO` actions. This concept is powerful enough to let us encapsulate arbitrary\n"
"programs with side effects in a single value of type `IO`. Such a\n"
"description can then be returned by function `main`, the main entry point\n"
"to an Idris program, which is being executed when we run a compiled\n"
"Idris binary.\n"
msgstr "注意 `readHello` 实现开始时的 `do` 关键字：它启动了一个 *do 块*，我们可以在其中链接 `IO` 计算和使用指向左侧的箭头 (`<-`) 将中间结果绑定到变量，然后可以在以后的 `IO` 操作中使用。这个概念足够强大，可以让我们将具有副作用的任意程序封装在 `IO` 类型的单个值中。然后可以通过函数 `main` 返回这样的描述，这是 Idris 程序的主入口点，当我们运行已编译的 Idris 二进制文件时，该程序正在执行。"

#. type: Title ###
#: ../src/Tutorial/IO.md:115
#, fuzzy, no-wrap
msgid "The Difference between Program Description and Execution"
msgstr "### 程序描述和执行的区别"

#. type: Plain text
#: ../src/Tutorial/IO.md:120
#, fuzzy, no-wrap
msgid ""
"In order to better understand the difference between *describing*\n"
"an effectful computation and *executing* or *running* it, here is a small\n"
"program:\n"
msgstr "为了更好地理解*描述*有效计算和*执行*或*运行*之间的区别，这里有一个小程序："

#. type: Plain text
#: ../src/Tutorial/IO.md:121
#, fuzzy, no-wrap
msgid ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"
msgstr ""
"发射导弹：IO（）\n"
"\" launchMissiles = putStrLn \"轰！你死了。\"\n"
"\n"
"友好读你好：IO（）\n"
"友好读你好 = 做\n"
"  _ <- putStrLn \"请输入您的姓名。\"\n"
"  读你好\n"
"\n"
"行动：Vect 3 (IO ())\n"
"动作 = [launchMissiles，friendlyReadHello，friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = 去 xs\n"
"  去哪里： Vect k (IO ()) -> IO ()\n"
"        去 [] = 纯 ()\n"
"        去（y :: ys）=做\n"
"          _ <- 是\n"
"          去吧\n"
"\n"
"读你好：IO（）\n"
"readHellos = runActions 动作\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:153
#, fuzzy, no-wrap
msgid ""
"Before I explain what the code above does, please note function\n"
"`pure` used in the implementation of `runActions`. It is\n"
"a constrained function, about which we will learn in the next\n"
"chapter. Specialized to `IO`, it has generic type `a -> IO a`:\n"
"It allows us to wrap a value in an `IO` action. The resulting\n"
"`IO` program will just return the wrapped value without performing\n"
"any side effects. We can now look at the big picture of what's\n"
"going on in `readHellos`.\n"
msgstr "在我解释上面代码的作用之前，请注意 `runActions` 的实现中使用的函数 `pure`。它是一个受约束的函数，我们将在下一章中学习。专门用于 `IO`，它具有通用类型 `a -> IO a`：它允许我们将值包装在 `IO` 动作中。生成的 `IO` 程序将只返回包装后的值，而不会执行任何副作用。我们现在可以看一下 `readHellos` 中发生的事情的总体情况。"

#. type: Plain text
#: ../src/Tutorial/IO.md:160
#, fuzzy, no-wrap
msgid ""
"First, we define a friendlier version of `readHello`: When executed, this will\n"
"ask about our name explicitly. Since we will not use the result\n"
"of `putStrLn` any further, we can use an underscore as a catch-all\n"
"pattern here. Afterwards, `readHello` is invoked. We also define\n"
"`launchMissiles`, which, when being executed, will lead to the\n"
"destruction of planet earth.\n"
msgstr "首先，我们定义了一个更友好的 `readHello` 版本：当执行时，它会明确询问我们的名字。由于我们将不再使用 `putStrLn` 的结果，因此我们可以在这里使用下划线作为包罗万象的模式。之后，调用 `readHello`。我们还定义了`launchMissiles`，执行时会导致地球毁灭。"

#. type: Plain text
#: ../src/Tutorial/IO.md:169
#, fuzzy, no-wrap
msgid ""
"Now, `runActions` is the function we use to\n"
"demonstrate that *describing* an `IO` action is not the\n"
"same as *running* it. It will drop the first action from\n"
"the non-empty vector it takes as its\n"
"argument and return a new `IO` action, which describes the\n"
"execution of the remaining `IO` actions in sequence. If this behaves\n"
"as expected, the first `IO` action passed to `runActions` should be\n"
"silently dropped together with all its potential side effects.\n"
msgstr "现在，`runActions` 是我们用来证明 * 描述 * 和 `IO` 动作与 * 运行 * 动作不同的函数。它将从作为参数的非空向量中删除第一个动作，并返回一个新的 `IO` 动作，它描述了按顺序执行剩余的 `IO` 动作。如果这符合预期，则传递给 `runActions` 的第一个 `IO` 操作应连同其所有潜在副作用一起被静默删除。"

#. type: Plain text
#: ../src/Tutorial/IO.md:174
#, fuzzy, no-wrap
msgid ""
"When we execute `readHellos` at the REPL, we will be asked for our\n"
"name twice, although `actions` also contains `launchMissiles` at the\n"
"beginning. Luckily, although we described how to destroy the planet,\n"
"the action was not executed, and we are (probably) still here.\n"
msgstr "当我们在 REPL 中执行 `readHellos` 时，我们会被要求输入我们的名字两次，尽管 `actions` 开头也包含 `launchMissiles`。幸运的是，虽然我们描述了如何摧毁地球，但行动并未执行，我们（可能）还在这里。"

#. type: Plain text
#: ../src/Tutorial/IO.md:176
#, fuzzy, no-wrap
msgid "From this example we learn several things:\n"
msgstr "从这个例子中，我们学到了几件事："

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:180
#, fuzzy
msgid ""
"Values of type `IO a` are *pure descriptions* of programs, which, when being "
"*executed*, perform arbitrary side effects before returning a value of type "
"`a`."
msgstr ""
"`IO a` 类型的值是程序的 * 纯描述 *，当被 * 执行 * 时，在返回 `a[ 类型的值之前"
"执行任意副作用X155X]。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:184
#, fuzzy
msgid ""
"Values of type `IO a` can be safely returned from functions and passed "
"around as arguments or in data structures, without the risk of them being "
"executed."
msgstr ""
"`IO a` 类型的值可以安全地从函数返回并作为参数或在数据结构中传递，而不会有被执"
"行的风险。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:187
#, fuzzy
msgid ""
"Values of type `IO a` can be safely combined in *do blocks* to *describe* "
"new `IO` actions."
msgstr "`IO a` 类型的值可以安全地组合在 *do 块 * 到 * 描述 * 新 `IO` 动作中。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:191
#, fuzzy
msgid ""
"An `IO` action will only ever get executed when it's passed to `:exec` at "
"the REPL, or when it is the `main` function of a compiled Idris program that "
"is being executed."
msgstr ""
"一个 `IO` 动作只会在它被传递给 REPL 的 `:exec` 或者当它是已编译的 Idris 程序"
"的 `main` 函数时才会被执行。被执行。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:196
#, fuzzy
msgid ""
"It is not possible to ever break out of the `IO` context: There is no "
"function of type `IO a -> a`, as such a function would need to execute its "
"argument in order to extract the final result, and this would break "
"referential transparency."
msgstr ""
"永远不可能跳出 `IO` 上下文：没有 `IO a -> a` 类型的函数，因为这样的函数需要执"
"行它的参数才能提取最终结果，这将破坏参考透明度。"

#. type: Title ###
#: ../src/Tutorial/IO.md:197
#, fuzzy, no-wrap
msgid "Combining Pure Code with `IO` Actions"
msgstr "### 结合纯代码和 `IO` 动作"

#. type: Plain text
#: ../src/Tutorial/IO.md:202
#, fuzzy, no-wrap
msgid ""
"The title of this subsection is somewhat misleading. `IO` actions\n"
"*are* pure values, but what is typically meant here, is that we\n"
"combine non-`IO` functions with effectful computations.\n"
msgstr "本小节的标题有些误导。 `IO` 动作 * 是 * 纯值，但这里通常的意思是我们将非 `IO` 函数与有效计算相结合。"

#. type: Plain text
#: ../src/Tutorial/IO.md:208
#, fuzzy, no-wrap
msgid ""
"As a demonstration, in this section we are going to write a small\n"
"program for evaluating arithmetic expressions. We are going to\n"
"keep things simple and allow only expressions with a single\n"
"operator and two arguments, both of which must be integers,\n"
"for instance `12 + 13`.\n"
msgstr "作为演示，在本节中，我们将编写一个用于计算算术表达式的小程序。我们将保持简单，只允许具有单个运算符和两个参数的表达式，这两个参数都必须是整数，例如 `12 + 13`。"

#. type: Plain text
#: ../src/Tutorial/IO.md:216
#, fuzzy, no-wrap
msgid ""
"We are going to use function `split` from `Data.String` in\n"
"*base* to tokenize arithmetic expressions. We are then trying\n"
"to parse the two integer values and the operator. These operations\n"
"might fail, since user input can be invalid, so we also need an\n"
"error type. We could actually just use `String`, but I\n"
"consider it to be good practice to use custom sum types\n"
"for erroneous conditions.\n"
msgstr "我们将使用 *base* 中 `Data.String` 中的函数 `split` 来标记算术表达式。然后我们尝试解析两个整数值和运算符。这些操作可能会失败，因为用户输入可能无效，所以我们还需要一个错误类型。我们实际上可以只使用 `String`，但我认为对错误条件使用自定义求和类型是一种好习惯。"

#. type: Plain text
#: ../src/Tutorial/IO.md:217
#, fuzzy, no-wrap
msgid ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"
msgstr ""
"dispError : 错误 -> 字符串\n"
"dispError (NotAnInteger v) = \"不是整数：\" ++ v ++ \"。\"\n"
"dispError (UnknownOperator v) = \"未知运算符：\" ++ v ++ \"。\"\n"
"dispError (ParseError v) = \"无效表达式：\" ++ v ++ \"。\"\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:231
#, fuzzy, no-wrap
msgid ""
"In order to parse integer literals, we use function `parseInteger`\n"
"from `Data.String`:\n"
msgstr "为了解析整数文字，我们使用来自 `Data.String` 的函数 `parseInteger`："

#. type: Plain text
#: ../src/Tutorial/IO.md:232
#, fuzzy, no-wrap
msgid ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"
msgstr "```idris readInteger : String -> Either Error Integer readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:239
#, fuzzy, no-wrap
msgid ""
"Likewise, we declare and implement a function for parsing\n"
"arithmetic operators:\n"
msgstr "同样，我们声明并实现了一个解析算术运算符的函数："

#. type: Plain text
#: ../src/Tutorial/IO.md:240
#, fuzzy, no-wrap
msgid ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"
msgstr ""
"```伊德里斯\n"
"readOperator : 字符串 -> 任一错误（整数 -> 整数 -> 整数）\n"
"readOperator \"+\" = 右 (+)\n"
"readOperator \"*\" = 右 (*)\n"
"readOperator s = 左（UnknownOperator s）\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:254
#, fuzzy, no-wrap
msgid ""
"We are now ready to parse and evaluate simple arithmetic\n"
"expressions. This consists of several steps (splitting the\n"
"input string, parsing each literal), each of which can fail.\n"
"Later, when we learn about monads, we will see that do\n"
"blocks can be used in such occasions just as well. However,\n"
"in this case we can use an alternative syntactic convenience:\n"
"Pattern matching in let bindings. Here is the code:\n"
msgstr "我们现在准备解析和评估简单的算术表达式。这包括几个步骤（拆分输入字符串，解析每个文字），每个步骤都可能失败。稍后，当我们了解 monad 时，我们会看到 do 块也可以在这种情况下使用。但是，在这种情况下，我们可以使用另一种语法便利：let 绑定中的模式匹配。这是代码："

#. type: Plain text
#: ../src/Tutorial/IO.md:255
#, fuzzy, no-wrap
msgid ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"
msgstr ""
"```伊德里斯\n"
"eval : String -> 任一错误整数\n"
"评估 s =\n"
"  让 [x,y,z] := 忘记 $ split isSpace s | _ => 左（ParseError s）\n"
"      右 v1 := readInteger x |左 e => 左 e\n"
"      右操作 := readOperator y |左 e => 左 e\n"
"      右 v2 := readInteger z |左 e => 左 e\n"
"   在右 $ op v1 v2\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:280
#, fuzzy, no-wrap
msgid ""
"Let's break this down a bit. On the first line, we split\n"
"the input string at all whitespace occurrences. Since\n"
"`split` returns a `List1` (a type for non-empty lists\n"
"exported from `Data.List1` in *base*) but pattern matching\n"
"on `List` is more convenient, we convert the result using\n"
"`Data.List1.forget`. Note, how we use a pattern match\n"
"on the left hand side of the assignment operator `:=`.\n"
"This is a partial pattern match (*partial* meaning,\n"
"that it doesn't cover all possible cases), therefore we have\n"
"to deal with the other possibilities as well, which is\n"
"done after the vertical line. This can be read as follows:\n"
"\"If the pattern match on the left hand side is successful,\n"
"and we get a list of exactly three tokens, continue with\n"
"the `let` expression, otherwise return a `ParseError` in\n"
"a `Left` immediately\".\n"
msgstr "让我们分解一下。在第一行，我们在所有出现的空格处拆分输入字符串。由于 `split` 返回 `List1` （从 *base* 中的 `Data.List1` 导出的非空列表的类型），但在 [ X227X]List`更方便，我们使用`Data.List1.forget`转换结果。请注意，我们如何在赋值运算符 `:=` 的左侧使用模式匹配。这是一个部分模式匹配（*partial* 的意思，它没有涵盖所有可能的情况），因此我们还必须处理其他可能性，这是在垂直线之后完成的。可以这样理解：“如果左侧的模式匹配成功，并且我们得到一个正好包含三个标记的列表，则继续使用 `let` 表达式，否则返回 `ParseError[ X787X] 在 ` 左 ` 立即\"。"

#. type: Plain text
#: ../src/Tutorial/IO.md:286
#, fuzzy, no-wrap
msgid ""
"The other three lines behave exactly the same: Each has\n"
"a partial pattern match on the left hand side with\n"
"instructions what to return in case of invalid input after\n"
"the vertical bar. We will later see, that this syntax is also\n"
"available in *do blocks*.\n"
msgstr "其他三行的行为完全相同：每一行在左侧都有一个部分模式匹配，指示在竖线后输入无效时返回的内容。我们稍后会看到，这种语法也可以在 *do blocks* 中使用。"

#. type: Plain text
#: ../src/Tutorial/IO.md:294
#, fuzzy, no-wrap
msgid ""
"Note, how all of the functionality implemented so far is\n"
"*pure*, that is, it does not describe computations with\n"
"side effects. (One could argue that already the possibility\n"
"of failure is an observable *effect*, but even then, the code above\n"
"is still referentially transparent,\n"
"can be easily tested at the REPL, and evaluated at\n"
"compile time, which is the important thing here.)\n"
msgstr "请注意，到目前为止实现的所有功能都是 *pure*，也就是说，它没有描述具有副作用的计算。 （有人可能会争辩说，失败的可能性已经是可观察到的 * 效果 *，但即便如此，上面的代码仍然是引用透明的，可以在 REPL 轻松测试，并在编译时评估，这是这里很重要。）"

#. type: Plain text
#: ../src/Tutorial/IO.md:298
#, fuzzy, no-wrap
msgid ""
"Finally, we can wrap this functionality in an `IO`\n"
"action, which reads a string from standard input\n"
"and tries to evaluate the arithmetic expression:\n"
msgstr "最后，我们可以将此功能包装在 `IO` 操作中，该操作从标准输入读取字符串并尝试计算算术表达式："

#. type: Plain text
#: ../src/Tutorial/IO.md:299
#, fuzzy, no-wrap
msgid ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"
msgstr ""
"```伊德里斯\n"
"exprProg : IO ()\n"
"exprProg = 做\n"
"  s <- 获取线\n"
"  case eval 的\n"
"    左错误 => 做\n"
"      putStrLn \"发生错误：\"\n"
"      putStrLn (dispError 错误)\n"
"    右 res => putStrLn (s ++ \" = \" ++ 显示 res)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:316
#, fuzzy, no-wrap
msgid ""
"Note, how in `exprProg` we were forced to deal with the\n"
"possibility of failure and handle both constructors\n"
"of `Either` differently in order to print a result.\n"
"Note also, that *do blocks* are ordinary expressions,\n"
"and we can, for instance, start a new *do block* on\n"
"the right hand side of a case expression.\n"
msgstr "请注意，在 `exprProg` 中，我们如何被迫处理失败的可能性并以不同方式处理 `Either` 的两个构造函数以打印结果。还要注意，*do blocks* 是普通表达式，例如，我们可以在 case 表达式的右侧开始一个新的 *do block*。"

#. type: Plain text
#: ../src/Tutorial/IO.md:329
#, fuzzy, no-wrap
msgid ""
"In these exercises, you are going to implement some\n"
"small command-line applications. Some of these will potentially\n"
"run forever, as they will only stop when the user enters\n"
"a keyword for quitting the application. Such programs\n"
"are no longer provably total. If you added the\n"
"`%default total` pragma at the top of your source file,\n"
"you'll need to annotate these functions with `covering`,\n"
"meaning that you covered all cases in all pattern matches\n"
"but your program might still loop due to unrestricted\n"
"recursion.\n"
msgstr "在这些练习中，您将实现一些小型命令行应用程序。其中一些可能会永远运行，因为它们只会在用户输入退出应用程序的关键字时停止。这样的程序不再是可证明的全部。如果您在源文件的顶部添加了 `%default total` 杂注，则需要使用 `covering` 注释这些函数，这意味着您涵盖了所有模式匹配中的所有情况，但由于不受限制的递归，您的程序可能仍会循环。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:333
#, fuzzy
msgid ""
"Implement function `rep`, which will read a line of input from the terminal, "
"evaluate it using the given function, and print the result to standard "
"output:"
msgstr ""
"实现函数 `rep`，它将从终端读取一行输入，使用给定函数对其进行评估，并将结果打"
"印到标准输出："

#. type: Plain text
#: ../src/Tutorial/IO.md:334
#, fuzzy, no-wrap
msgid "   rep : (String -> String) -> IO ()\n"
msgstr ""
"   ```伊德里斯\n"
"   覆盖\n"
"   复制：（字符串->字符串）-> IO（）\n"
"   ```\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:341
#, fuzzy
msgid ""
"Implement function `repl`, which behaves just like `rep` but will repeat "
"itself forever (or until being forcefully terminated):"
msgstr ""
"实现函数 `repl`，其行为类似于 `rep`，但会永远重复（或直到被强制终止）："

#. type: Plain text
#: ../src/Tutorial/IO.md:342
#, fuzzy, no-wrap
msgid ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"
msgstr ""
"   ```伊德里斯\n"
"   覆盖\n"
"   复制：（字符串->字符串）-> IO（）\n"
"   ```\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:351
#, fuzzy
msgid ""
"Implement function `replTill`, which behaves just like `repl` but will only "
"continue looping if the given function returns a `Right`. If it returns a "
"`Left`, `replTill` should print the final message wrapped in the `Left` and "
"then stop."
msgstr ""
"实现函数 `replTill`，其行为类似于 `repl`，但只有在给定函数返回 `Right` 时才会"
"继续循环。如果它返回 `Left`，`replTill` 应该打印包装在 `Left` 中的最终消息，"
"然后停止。"

#. type: Plain text
#: ../src/Tutorial/IO.md:352
#, fuzzy, no-wrap
msgid ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"
msgstr ""
"   ```伊德里斯\n"
"   覆盖\n"
"   replTill : (String -> 任一字符串字符串) -> IO ()\n"
"   ```\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:364
#, fuzzy
msgid ""
"Write a program, which reads arithmetic expressions from standard input, "
"evaluates them using `eval`, and prints the result to standard output. The "
"program should loop until users stops it by entering \"done\", in which case "
"the program should terminate with a friendly greeting.  Use `replTill` in "
"your implementation."
msgstr ""
"编写一个程序，从标准输入读取算术表达式，使用 `eval` 计算它们，并将结果打印到"
"标准输出。程序应该循环，直到用户通过输入“完成”停止它，在这种情况下，程序应该"
"以友好的问候终止。在您的实现中使用 `replTill`。"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:373
#, fuzzy
msgid ""
"Implement function `replWith`, which behaves just like `repl` but uses some "
"internal state to accumulate values.  At each iteration (including the very "
"first one!), the current state should be printed to standard output using "
"function `dispState`, and the next state should be computed using function "
"`next`.  The loop should terminate in case of a `Left` and print a final "
"message using `dispResult`:"
msgstr ""
"实现函数 `replWith`，其行为类似于 `repl`，但使用一些内部状态来累积值。在每次"
"迭代中（包括第一次迭代！），当前状态应该使用函数 `dispState` 打印到标准输出，"
"并且应该使用函数 `next` 计算下一个状态。如果出现 `Left`，循环应该终止，并使"
"用 `dispResult` 打印最终消息："

#. type: Plain text
#: ../src/Tutorial/IO.md:374
#, fuzzy, no-wrap
msgid ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"
msgstr ""
"   ```伊德里斯\n"
"   覆盖\n"
"   replWith : (状态 : s)\n"
"            -> (next : s -> String -> 无论是 res s)\n"
"            -> (dispState : s -> 字符串)\n"
"            -> (dispResult : res -> s -> 字符串)\n"
"            -> IO()\n"
"   ```\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/IO.md:388
#, fuzzy
msgid ""
"Use `replWith` from Exercise 5 to write a program for reading natural "
"numbers from standard input and printing the accumulated sum of these "
"numbers.  The program should terminate in case of invalid input and if a "
"user enters \"done\"."
msgstr ""
"使用练习 5 中的 `replWith` 编写一个程序，用于从标准输入读取自然数并打印这些数"
"字的累加和。如果输入无效并且用户输入“完成”，程序应该终止。"

#. type: Title ##
#: ../src/Tutorial/IO.md:389
#, fuzzy, no-wrap
msgid "Do Blocks, Desugared"
msgstr "## 做块，脱糖"

#. type: Plain text
#: ../src/Tutorial/IO.md:402
#, fuzzy, no-wrap
msgid ""
"Here's an important piece of information: There is nothing\n"
"special about *do blocks*. They are just syntactic sugar,\n"
"which is converted to a sequence of operator applications.\n"
"With [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar),\n"
"we mean syntax in a programming language that makes it\n"
"easier to express certain things in that language without\n"
"making the language itself any more powerful or expressive.\n"
"Here, it means you could write all the `IO` programs\n"
"without using `do` notation, but the code you'll write\n"
"will sometimes be harder to read, so *do blocks* provide\n"
"nicer syntax for these occasions.\n"
msgstr "这里有一条重要信息：*do blocks* 没有什么特别之处。它们只是语法糖，被转换为一系列运算符应用程序。使用 [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar)，我们指的是一种编程语言中的语法，它可以更容易地用该语言表达某些事物，而不会使语言本身更强大或更具表现力。在这里，这意味着您可以编写所有 `IO` 程序而不使用 `do` 符号，但是您编写的代码有时会更难阅读，因此 *do blocks[X577X ] 为这些场合提供更好的语法。"

#. type: Plain text
#: ../src/Tutorial/IO.md:404
#, fuzzy, no-wrap
msgid "Consider the following example program:\n"
msgstr "考虑以下示例程序："

#. type: Plain text
#: ../src/Tutorial/IO.md:405
#, fuzzy, no-wrap
msgid ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
msgstr ""
"```伊德里斯\n"
"加糖1：IO（）\n"
"加糖1 = 做\n"
"  str1 <- 获取线\n"
"  str2 <- 获取线\n"
"  str3 <- 获取线\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:416
#, fuzzy, no-wrap
msgid ""
"The compiler will convert this to the following program\n"
"*before disambiguating function names and type checking*:\n"
msgstr "在消除函数名称歧义和类型检查 * 之前，编译器会将其转换为以下程序 *："

#. type: Plain text
#: ../src/Tutorial/IO.md:417
#, fuzzy, no-wrap
msgid ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
msgstr ""
"```伊德里斯\n"
"脱糖1：IO（）\n"
"脱糖1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:432
#, fuzzy, no-wrap
msgid ""
"There is a new operator (`(>>=)`) called *bind* in the\n"
"implementation of `desugared1`. If you look at its type\n"
"at the REPL, you'll see the following:\n"
msgstr "在 `desugared1` 的实现中有一个称为 *bind* 的新运算符 (`(>>=)`)。如果您在 REPL 中查看它的类型，您将看到以下内容："

#. type: Plain text
#: ../src/Tutorial/IO.md:433
#, fuzzy, no-wrap
msgid ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
msgstr "```repl Main> :t (>>=) Prelude.>>= : Monad m => m a -> (a -> m b) -> m b ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:441
#, fuzzy, no-wrap
msgid ""
"This is a constrained function requiring an interface called `Monad`.\n"
"We will talk about `Monad` and some of its friends in the next\n"
"chapter. Specialized to `IO`, *bind* has the following type:\n"
msgstr "这是一个受约束的函数，需要一个名为 `Monad` 的接口。我们将在下一章讨论 `Monad` 和它的一些朋友。专门针对`IO`，*bind*有以下类型："

#. type: Plain text
#: ../src/Tutorial/IO.md:442
#, fuzzy, no-wrap
msgid ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"
msgstr "```repl Main> :t (>>=) {m = IO} >>= : IO a -> (a -> IO b) -> IO b ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:451
#, fuzzy, no-wrap
msgid ""
"This describes a sequencing of `IO` actions. Upon execution,\n"
"the first `IO` action is being run and its result is\n"
"being passed as an argument to the function generating\n"
"the second `IO` action, which is then also being executed.\n"
msgstr "这描述了 `IO` 动作的顺序。执行时，第一个 `IO` 动作正在运行，其结果作为参数传递给生成第二个 `IO` 动作的函数，然后也将执行该动作。"

#. type: Plain text
#: ../src/Tutorial/IO.md:466
#, fuzzy, no-wrap
msgid ""
"You might remember, that you already implemented something\n"
"similar in an earlier exercise: In [Algebraic Data Types](DataTypes.md),\n"
"you implemented *bind* for `Maybe` and `Either e`. We will\n"
"learn in the next chapter, that `Maybe` and `Either e` too come\n"
"with an implementation of `Monad`. For now, suffice to say\n"
"that `Monad` allows us to run computations with some kind\n"
"of effect in sequence by passing the *result* of the\n"
"first computation to the function returning the\n"
"second computation. In `desugared1` you can see, how\n"
"we first perform an `IO` action and use its result\n"
"to compute the next `IO` action and so on. The code is somewhat\n"
"hard to read, since we use several layers of nested\n"
"anonymous function, that's why in such cases, *do blocks*\n"
"are a nice alternative to express the same functionality.\n"
msgstr "您可能还记得，您已经在之前的练习中实现了类似的东西：在 [Algebraic Data Types](DataTypes.md) 中，您为 `Maybe` 和 ` 实现了 *bind* 或者`。我们将在下一章中了解到，`Maybe` 和 `E` 也都带有 `Monad` 的实现。现在，可以说 `Monad` 允许我们通过将第一次计算的 *result* 传递给返回第二次计算的函数来按顺序运行具有某种效果的计算。在 `desugared1` 中，您可以看到，我们如何首先执行 `IO` 动作并使用其结果来计算下一个 `IO` 动作等等。代码有点难以阅读，因为我们使用了多层嵌套匿名函数，这就是为什么在这种情况下，*do 块* 是表达相同功能的不错选择。"

#. type: Plain text
#: ../src/Tutorial/IO.md:471
#, fuzzy, no-wrap
msgid ""
"Since *do block* are always desugared to sequences of\n"
"applied *bind* operators, we can use them to chain\n"
"any monadic computation. For instance, we can rewrite\n"
"function `eval` by using a *do block* like so:\n"
msgstr "由于 *do 块 * 总是与应用的 *bind* 运算符序列脱糖，因此我们可以使用它们链接任何一元计算。例如，我们可以使用 *do 块 * 重写函数 `eval`，如下所示："

#. type: Plain text
#: ../src/Tutorial/IO.md:472
#, fuzzy, no-wrap
msgid ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"
msgstr ""
"```伊德里斯\n"
"evalDo : String -> 任一错误整数\n"
"evalDo s = case forget $ split isSpace s 的\n"
"  [x,y,z] => 做\n"
"    v1 <- 读取整数 x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    对 $ op v1 v2\n"
"  _ => 左（ParseError s）\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:488
#, fuzzy, no-wrap
msgid ""
"Don't worry, if this doesn't make too much sense yet. We will\n"
"see many more examples, and you'll get the hang of this\n"
"soon enough. The important thing to remember is how *do\n"
"blocks* are always converted to sequences of *bind*\n"
"operators as shown in `desugared1`.\n"
msgstr "别担心，如果这还没有太大意义。我们将看到更多示例，您很快就会掌握其中的窍门。要记住的重要一点是 *do 块 * 总是如何转换为 *bind* 运算符的序列，如 `desugared1` 所示。"

#. type: Title ###
#: ../src/Tutorial/IO.md:489
#, fuzzy, no-wrap
msgid "Binding Unit"
msgstr "### 绑定单元"

#. type: Plain text
#: ../src/Tutorial/IO.md:492
#, fuzzy, no-wrap
msgid "Remember our implementation of `friendlyReadHello`? Here it is again:\n"
msgstr "还记得我们对 `friendlyReadHello` 的实现吗？这里又是："

#. type: Plain text
#: ../src/Tutorial/IO.md:493
#, fuzzy, no-wrap
msgid ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
msgstr ""
"友好读你好：IO（）\n"
"友好读你好 = 做\n"
"  _ <- putStrLn \"请输入您的姓名。\"\n"
"  读你好\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:505
#, fuzzy, no-wrap
msgid ""
"The underscore in there is a bit ugly and unnecessary. In fact,\n"
"a common use case is to just chain effectful computations with\n"
"result type `Unit` (`()`), merely for the side\n"
"effects they perform. For instance, we could repeat `friendlyReadHello`\n"
"three times, like so:\n"
msgstr "那里的下划线有点丑陋和不必要。事实上，一个常见的用例是将有效计算与结果类型 `Unit` (`()`) 链接起来，只是为了它们执行的副作用。例如，我们可以重复 `friendlyReadHello` 三次，如下所示："

#. type: Plain text
#: ../src/Tutorial/IO.md:506
#, fuzzy, no-wrap
msgid ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"```伊德里斯\n"
"友好3：IO（）\n"
"友好3 = 做\n"
"  _ <-friendlyReadHello\n"
"  _ <-friendlyReadHello\n"
"  友好阅读你好\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:516
#, fuzzy, no-wrap
msgid ""
"This is such a common thing to do, that Idris allows us to\n"
"drop the bound underscores altogether:\n"
msgstr "这是很常见的事情，Idris 允许我们完全放弃绑定的下划线："

#. type: Plain text
#: ../src/Tutorial/IO.md:517
#, fuzzy, no-wrap
msgid ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"```伊德里斯\n"
"友好4：IO（）\n"
"友好4 = 做\n"
"  友好阅读你好\n"
"  友好阅读你好\n"
"  友好阅读你好\n"
"  友好阅读你好\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:527
#, fuzzy, no-wrap
msgid "Note, however, that the above gets desugared slightly differently:\n"
msgstr "但是请注意，上述内容的脱糖略有不同："

#. type: Plain text
#: ../src/Tutorial/IO.md:528
#, fuzzy, no-wrap
msgid ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"
msgstr ""
"```伊德里斯\n"
"友好4Desugared : IO ()\n"
"友好4Desugared =\n"
"  友好阅读你好>>\n"
"  友好阅读你好>>\n"
"  友好阅读你好>>\n"
"  友好阅读你好\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:538
#, fuzzy, no-wrap
msgid "Operator `(>>)` has the following type:\n"
msgstr "运算符 `(>>)` 具有以下类型："

#. type: Plain text
#: ../src/Tutorial/IO.md:539
#, fuzzy, no-wrap
msgid ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"
msgstr "```repl Main> :t (>>) Prelude.>> : Monad m => m () -> Lazy (m b) -> m b ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:550
#, fuzzy, no-wrap
msgid ""
"Note the `Lazy` keyword in the type signature. This means,\n"
"that the wrapped argument will be *lazily evaluated*. This\n"
"makes sense in many occasions. For instance, if the `Monad`\n"
"in question is `Maybe` the result will be `Nothing` if\n"
"the first argument is `Nothing`, in which case there is no\n"
"need to even evaluate the second argument.\n"
msgstr "注意类型签名中的 `Lazy` 关键字。这意味着，包装的参数将被 * 延迟评估 *。这在很多场合都是有道理的。例如，如果所讨论的 `Monad` 是 `Maybe` 如果第一个参数是 `Nothing`，那么结果将是 `Nothing`，在这种情况下甚至不需要评估第二个参数。"

#. type: Title ###
#: ../src/Tutorial/IO.md:551
#, fuzzy, no-wrap
msgid "Do, Overloaded"
msgstr "### 做，重载"

#. type: Plain text
#: ../src/Tutorial/IO.md:562
#, fuzzy, no-wrap
msgid ""
"Because Idris supports function and operator overloading, we\n"
"can write custom *bind* operators, which allows us to\n"
"use *do notation* for types without an implementation\n"
"of `Monad`. For instance, here is a custom implementation of\n"
"`(>>=)` for sequencing computations returning vectors.\n"
"Every value in the first vector (of length `m`)\n"
"will be converted to a vector of length `n`, and\n"
"the results will be concatenated leading to\n"
"a vector of length `m * n`:\n"
msgstr "因为 Idris 支持函数和运算符重载，我们可以编写自定义的 *bind* 运算符，这允许我们对没有实现 `Monad` 的类型使用 *do notation*。例如，这是 `(>>=)` 的自定义实现，用于对返回向量的计算进行排序。第一个向量（长度为 `m`）中的每个值都将转换为长度为 `n` 的向量，结果将被连接到长度为 `m * 的向量n`："

#. type: Plain text
#: ../src/Tutorial/IO.md:563
#, fuzzy, no-wrap
msgid ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"
msgstr ""
"```伊德里斯\n"
"展平：Vect m (Vect n a) -> Vect (m * n) a\n"
"展平 [] = []\n"
"展平 (x :: xs) = x ++ 展平 xs\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:580
#, fuzzy, no-wrap
msgid ""
"It is not possible to write an implementation of `Monad`,\n"
"which encapsulates this behavior, as the types wouldn't\n"
"match: Monadic *bind* specialized to `Vect` has\n"
"type `Vect k a -> (a -> Vect k b) -> Vect k b`. As you\n"
"see, the sizes of all three occurrences of `Vect`\n"
"have to be the same, which is not what we expressed\n"
"in our custom version of *bind*. Here is an example to\n"
"see this in action:\n"
msgstr "无法编写封装此行为的 `Monad` 的实现，因为类型不匹配：专用于 `Vect` 的 Monadic *bind* 具有类型 [ X167X]Vect k a -> (a -> Vect k b) -> Vect k b`。如您所见，所有三个 `Vect` 的大小必须相同，这不是我们在自定义版本的 *bind* 中表达的。下面是一个例子，可以看到这一点："

#. type: Plain text
#: ../src/Tutorial/IO.md:581
#, fuzzy, no-wrap
msgid ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"
msgstr ""
"testDo : Vect 24 字符串\n"
"testDo = IO.do\n"
"  s1 <- [“你好”，“世界”]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ 显示 s2)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:601
#, fuzzy, no-wrap
msgid ""
"Try to figure out how `testDo` works by desugaring it\n"
"manually and then comparing its result with what you\n"
"expected at the REPL. Note, how we helped Idris disambiguate,\n"
"which version of the *bind* operator to use by prefixing\n"
"the `do` keyword with part of the operator's namespace.\n"
"In this case, this wasn't strictly necessary, although\n"
"`Vect k` does have an implementation of `Monad`, but it is\n"
"still good to know that it is possible to help\n"
"the compiler with disambiguating do blocks.\n"
msgstr "尝试通过手动对 `testDo` 进行脱糖，然后将其结果与您在 REPL 中的预期结果进行比较来弄清楚 `testDo` 是如何工作的。请注意，我们如何帮助 Idris 消除歧义，通过在 `do` 关键字前加上运算符名称空间的一部分来使用哪个版本的 *bind* 运算符。在这种情况下，这不是绝对必要的，虽然 `Vect k` 确实有 `Monad` 的实现，但知道它可以帮助编译器消除歧义仍然是件好事做积木。"

#. type: Plain text
#: ../src/Tutorial/IO.md:605
#, fuzzy, no-wrap
msgid ""
"Of course, we can (and should!) overload `(>>)` in the\n"
"same manner as `(>>=)`, if we want to overload the\n"
"behavior of *do blocks*.\n"
msgstr "当然，如果我们想重载 * 的行为，我们可以（并且应该！）重载 `(>>)` 和 `(>>=)` 一样块*。"

#. type: Title ####
#: ../src/Tutorial/IO.md:606
#, fuzzy, no-wrap
msgid "Modules and Namespaces"
msgstr "#### 模块和命名空间"

#. type: Plain text
#: ../src/Tutorial/IO.md:614
#, fuzzy, no-wrap
msgid ""
"Every data type, function, or operator can be unambiguously\n"
"identified by prefixing it with its *namespace*. A function's\n"
"namespace typically is the same as the module where it was defined.\n"
"For instance, the fully qualified name of function `eval`\n"
"would be `Tutorial.IO.eval`. Function and operator names must\n"
"be unique in their namespace.\n"
msgstr "每个数据类型、函数或运算符都可以通过为其 * 命名空间 * 加上前缀来明确标识。函数的命名空间通常与定义它的模块相同。例如，函数 `eval` 的完全限定名称将是 `Tutorial.IO.eval`。函数和运算符名称在其命名空间中必须是唯一的。"

#. type: Plain text
#: ../src/Tutorial/IO.md:620
#, fuzzy, no-wrap
msgid ""
"As we already learned, Idris can often disambiguate between\n"
"functions with the same name but defined in different namespaces\n"
"based on the types involved. If this is not possible, we can help\n"
"the compiler by *prefixing* the function or operator name with\n"
"a *suffix* of the full namespace. Let's demonstrate this at the REPL:\n"
msgstr "正如我们已经了解到的那样，Idris 通常可以消除具有相同名称但根据所涉及的类型在不同命名空间中定义的函数之间的歧义。如果这是不可能的，我们可以通过 * 前缀 * 使用完整命名空间的 * 后缀 * 的函数或运算符名称来帮助编译器。让我们在 REPL 上演示一下："

#. type: Plain text
#: ../src/Tutorial/IO.md:621
#, fuzzy, no-wrap
msgid ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr "```repl Tutorial.IO> :t (>>=) Prelude.>>= : Monad m => m a -> (a -> m b) -> m b Tutorial.IO.>>= : Vect m a -> ( a -> Vect n b) -> Vect (m * n) b ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:633
#, fuzzy, no-wrap
msgid ""
"As you can see, if we load this module in a REPL session and\n"
"inspect the type of `(>>=)`, we get two results as two\n"
"operators with this name are in scope. If we only want\n"
"the REPL to print the type of our custom *bind* operator,\n"
"is is sufficient to prefix it with `IO`, although we could\n"
"also prefix it with its full namespace:\n"
msgstr "如您所见，如果我们在 REPL 会话中加载此模块并检查 `(>>=)` 的类型，我们会得到两个结果，因为具有此名称的两个运算符都在范围内。如果我们只希望 REPL 打印我们自定义的 *bind* 运算符的类型，那么在它前面加上 `IO` 就足够了，尽管我们也可以在它前面加上完整的命名空间："

#. type: Plain text
#: ../src/Tutorial/IO.md:634
#, fuzzy, no-wrap
msgid ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr "```repl Tutorial.IO> :t IO.(>>=) Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b Tutorial.IO> : t Tutorial.IO.(>>=) Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:649
#, fuzzy, no-wrap
msgid ""
"Since function names must be unique in their namespace and\n"
"we still may want to define two overloaded versions of a function\n"
"in an Idris module, Idris makes it possible to add\n"
"additional namespaces to modules. For instance, in order\n"
"to define another function called `eval`, we need to add\n"
"it to its own namespace (note, that all definitions in a\n"
"namespace must be indented by the same amount of\n"
"white space):\n"
msgstr "由于函数名称在它们的命名空间中必须是唯一的，而且我们仍然可能希望在 Idris 模块中定义函数的两个重载版本，因此 Idris 可以为模块添加额外的命名空间。例如，为了定义另一个名为 `eval` 的函数，我们需要将它添加到它自己的命名空间中（注意，命名空间中的所有定义必须缩进相同数量的空格）："

#. type: Plain text
#: ../src/Tutorial/IO.md:650
#, fuzzy, no-wrap
msgid ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"
msgstr "-- 在 `eval` 前加上它的命名空间并不是绝对必要的 testFooEval : Nat testFooEval = Foo.eval 12 100 ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:665
#, fuzzy, no-wrap
msgid ""
"Now, here is an important thing: For functions and data types to\n"
"be accessible from outside their namespace or module, they need to\n"
"be *exported* by annotating them with the `export` or `public export`\n"
"keywords.\n"
msgstr "现在，这里有一件重要的事情：对于要从其命名空间或模块外部访问的函数和数据类型，需要通过使用 `export` 或 ` 注释它们来 *exported*公共导出` 关键字。"

#. type: Plain text
#: ../src/Tutorial/IO.md:674
#, fuzzy, no-wrap
msgid ""
"The difference between `export` and `public export` is the following:\n"
"A function annotated with `export` exports its type and can be\n"
"called from other namespaces. A data type annotated with `export`\n"
"exports its type constructor but not its data constructors.\n"
"A function annotated with `public export` also exports its\n"
"implementation. This is necessary to use the function in compile-time\n"
"computations. A data type annotated with `public export`\n"
"exports its data constructors as well.\n"
msgstr "`export` 和 `public export` 的区别如下：用 `export` 注解的函数导出其类型，可以从其他命名空间调用。使用 `export` 注释的数据类型导出其类型构造函数，但不导出其数据构造函数。使用 `public export` 注释的函数也会导出其实现。这是在编译时计算中使用该函数所必需的。使用 `public export` 注释的数据类型也会导出其数据构造函数。"

#. type: Plain text
#: ../src/Tutorial/IO.md:680
#, fuzzy, no-wrap
msgid ""
"In general, consider annotating data types with `public export`,\n"
"since otherwise you will not be able to create values of these\n"
"types or deconstruct them in pattern matches. Likewise, unless you\n"
"plan to use your functions in compile-time computations, annotate\n"
"them with `export`.\n"
msgstr "通常，请考虑使用 `public export` 注释数据类型，否则您将无法创建这些类型的值或在模式匹配中解构它们。同样，除非您打算在编译时计算中使用您的函数，否则请使用 `export` 注释它们。"

#. type: Title ###
#: ../src/Tutorial/IO.md:681
#, fuzzy, no-wrap
msgid "Bind, with a Bang"
msgstr "### 绑定，砰的一声"

#. type: Plain text
#: ../src/Tutorial/IO.md:688
#, fuzzy, no-wrap
msgid ""
"Sometimes, even *do blocks* are too noisy to express a\n"
"combination of effectful computations. In this case, we\n"
"can prefix the effectful parts with an exclamation mark\n"
"(wrapping them in parentheses if they contain additional\n"
"white space), while leaving pure expressions unmodified:\n"
msgstr "有时，即使是 *do 块 * 也过于嘈杂，无法表达有效计算的组合。在这种情况下，我们可以在有效部分前面加上一个感叹号（如果它们包含额外的空格，则将它们括在括号中），同时保持纯表达式不变："

#. type: Plain text
#: ../src/Tutorial/IO.md:689
#, fuzzy, no-wrap
msgid ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"
msgstr "```idris getHello : IO () getHello = putStrLn $ \"Hello\" ++ !getLine ++ \"!\" ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:695
#, fuzzy, no-wrap
msgid "The above gets desugared to the following *do block*:\n"
msgstr "上面的内容被分解为以下 *do 块*："

#. type: Plain text
#: ../src/Tutorial/IO.md:696
#, fuzzy, no-wrap
msgid ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"
msgstr ""
"```伊德里斯\n"
"getHello' : IO ()\n"
"getHello' = 做\n"
"  s <- 获取线\n"
"  putStrLn $ \"你好\" ++ s ++ \"！\"\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:704
#, fuzzy, no-wrap
msgid "Here is another example:\n"
msgstr "这是另一个例子："

#. type: Plain text
#: ../src/Tutorial/IO.md:705
#, fuzzy, no-wrap
msgid ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
msgstr ""
"```伊德里斯\n"
"bangExpr : 字符串 -> 字符串 -> 字符串 -> 也许整数\n"
"bangExpr s1 s2 s3 =\n"
"  只需 $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:712
#, fuzzy, no-wrap
msgid "And here is the desugared *do block*:\n"
msgstr "这是脱糖的 *do 块*："

#. type: Plain text
#: ../src/Tutorial/IO.md:713
#, fuzzy, no-wrap
msgid ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"
msgstr ""
"```伊德里斯\n"
"bangExpr' : 字符串 -> 字符串 -> 字符串 -> 可能整数\n"
"bangExpr' s1 s2 s3 = 做\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  只需 $ x1 + x2 * x3\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:727
#, fuzzy, no-wrap
msgid ""
"Please remember the following: Syntactic sugar has been introduced\n"
"to make code more readable or more convenient to write. If\n"
"it is abused just to show how clever you are, you make things\n"
"harder for other people (including your future self!)\n"
"reading and trying to understand your code.\n"
msgstr "请记住以下几点： 已引入语法糖以使代码更具可读性或更方便编写。如果它被滥用只是为了展示你有多聪明，你会让其他人（包括你未来的自己！）阅读和试图理解你的代码变得更加困难。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:733
#, fuzzy
msgid ""
"Reimplement the following *do blocks*, once by using *bang notation*, and "
"once by writing them in their desugared form with nested *bind*s:"
msgstr ""
"重新实现以下 *do 块*，一次使用 *bang notation*，一次通过嵌套 *bind*s 以脱糖形"
"式编写它们："

#. type: Plain text
#: ../src/Tutorial/IO.md:734
#, fuzzy, no-wrap
msgid ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"
msgstr ""
"```伊德里斯\n"
"加糖1：IO（）\n"
"加糖1 = 做\n"
"  str1 <- 获取线\n"
"  str2 <- 获取线\n"
"  str3 <- 获取线\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
"```\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:752
#, fuzzy
msgid ""
"Below is the definition of an indexed family of types, the index of which "
"keeps track of whether the value in question is possibly empty or provably "
"non-empty:"
msgstr "下面是索引类型族的定义，其索引跟踪所讨论的值是否可能为空或可证明非空："

#. type: Plain text
#: ../src/Tutorial/IO.md:766
#, fuzzy, no-wrap
msgid ""
"   Please note, that the `Nil` case *must* have the `nonEmpty`\n"
"   tag set to `False`, while with the *cons* case, this is\n"
"   optional. So, a `List01 False a` can be empty or non-empty,\n"
"   and we'll only find out, which is the case, by pattern\n"
"   matching on it. A `List01 True a` on the other hand *must*\n"
"   be a *cons*, as for the `Nil` case the `nonEmpty` tag is\n"
"   always set to `False`.\n"
msgstr ""
"   请注意，`Nil` 案例 * 必须 * 具有 `nonEmpty`\n"
"   标签设置为 `False`，而在 *cons* 的情况下，这是\n"
"   可选的。因此，a `List01 False a` 可以为空或非空，\n"
"   我们只会通过模式找出情况\n"
"   匹配它。 A `List01 True a` 另一方面 * 必须*\n"
"   是 *cons*，对于 `Nil` 的情况， `nonEmpty` 标签是\n"
"   始终设置为 `False`。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/IO.md:768
#, fuzzy
msgid "Declare and implement function `head` for non-empty lists:"
msgstr "为非空列表声明并实现函数 `head`："

#. type: Plain text
#: ../src/Tutorial/IO.md:772
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      头部：List01 真 a -> a\n"
"      ```\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/IO.md:776
#, fuzzy
msgid ""
"Declare and implement function `weaken` for converting any `List01 ne a` to "
"a `List01 False a` of the same length and order of values."
msgstr ""
"声明并实现函数 `weaken` 用于将任何 `List01 ne a` 转换为具有相同长度和值顺序"
"的 `List01 False a`。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/IO.md:779
#, fuzzy
msgid ""
"Declare and implement function `tail` for extracting the possibly empty tail "
"from a non-empty list."
msgstr "声明并实现函数 `tail` 用于从非空列表中提取可能为空的尾部。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/IO.md:784
#, fuzzy
msgid ""
"Implement function `(++)` for concatenating two values of type `List01`. "
"Note, how we use a type-level computation to make sure the result is non-"
"empty if and only if at least one of the two arguments is non-empty:"
msgstr ""
"实现函数 `(++)` 以连接两个 `List01` 类型的值。请注意，当且仅当两个参数中的至"
"少一个非空时，我们如何使用类型级计算来确保结果非空："

#. type: Plain text
#: ../src/Tutorial/IO.md:788
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/IO.md:794
#, fuzzy
msgid ""
"Implement utility function `concat'` and use it in the implementation of "
"`concat`. Note, that in `concat` the two boolean tags are passed as "
"unrestricted implicits, since you will need to pattern match on these to "
"determine whether the result is provably non-empty or not:"
msgstr ""
"实现实用函数 `concat'` 并在 `concat` 的实现中使用它。请注意，在 `concat` 中，"
"两个布尔标记作为不受限制的隐式传递，因为您需要对它们进行模式匹配以确定结果是"
"否可证明为非空："

#. type: Plain text
#: ../src/Tutorial/IO.md:797
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"
msgstr ""
"      ```伊德里斯\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:802
#, fuzzy, no-wrap
msgid ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"
msgstr ""
"      连接：{ne1，ne2：_}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) 一个\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/IO.md:804
#, fuzzy
msgid "Implement `map01`:"
msgstr "实现 `map01`："

#. type: Plain text
#: ../src/Tutorial/IO.md:808
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/IO.md:811
#, fuzzy
msgid ""
"Implement a custom *bind* operator in namespace `List01` for sequencing "
"computations returning `List01`s."
msgstr ""
"在命名空间 `List01` 中实现自定义 *bind* 运算符，用于对返回 `List01`s 的计算进"
"行排序。"

#. type: Plain text
#: ../src/Tutorial/IO.md:814
#, fuzzy, no-wrap
msgid ""
"      Hint: Use `map01` and `concat` in your implementation and\n"
"      make sure to use unrestricted implicits where necessary.\n"
msgstr ""
"      提示：在你的实现中使用 `map01` 和 `concat`\n"
"      确保在必要时使用不受限制的隐式。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:817
#, fuzzy, no-wrap
msgid ""
"      You can use the following examples to test your\n"
"      custom *bind* operator:\n"
msgstr ""
"      您可以使用以下示例来测试您的\n"
"      自定义 *bind* 运算符：\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:823
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"
msgstr ""
"      ```伊德里斯\n"
"      -- this 和 lf 是确定使用哪个标签所必需的\n"
"      -- 使用列表文字时\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:826
#, fuzzy, no-wrap
msgid ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"
msgstr ""
"      lf : List01 假 a -> List01 假 a\n"
"      lf = 身份证\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:833
#, fuzzy, no-wrap
msgid ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"
msgstr ""
"      测试：List01 真整数\n"
"      测试 = List01.do\n"
"        x <- lt [1,2,3]\n"
"        y <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [操作 x y]\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:841
#, fuzzy, no-wrap
msgid ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"
msgstr ""
"      test2 : List01 假整数\n"
"      test2 = List01.do\n"
"        x <- lt [1,2,3]\n"
"        y <- 无 {a = 整数}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:857
#, fuzzy, no-wrap
msgid ""
"Some notes on Exercise 2: Here, we combined the capabilities\n"
"of `List` and `Data.List1` in a single indexed type family.\n"
"This allowed us to treat list concatenation correctly: If\n"
"at least one of the arguments is provably non-empty, the\n"
"result is also non-empty. To tackle this correctly with\n"
"`List` and `List1`, a total of four concatenation functions\n"
"would have to be written. So, while it is often possible to\n"
"define distinct data types instead of indexed families,\n"
"the latter allow us to perform type-level computations to\n"
"be more precise about the pre- and postconditions of the functions\n"
"we write, at the cost of more-complex type signatures.\n"
"In addition, sometimes it's not possible to derive the\n"
"values of the indices from pattern matching on the data\n"
"values alone, so they have to be passed as unerased\n"
"(possibly implicit) arguments.\n"
msgstr "练习 2 的一些注意事项：在这里，我们将 `List` 和 `Data.List1` 的功能组合在一个索引类型族中。这使我们能够正确处理列表连接：如果至少有一个参数可证明是非空的，则结果也是非空的。为了用 `List` 和 `List1` 正确解决这个问题，总共需要编写四个连接函数。因此，虽然通常可以定义不同的数据类型而不是索引族，但后者允许我们执行类型级计算，以更精确地了解我们编写的函数的前置条件和后置条件，但代价是更复杂类型签名。此外，有时不可能仅从数据值的模式匹配中导出索引的值，因此必须将它们作为未擦除（可能是隐式）参数传递。"

#. type: Plain text
#: ../src/Tutorial/IO.md:864
#, fuzzy, no-wrap
msgid ""
"Please remember, that *do blocks* are first desugared, before\n"
"type-checking, disambiguating which *bind* operator to use,\n"
"and filling in implicit arguments. It is therefore perfectly fine\n"
"to define *bind* operators with arbitrary constraints or\n"
"implicit arguments as was shown above. Idris will handle\n"
"all the details, *after* desugaring the *do blocks*.\n"
msgstr "请记住，首先对 *do 块* 进行脱糖，然后再进行类型检查、消除使用哪个 *bind* 运算符的歧义以及填充隐式参数。因此，使用任意约束或隐式参数定义 *bind* 运算符是非常好的，如上所示。 Idris 将处理所有细节，* 在 * 脱糖 *do 块* 之后。"

#. type: Title ##
#: ../src/Tutorial/IO.md:865
#, fuzzy, no-wrap
msgid "Working with Files"
msgstr "## 使用文件"

#. type: Plain text
#: ../src/Tutorial/IO.md:872
#, fuzzy, no-wrap
msgid ""
"Module `System.File` from the *base* library exports utilities necessary\n"
"to work with file handles and read and write from and to files. When\n"
"you have a file path (for instance \"/home/hock/idris/tutorial/tutorial.ipkg\"),\n"
"the first thing we will typically do is to try and create a file handle\n"
"(of type `System.File.File` by calling `fileOpen`).\n"
msgstr "*base* 库中的模块 `System.File` 导出处理文件句柄和读取和写入文件所需的实用程序。当您有一个文件路径（例如“/home/hock/idris/tutorial/tutorial.ipkg”）时，我们通常会做的第一件事是尝试创建一个文件句柄（类型为 `System.File. File` 通过调用 `fileOpen`）。"

#. type: Plain text
#: ../src/Tutorial/IO.md:874
#, fuzzy, no-wrap
msgid "Here is a program for counting all empty lines in a Unix/Linux-file:\n"
msgstr "这是一个计算 Unix/Linux 文件中所有空行的程序："

#. type: Plain text
#: ../src/Tutorial/IO.md:875
#, fuzzy, no-wrap
msgid ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"
msgstr ""
"```伊德里斯\n"
"覆盖\n"
"countEmpty：（路径：字符串）-> IO（FileError Nat）\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  覆盖的地方：Nat -> File -> IO（FileError Nat）\n"
"        去k文件=做\n"
"          错误 <- fEOF 文件 | True => closeFile 文件 $> 右 k\n"
"          右 \"\\n\" <- fGetLine 文件\n"
"            |对 _ => 去 k 文件\n"
"            | Left err => closeFile file $> Left err\n"
"          去（k + 1）文件\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:894
#, fuzzy, no-wrap
msgid ""
"In the example above, I invoked `(>>=)` without starting a *do block*.\n"
"Make sure you understand what's going on here. Reading concise functional\n"
"code is important in order to understand other people's code.\n"
"Have a look at function `either` at the REPL, try figuring out what\n"
"`(pure . Left)` does, and note how we use a curried version of `go`\n"
"as the second argument to `either`.\n"
msgstr "在上面的示例中，我调用了 `(>>=)` 而不启动 *do 块*。确保你了解这里发生了什么。阅读简洁的功能代码对于理解其他人的代码很重要。查看 REPL 中的函数 `either`，尝试弄清楚 `(pure . Left)` 做了什么，并注意我们如何使用 `go` 的柯里化版本`either` 的第二个参数。"

#. type: Plain text
#: ../src/Tutorial/IO.md:905
#, fuzzy, no-wrap
msgid ""
"Function `go` calls for some additional explanations. First, note how\n"
"we used the same syntax for pattern matching intermediary results\n"
"as we also saw for `let` bindings. As you can see, we can use several\n"
"vertical bars to handle more than one additional pattern. In order to\n"
"read a single line from a file, we use function `fGetLine`. As with\n"
"most operations working with the file system, this function might fail\n"
"with a `FileError`, which we have to handle correctly. Note also, that\n"
"`fGetLine` will return the line including its trailing newline character\n"
"`'\\n'`, so in order to check for empty lines, we have to match against\n"
"`\"\\n\"` instead of the empty string `\"\"`.\n"
msgstr "函数 `go` 需要一些额外的解释。首先，请注意我们如何使用与 `let` 绑定相同的语法来进行模式匹配中间结果。如您所见，我们可以使用多个垂直条来处理多个附加模式。为了从文件中读取单行，我们使用函数 `fGetLine`。与使用文件系统的大多数操作一样，此函数可能会因 `FileError` 而失败，我们必须正确处理。另请注意，`fGetLine` 将返回包含其尾随换行符 `'\\n'` 的行，因此为了检查空行，我们必须匹配 `\"\\ n\"` 而不是空字符串 `\"\"`。"

#. type: Plain text
#: ../src/Tutorial/IO.md:910
#, fuzzy, no-wrap
msgid ""
"Finally, `go` is not provably total and rightfully so.\n"
"Files like `/dev/urandom` or `/dev/zero` provide infinite\n"
"streams of data, so `countEmpty` will never\n"
"terminate when invoked with such a file path.\n"
msgstr "最后，`go` 不能被证明是完全的并且是正确的。像 `/dev/urandom` 或 `/dev/zero` 这样的文件提供了无限的数据流，所以当使用这样的文件路径调用时，`countEmpty` 永远不会终止。"

#. type: Title ###
#: ../src/Tutorial/IO.md:911
#, fuzzy, no-wrap
msgid "Safe Resource Handling"
msgstr "### 安全资源处理"

#. type: Plain text
#: ../src/Tutorial/IO.md:919
#, fuzzy, no-wrap
msgid ""
"Note, how we had to manually open and close the file handle in\n"
"`countEmpty`. This is error-prone and tedious. Resource handling\n"
"is a big topic, and we definitely won't be going into the\n"
"details here, but there is a convenient function exported\n"
"from `System.File`: `withFile`, which handles the opening,\n"
"closing and handling of file errors for us.\n"
msgstr "注意，我们必须手动打开和关闭 `countEmpty` 中的文件句柄。这是容易出错且乏味的。资源处理是一个很大的话题，这里肯定不赘述，但是从`System.File`导出一个方便的函数：`withFile`，处理打开，为我们关闭和处理文件错误。"

#. type: Plain text
#: ../src/Tutorial/IO.md:920
#, fuzzy, no-wrap
msgid ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"
msgstr ""
"```伊德里斯\n"
"覆盖\n"
"countEmpty'：（路径：字符串）-> IO（FileError Nat）\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  覆盖的地方：Nat -> File -> IO（FileError Nat）\n"
"        去k文件=做\n"
"          错误 <- fEOF 文件 |真 => 纯（右 k）\n"
"          右 \"\\n\" <- fGetLine 文件\n"
"            |对 _ => 去 k 文件\n"
"            |左错误 => 纯（左错误）\n"
"          去（k + 1）文件\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:937
#, fuzzy, no-wrap
msgid ""
"Go ahead, and have a look at the type of `withFile`, then\n"
"have a look how we use it to simplify the implementation of\n"
"`countEmpty'`. Reading and understanding slightly more complex\n"
"function types is important when learning to program in Idris.\n"
msgstr "来吧，看看 `withFile` 的类型，然后看看我们如何使用它来简化 `countEmpty'` 的实现。在学习 Idris 编程时，阅读和理解稍微复杂的函数类型很重要。"

#. type: Title ####
#: ../src/Tutorial/IO.md:938
#, fuzzy, no-wrap
msgid "Interface `HasIO`"
msgstr "####接口`HasIO`"

#. type: Plain text
#: ../src/Tutorial/IO.md:948
#, fuzzy, no-wrap
msgid ""
"When you look at the `IO` functions we used so far, you'll\n"
"notice that most if not all of them actually don't work\n"
"with `IO` itself but with a type parameter `io` with a\n"
"constraint of `HasIO`. This interface allows us to *lift*\n"
"a value of type `IO a` into another context. We will see\n"
"use cases for this in later chapters, especially when we\n"
"talk about monad transformers. For now, you can treat these\n"
"`io` parameters as being specialized to `IO`.\n"
msgstr "当您查看我们目前使用的 `IO` 函数时，您会注意到大多数（如果不是全部）实际上不适用于 `IO` 本身，而是使用类型参数 [X158X ]io`，约束为 `HasIO`。该接口允许我们将 * 提升 * 类型为 `IO a` 的值放入另一个上下文中。我们将在后面的章节中看到这方面的用例，尤其是当我们谈论 monad 转换器时。现在，您可以将这些 `io` 参数视为专用于 `IO`。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:959
#, fuzzy
msgid ""
"As we have seen in the examples above, `IO` actions working with file "
"handles often come with the risk of failure. We can therefore simplify "
"things by writing some utility functions and a custom *bind* operator to "
"work with these nested effects. In a new namespace `IOErr`, implement the "
"following utility functions and use these to further cleanup the "
"implementation of `countEmpty'`:"
msgstr ""
"正如我们在上面的示例中所看到的，使用文件句柄的 `IO` 操作通常会带来失败的风"
"险。因此，我们可以通过编写一些实用函数和自定义 *bind* 运算符来处理这些嵌套效"
"果来简化事情。在新的命名空间 `IOErr` 中，实现以下实用函数并使用它们进一步清"
"理 `countEmpty'` 的实现："

#. type: Plain text
#: ../src/Tutorial/IO.md:960
#, fuzzy, no-wrap
msgid ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"
msgstr ""
"   纯：a -> IO（要么 e a）\n"
"\n"
"   失败：e -> IO（要么 e a）\n"
"\n"
"   电梯：IO a -> IO（要么 e a）\n"
"\n"
"   抓住：IO（e1 a）->（e1-> IO（e2 a））-> IO（e2 a）\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:977
#, fuzzy
msgid ""
"Write a function `countWords` for counting the words in a file.  Consider "
"using `Data.String.words` and the utilities from exercise 1 in your "
"implementation."
msgstr ""
"编写一个函数 `countWords` 用于计算文件中的单词。考虑在您的实现中使用 `Data."
"String.words` 和练习 1 中的实用程序。"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:983
#, fuzzy
msgid ""
"We can generalize the functionality used in `countEmpty` and `countWords`, "
"by implementing a helper function for iterating over the lines in a file and "
"accumulating some state along the way. Implement `withLines` and use it to "
"reimplement `countEmpty` and `countWords`:"
msgstr ""
"我们可以概括 `countEmpty` 和 `countWords` 中使用的功能，通过实现一个辅助函数"
"来迭代文件中的行并在此过程中累积一些状态。实现 `withLines` 并用它重新实现 "
"`countEmpty` 和 `countWords`："

#. type: Plain text
#: ../src/Tutorial/IO.md:984
#, fuzzy, no-wrap
msgid ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   ```伊德里斯\n"
"   覆盖\n"
"   withLines：（路径：字符串）\n"
"             -> (accum : s -> 字符串 -> s)\n"
"             ->（初始状态：s）\n"
"             -> IO（文件错误）\n"
"   ```\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:996
#, fuzzy
msgid ""
"We often use a `Monoid` for accumulating values.  It is therefore convenient "
"to specialize `withLines` for this case. Use `withLines` to implement "
"`foldLines` according to the type given below:"
msgstr ""
"我们经常使用 `Monoid` 来累加值。因此在这种情况下特化 `withLines` 很方便。使"
"用 `withLines` 根据下面给出的类型实现 `foldLines`："

#. type: Plain text
#: ../src/Tutorial/IO.md:997
#, fuzzy, no-wrap
msgid ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   ```伊德里斯\n"
"   覆盖\n"
"   foldLines : Monoid s\n"
"             =>（路径：字符串）\n"
"             -> (f: 字符串 -> s)\n"
"             -> IO（文件错误）\n"
"   ```\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:1012
#, fuzzy
msgid ""
"Implement function `wordCount` for counting the number of lines, words, and "
"characters in a text document. Define a custom record type together with an "
"implementation of `Monoid` for storing and accumulating these values and use "
"`foldLines` in your implementation of `wordCount`."
msgstr ""
"实现函数 `wordCount` 用于计算文本文档中的行数、单词数和字符数。定义自定义记录"
"类型以及 `Monoid` 的实现，用于存储和累积这些值，并在 `wordCount` 的实现中使"
"用 `foldLines`。"

#. type: Title ##
#: ../src/Tutorial/IO.md:1013
#, fuzzy, no-wrap
msgid "How `IO` is Implemented"
msgstr "## `IO` 是如何实现的"

#. type: Plain text
#: ../src/Tutorial/IO.md:1019
#, fuzzy, no-wrap
msgid ""
"In this final section of an already lengthy chapter, we will risk\n"
"a glance at how `IO` is implemented in Idris. It is interesting\n"
"to note, that `IO` is not a built-in type but a regular data type\n"
"with only one minor speciality. Let's learn about it at the REPL:\n"
msgstr "在已经很长的一章的最后一节中，我们将冒险看一眼 `IO` 在 Idris 中是如何实现的。有趣的是，`IO` 不是内置类型，而是只有一个小特性的常规数据类型。让我们在 REPL 中了解它："

#. type: Plain text
#: ../src/Tutorial/IO.md:1020
#, fuzzy, no-wrap
msgid ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"
msgstr ""
"```repl\n"
"教程.IO> :doc IO\n"
"数据 PrimIO.IO：类型 -> 类型\n"
"  总量：总计\n"
"  构造函数： MkIO : (1 _ : PrimIO a) -> IO a\n"
"  提示：\n"
"    应用IO\n"
"    函子 IO\n"
"    HasLinearIO IO\n"
"    单子IO\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1037
#, fuzzy, no-wrap
msgid ""
"Here, we learn that `IO` has a single data constructor\n"
"called `MkIO`, which takes a single argument of type\n"
"`PrimIO a` with quantity *1*. We are not going to\n"
"talk about the quantities here, as in fact they are not\n"
"important to understand how `IO` works.\n"
msgstr "在这里，我们了解到 `IO` 有一个名为 `MkIO` 的单个数据构造函数，它采用类型为 `PrimIO a` 的单个参数，数量为 *1* .我们不打算在这里讨论数量，因为事实上它们对于理解 `IO` 的工作原理并不重要。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1039
#, fuzzy, no-wrap
msgid "Now, `PrimIO a` is a type alias for the following function:\n"
msgstr "现在，`PrimIO a` 是以下函数的类型别名："

#. type: Plain text
#: ../src/Tutorial/IO.md:1040
#, fuzzy, no-wrap
msgid ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"
msgstr "```repl Tutorial.IO> :printdef PrimIO PrimIO.PrimIO : Type -> Type PrimIO a = (1 _ : %World) -> IORes a ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:1049
#, fuzzy, no-wrap
msgid ""
"Again, don't mind the quantities. There is only\n"
"one piece of the puzzle missing: `IORes a`, which is\n"
"a publicly exported record type:\n"
msgstr "再次，不要介意数量。只缺少一块拼图：`IORes a`，这是一种公开导出的记录类型："

#. type: Plain text
#: ../src/Tutorial/IO.md:1050
#, fuzzy, no-wrap
msgid ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"
msgstr ""
"```repl\n"
"Solutions.IO> :doc IORes\n"
"数据 PrimIO.IORes：类型 -> 类型\n"
"  总量：总计\n"
"  构造函数： MkIORes : a -> (1 _ : %World) -> IORes a\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1059
#, fuzzy, no-wrap
msgid ""
"So, to put this all together, `IO` is a wrapper around\n"
"something similar to the following function type:\n"
msgstr "所以，总而言之，`IO` 是一个类似于以下函数类型的包装器："

#. type: Plain text
#: ../src/Tutorial/IO.md:1060
#, fuzzy, no-wrap
msgid "%World -> (a, %World)\n"
msgstr "```repl %World -> (a, %World) ```"

#. type: Plain text
#: ../src/Tutorial/IO.md:1072
#, fuzzy, no-wrap
msgid ""
"You can think of type `%World` as a placeholder for the\n"
"state of the outside world of a program (file system,\n"
"memory, network connections, and so on). Conceptually,\n"
"to execute an `IO a` action, we pass it the current state\n"
"of the world, and in return get an updated world state\n"
"plus a result of type `a`. The world state being updated\n"
"represents all the side effects describable in a computer\n"
"program.\n"
msgstr "您可以将类型 `%World` 视为程序外部世界状态（文件系统、内存、网络连接等）的占位符。从概念上讲，要执行 `IO a` 动作，我们将世界的当前状态传递给它，并作为回报获得更新的世界状态加上 `a` 类型的结果。正在更新的世界状态代表了计算机程序中可描述的所有副作用。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1088
#, fuzzy, no-wrap
msgid ""
"Now, it is important to understand that there is no such\n"
"thing as the *state of the world*. The `%World` type is\n"
"just a placeholder, which is converted to some kind of\n"
"constant that's passed around and never inspected at\n"
"runtime. So, if we had a value of type `%World`, we could\n"
"pass it to an `IO a` action and execute it, and this is\n"
"exactly what happens at runtime: A single value of\n"
"type `%World` (an uninteresting placeholder like `null`,\n"
"`0`, or - in case of the JavaScript backends - `undefined`)\n"
"is passed to the `main` function, thus\n"
"setting the whole program in motion. However, it\n"
"is impossible to programmatically create a value of\n"
"type `%World` (it is an abstract, primitive type), and\n"
"therefore we cannot ever extract a value of type `a`\n"
"from an `IO a` action (modulo `unsafePerformIO`).\n"
msgstr "现在，重要的是要了解世界上没有 * 状态 * 这样的东西。 `%World` 类型只是一个占位符，它被转换为某种常量，在运行时不会被检查。因此，如果我们有一个 `%World` 类型的值，我们可以将它传递给 `IO a` 动作并执行它，这正是运行时发生的情况：类型 `%World`（一个无趣的占位符，如 `null`、`0`，或者 - 如果是 JavaScript 后端 - `undefined`）被传递给`main` 函数，从而使整个程序运行起来。但是，不可能以编程方式创建 `%World` 类型的值（它是一种抽象的原始类型），因此我们永远无法从 `a` X760X]IO 一个 ` 动作（模 `unsafePerformIO`）。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1094
#, fuzzy, no-wrap
msgid ""
"Once we will talk about monad transformers and the state\n"
"monad, you will see that `IO` is nothing else but\n"
"a state monad in disguise but with an abstract state\n"
"type, which makes it impossible for us to run the\n"
"stateful computation.\n"
msgstr "一旦我们将讨论 monad 转换器和 state monad，你会发现 `IO` 只不过是一个伪装的 state monad，但具有抽象的状态类型，这使得我们无法运行有状态计算."

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1099
#, fuzzy
msgid ""
"Values of type `IO a` describe programs with side effects, which will "
"eventually result in a value of type `a`."
msgstr "`IO a` 类型的值描述了具有副作用的程序，最终将导致 `a` 类型的值。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1104
#, fuzzy
msgid ""
"While we cannot safely extract a value of type `a` from an `IO a`, we can "
"use several combinators and syntactic constructs to combine `IO` actions and "
"build more-complex programs."
msgstr ""
"虽然我们不能安全地从 `IO a` 中提取 `a` 类型的值，但我们可以使用多个组合子和句"
"法结构来组合 `IO` 动作并构建更复杂的程式。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1107
#, fuzzy
msgid ""
"*Do blocks* offer a convenient way to run and combine `IO` actions "
"sequentially."
msgstr "*Do blocks* 提供了一种方便的方式来顺序运行和组合 `IO` 动作。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1110
#, fuzzy
msgid ""
"*Do blocks* are desugared to nested applications of *bind* operators "
"(`(>>=)`)."
msgstr "*Do 块* 对 *bind* 运算符 (`(>>=)`) 的嵌套应用程序进行去糖化。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1114
#, fuzzy
msgid ""
"*Bind* operators, and thus *do blocks*, can be overloaded to achieve custom "
"behavior instead of the default (monadic) *bind*."
msgstr ""
"*Bind* 操作符和 *do 块 * 可以被重载以实现自定义行为，而不是默认的（单子）"
"*bind*。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1117
#, fuzzy
msgid ""
"Under the hood, `IO` actions are stateful computations operating on a "
"symbolic `%World` state."
msgstr "在底层，`IO` 动作是在符号 `%World` 状态上运行的有状态计算。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1123
#, fuzzy, no-wrap
msgid ""
"Now, that we had a glimpse at *monads* and the *bind* operator,\n"
"it is time to in the [next chapter](Functor.md) introduce `Monad` and some\n"
"related interfaces for real.\n"
msgstr "现在，我们已经了解了 *monads* 和 *bind* 运算符，是时候在 [下一章](Functor.md) 中介绍 `Monad` 和一些相关的接口是真实的。"
