# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-02 23:16+0800\n"
"PO-Revision-Date: 2022-08-03 05:18+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2-tutorial/datatypes/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"

#. type: Title #
#: ../src/Tutorial/DataTypes.md:1
#, no-wrap
msgid "Algebraic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:8
msgid ""
"In the [previous chapter](Functions1.md), we learned how to write our own "
"functions and combine them to create more complex functionality. Of equal "
"importance is the ability to define our own data types and use them as "
"arguments and results in functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:15
msgid ""
"This is a lengthy chapter, densely packed with information.  If you are new "
"to Idris and functional programming, make sure to follow along slowly, "
"experimenting with the examples, and possibly coming up with your own. Make "
"sure to try and solve *all* exercises. The solutions to the exercises can be "
"found [here](../Solutions/DataTypes.idr)."
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr "idris"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:16
#, fuzzy, no-wrap
msgid "module Tutorial.DataTypes\n"
msgstr "```idris 模块 Tutorial.Interfaces"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:20
#, no-wrap
msgid "Enumerations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:24
msgid "Let's start with a data type for the days of the week as an example."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:25
#, no-wrap
msgid ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:38
msgid ""
"The declaration above defines a new *type* (`Weekday`) and several new "
"*values* (`Monday` to `Sunday`) of the given type. Go ahead, and verify this "
"at the REPL:"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr "repl"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:39
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:48
msgid ""
"So, `Monday` is of type `Weekday`, while `Weekday` itself is of type `Type`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:52
msgid ""
"It is important to note, that a value of type `Weekday` can only ever be one "
"of the values listed above. It is a *type error* to use anything else where "
"a `Weekday` is expected."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:53
#, fuzzy, no-wrap
msgid "Pattern Matching"
msgstr "#### 隐式模式匹配"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:59
msgid ""
"In order to use our new data type as a function argument, we need to learn "
"about an important concept in functional programming languages: Pattern "
"matching. Let's implement a function, which calculates the successor of a "
"weekday:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:60
#, no-wrap
msgid ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:81
msgid ""
"In order to inspect a `Weekday` argument, we match on the different possible "
"values and return a result for each of them.  This is a very powerful "
"concept, as it allows us to match on and extract values from deeply nested "
"data structures.  The different cases in a pattern match are inspected from "
"top to bottom, each being compared against the current function argument. "
"Once a matching pattern is found, the computation on the right hand side of "
"this pattern is evaluated. Later patterns are then ignored."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:89
msgid ""
"For instance, if we invoke `next` with argument `Thursday`, the first three "
"patterns (`Monaday`, `Tuesday`, and `Wednesday`)  will be checked against "
"the argument, but they do not match.  The fourth pattern is a match, and "
"result `Friday` is being returned. Later patterns are then ignored, even if "
"they would also match the input (this becomes relevant with catch-all "
"patterns, which we will talk about in a moment)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:98
msgid ""
"The function above is provably total. Idris knows about the possible values "
"of type `Weekday`, and can therefore figure out that our pattern match "
"covers all possible cases. We can therefore annotate the function with the "
"`total` keyword, and Idris will answer with a type error, if it can't verify "
"the function's totality. (Go ahead, and try removing one of the clauses in "
"`next` to get an idea about how an error message from the coverage checker "
"looks like.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:105
msgid ""
"Please remember, that these are very strong guarantees from the type "
"checker: Given enough resources, a provably total function will *always* "
"return a result of the given type in a finite amount of time (*resources* "
"here meaning computational resources like memory or, in case of recursive "
"functions, stack space)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:106
#, no-wrap
msgid "Catch-all Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:111
msgid ""
"Sometimes, it is convenient to only match on a subset of the possible values "
"and collect the remaining possibilities in a catch-all clause:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:112
#, no-wrap
msgid ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:125
msgid ""
"The final line with the catch-all pattern is only invoked, if the argument "
"is not equal to `Saturday` or `Sunday`.  Remember: Patterns in a pattern "
"match are matched against the input from top to bottom and the first match "
"decides, which path on the right hand side will be taken."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:129
msgid ""
"We can use catch-all patterns to implement an equality test for `Weekday` "
"(we will not yet use the `==` operator for this; this will have to wait "
"until we learn about *interfaces*):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:130
#, no-wrap
msgid ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:143
#, fuzzy, no-wrap
msgid "Enumeration Types in the Prelude"
msgstr "## *Prelude*中的接口"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:151
msgid ""
"Data types like `Weekday` consisting of a finite set of values are sometimes "
"called *enumerations*. The Idris *Prelude* defines some common enumerations "
"for us, for instance `Bool` and `Ordering`. As with `Weekday`, we can use "
"pattern matching when implementing functions on these types:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:152
#, no-wrap
msgid ""
"-- this is how `not` is implemented in the *Prelude*\n"
"total\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:162
msgid ""
"The `Ordering` data type describes an ordering relation between two values. "
"For instance:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:163
#, no-wrap
msgid ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:176
msgid ""
"Here, `LT` means that the first argument is *less than* the second, `EQ` "
"means that the two arguments are *equal* and `GT` means, that the first "
"argument is *greater than* the second."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:177
#, no-wrap
msgid "Case Expressions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:183
msgid ""
"Sometimes we need to perform a computation with one of the arguments and "
"want to pattern match on the result of this computation. We can use *case "
"expressions* in this situation:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:184
#, no-wrap
msgid ""
"-- returns the larger of the two arguments\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:202
msgid ""
"The first line of the case expression (`case compare x y of`)  will invoke "
"function `compare` with arguments `x` and `y`. On the following (indented) "
"lines, we pattern match on the result of this computation. This is of type "
"`Ordering`, so we expect one of the three constructors `LT`, `EQ`, or `GT` "
"as the result.  On the first line, we handle the `LT` case explicitly, while "
"the other two cases are handled with an underscore as a catch-all pattern."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:206
msgid ""
"Note, that indentation matters here: The case block as a whole must be "
"indented (if it starts on a new line), and the different cases must also be "
"indented by the same amount of whitespace."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:209
msgid ""
"Function `compare` is overloaded for many data types. We will learn how this "
"works when we talk about interfaces."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/DataTypes.md:210
#, no-wrap
msgid "If Then Else"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:214
msgid ""
"When working with `Bool`, there is an alternative to pattern matching common "
"to most programming languages:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:215
#, no-wrap
msgid ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:225
msgid ""
"Note, that the `if then else` expression always returns a value and "
"therefore, the `else` branch cannot be dropped. This is different from the "
"behavior in typical imperative languages, where `if` is a statement with "
"possible side effects."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:226
#, no-wrap
msgid "Naming Conventions: Identifiers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:233
msgid ""
"While we are free to use lower-case and upper-case identifiers for function "
"names, type- and data constructors must be given upper-case identifiers in "
"order not to confuse Idris (operators are also fine).  For instance, the "
"following data definition is not valid, and Idris will complain that it "
"expected upper-case identifiers:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:234
#, no-wrap
msgid "data foo = bar | baz\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:240
msgid ""
"The same goes for similar data definitions like records and sum types (both "
"will be explained below):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:241
#, fuzzy, no-wrap
msgid ""
"-- not valid Idris\n"
"record Foo where\n"
"  constructor mkfoo\n"
msgstr ""
"   ```伊德里斯\n"
"   记录任何地方\n"
"     构造函数 MkAny\n"
"     任何：布尔\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:252
msgid ""
"On the other hand, we typically use lower-case identifiers for function "
"names, unless we plan to use them mostly during type checking (more on this "
"later). This is not enforced by Idris, however, so if you are working in a "
"domain where upper-case identifiers are preferable, feel free to use those:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:253
#, no-wrap
msgid ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, fuzzy, no-wrap
msgid "Exercises part 1"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:267
msgid ""
"Use pattern matching to implement your own versions of boolean operators "
"`(&&)` and `(||)` calling them `and` and `or` respectively."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:274
#, no-wrap
msgid ""
"   Note: One way to go about this is to enumerate\n"
"   all four possible combinations of two boolean\n"
"   values and give the result for each. However, there\n"
"   is a shorter, more clever way,\n"
"   requiring only two pattern matches for each of the\n"
"   two functions.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:282
msgid ""
"Define your own data type representing different units of time (seconds, "
"minutes, hours, days, weeks), and implement the following functions for "
"converting between time spans using different units. Hint: Use integer "
"division (`div`)  when going from seconds to some larger unit like hours)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:283
#, no-wrap
msgid ""
"   data UnitOfTime = Second -- add additional values\n"
"\n"
"   -- calculate the number of seconds from a\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- Given a number of seconds, calculate the\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- convert the number of steps in a given unit of time\n"
"   -- to the number of steps in another unit of time.\n"
"   -- use `fromSeconds` and `toSeconds` in your implementation\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:306
msgid ""
"Define a data type for representing a subset of the chemical elements: "
"Hydrogen (H), Carbon (C), Nitrogen (N), Oxygen (O), and Fluorine (F)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:309
#, no-wrap
msgid ""
"   Declare and implement function `atomicMass`, which for each element\n"
"   returns its atomic mass in dalton:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:310
#, no-wrap
msgid ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:318
#, fuzzy, no-wrap
msgid "Sum Types"
msgstr "# 西格玛类型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:326
msgid ""
"Assume we'd like to write some web form, where users of our web application "
"can decide how they like to be addressed.  We give them a choice between two "
"common predefined forms of address (Mr and Mrs), but also allow them to "
"decide on a customized form. The possible choices can be encapsulated in an "
"Idris data type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:327
#, no-wrap
msgid "data Title = Mr | Mrs | Other String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:336
msgid ""
"This looks almost like an enumeration type, with the exception that there is "
"a new thing, called a *data constructor*, which accepts a `String` argument "
"(actually, the values in an enumeration are also called (nullary) data "
"constructors).  If we inspect the types at the REPL, we learn the following:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:337
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:347
msgid ""
"So, `Other` is a *function* from `String` to `Title`. This means, that we "
"can pass `Other` a `String` argument and get a `Title` as the result:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:348
#, no-wrap
msgid ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:358
msgid ""
"Again, a value of type `Title` can only consist of one of the three choices "
"listed above, and again, we can use pattern matching to implement functions "
"on the `Title` data type in a provably total way:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:359
#, no-wrap
msgid ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:372
msgid ""
"Note, how in the last pattern match, the string value stored in the `Other` "
"data constructor is *bound* to local variable `x`.  Also, the `Other x` "
"pattern has to be wrapped in parentheses, as otherwise Idris would think "
"`Other` and `x` were to distinct function arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:377
msgid ""
"This is a very common way to extract the values from data constructors.  We "
"can use `showTitle` to implement a function for creating a courteous "
"greeting:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:378
#, no-wrap
msgid ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:387
msgid ""
"In the implementation of `greet`, we use string literals and the string "
"concatenation operator `(++)` to assemble the greeting from its parts."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:389
msgid "At the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:390
#, no-wrap
msgid ""
"Tutorial.DataTypes> greet dr \"Hck\"\n"
"\"Hello, Dr. Hck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:400
msgid ""
"Data types like `Title` are called *sum types* as they consist of the sum of "
"their different parts: A value of type `Title` is either a `Mr`, a `Mrs`, or "
"a `String` wrapped up in `Other`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:407
msgid ""
"Here's another (drastically simplified) example of a sum type.  Assume we "
"allow two forms of authentication in our web application: Either by entering "
"a username plus a password (for which we'll use an unsigned 64 bit integer "
"here), or by providing user name plus a (very complex) secret key.  Here's a "
"data type to encapsulate this use case:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:408
#, no-wrap
msgid "data Credentials = Password String Bits64 | Key String String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:414
msgid ""
"As an example of a very primitive login function, we can hard-code some "
"known credentials:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:415
#, no-wrap
msgid ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:426
msgid ""
"As can be seen in the example above, we can also pattern match against "
"primitive values by using integer and string literals. Give `login` a go at "
"the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:427
#, no-wrap
msgid ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:622
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, fuzzy, no-wrap
msgid "Exercises part 2"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:440
msgid ""
"Implement an equality test for `Title` (you can use the equality operator "
"`(==)` for comparing two `String`s):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:441
#, fuzzy, no-wrap
msgid ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"
msgstr ""
"    ```伊德里斯\n"
"    数字：Bits64 -> 基数 -> 字符串\n"
"    ```\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:448
msgid ""
"For `Title`, implement a simple test to check, whether a custom title is "
"being used:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:449
#, fuzzy, no-wrap
msgid ""
"   total\n"
"   isOther : Title -> Bool\n"
msgstr ""
"      ```伊德里斯\n"
"      头部：List01 真 a -> a\n"
"      ```\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:456
msgid ""
"Given our simple `Credentials` type, there are three ways for authentication "
"to fail:"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "An unknown username was used."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "The password given does not match the one associated with the username."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "An invalid key was used."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:467
#, no-wrap
msgid ""
"   Encapsulate these three possibilities in a sum type\n"
"   called `LoginError`,\n"
"   but make sure not to disclose any confidential information:\n"
"   An invalid username should be stored in the corresponding\n"
"   error value, but an invalid password or key should not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:471
msgid ""
"Implement function `showError : LoginError -> String`, which can be used to "
"display an error message to the user who unsuccessfully tried to login into "
"our web application."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:472
#, no-wrap
msgid "Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:481
msgid ""
"It is often useful to group together several values as a logical unit. For "
"instance, in our web application we might want to group information about a "
"user in a single data type. Such data types are often called *product types* "
"(see below for an explanation).  The most common and convenient way to "
"define them is the `record` construct:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:482
#, fuzzy, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"
msgstr ""
"记录专辑在哪里\n"
"  构造函数 MkAlbum\n"
"  名称：字符串\n"
"  艺术家：艺术家\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:493
msgid ""
"The declaration above creates a new *type* called `User`, and a new *data "
"constructor* called `MkUser`. As usual, have a look at their types in the "
"REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:494
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:504
msgid ""
"We can use `MkUser` (which is a function from `String` to `Title` to `Bits8` "
"to `User`)  to create values of type `User`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:505
#, no-wrap
msgid ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:517
msgid ""
"We can also use pattern matching to extract the fields from a `User` value "
"(they can again be bound to local variables):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:518
#, no-wrap
msgid ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:530
msgid ""
"In the example above, the `name` and `title` field are bound to two new "
"local variables (`n` and `t` respectively), which can then be used on the "
"right hand side of `greetUser`'s implementation. For the `age` field, which "
"is not used on the right hand side, we can use an underscore as a catch-all "
"pattern."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:545
msgid ""
"Note, how Idris will prevent us from making a common mistake: If we confuse "
"the order of arguments, the implementation will no longer type check. We can "
"verify this by putting the erroneous code in a `failing` block: This is an "
"indented code block, which will lead to an error during elaboration (type "
"checking). We can give part of the expected error message as an optional "
"string argument to a failing block. If this does not match part of the error "
"message (or the whole code block does not fail to type check) the `failing` "
"block itself fails to type check. This is a useful tool to demonstrate that "
"type safety works in two directions: We can show that valid code type checks "
"but also that invalid code is rejected by the Idris elaborator:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:546
#, no-wrap
msgid ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:558
msgid ""
"In addition, for every record field, Idris creates an extractor function of "
"the same name. This can either be used as a regular function, or it can be "
"used in postfix notation by appending it to a variable of the record type "
"separated by a dot. Here are two examples for extracting the age from a user:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:559
#, no-wrap
msgid ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:567
#, no-wrap
msgid "Syntactic Sugar for Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:581
msgid ""
"As was already mentioned in the [intro](Intro.md), Idris is a *pure* "
"functional programming language. In pure functions, we are not allowed to "
"modify global mutable state. As such, if we want to modify a record value, "
"we will always create a *new* value with the original value remaining "
"unchanged: Records and other Idris values are *immutable*.  While this *can* "
"have a slight impact on performance, it has the benefit that we can freely "
"pass a record value to different functions, without fear of the functions "
"modifying the value by in-place mutation. These are, again, very strong "
"guarantees, which makes it drastically easier to reason about our code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:586
msgid ""
"There are several ways to modify a record, the most general being to pattern "
"match on the record and adjust each field as desired. If, for instance, we'd "
"like to increase the age of a `User` by one, we could do the following:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:587
#, no-wrap
msgid ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:597
msgid ""
"That's a lot of code for such a simple thing, so Idris offers several "
"syntactic conveniences for this. For instance, using *record* syntax, we can "
"just access and update the `age` field of a value:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:598
#, no-wrap
msgid ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:607
msgid ""
"Assignment operator `:=` assigns a new value to the `age` field in `u`. "
"Remember, that this will create a new `User` value. The original value `u` "
"remains unaffected by this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:613
msgid ""
"We can access a record field, either by using the field name as a projection "
"function (`age u`; also have a look at `:t age` in the REPL), or by using "
"dot syntax: `u.age`. This is special syntax and *not* related to the dot "
"operator for function composition (`(.)`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:616
msgid ""
"The use case of modifying a record field is so common that Idris provides "
"special syntax for this as well:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:617
#, no-wrap
msgid ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:627
msgid ""
"Here, I used an *operator section* (`(+ 1)`) to make the code more concise.  "
"As an alternative to an operator section, we could have used an anonymous "
"function like so:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:628
#, no-wrap
msgid ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:637
msgid ""
"Finally, since our function's argument `u` is only used once at the very "
"end, we can drop it altogether, to get the following, highly concise version:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:638
#, no-wrap
msgid ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:645
msgid "As usual, we should have a look at the result at the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:646
#, no-wrap
msgid ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:653
msgid ""
"It is possible to use this syntax to set and/or update several record fields "
"at once:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:654
#, no-wrap
msgid ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:660
#, no-wrap
msgid "Tuples"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:666
msgid ""
"I wrote above that a record is also called a *product type*.  This is quite "
"obvious when we consider the number of possible values inhabiting a given "
"type. For instance, consider the following custom record:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:667
#, fuzzy, no-wrap
msgid ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"
msgstr ""
"   记录所有地方\n"
"     构造函数 MkAll\n"
"     全部：布尔\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:678
msgid ""
"How many possible values of type `Foo` are there? The answer is `7 * 2 = "
"14`, as we can pair every possible `Weekday` (seven in total) with every "
"possible `Bool` (two in total). So, the number of possible values of a "
"record type is the *product* of the number of possible values for each field."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:680
msgid ""
"The canonical product type is the `Pair`, which is available from the "
"*Prelude*:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:681
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:692
msgid ""
"Since it is quite common to return several values from a function wrapped in "
"a `Pair` or larger tuple, Idris provides some syntactic sugar for working "
"with these. Instead of `Pair Weekday Bool`, we can just write `(Weekday, "
"Bool)`. Likewise, instead of `MkPair wd b`, we can just write `(wd, b)` (the "
"space is optional):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:693
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:700
msgid "This works also for nested tuples:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:701
#, no-wrap
msgid ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:713
msgid ""
"In the example above, `triple2` is converted to the form used in `triple` by "
"the Idris compiler."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:715
msgid "We can even use tuple syntax in pattern matches:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:716
#, no-wrap
msgid ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:723
#, no-wrap
msgid "As Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:728
msgid ""
"Sometimes, we'd like to take apart a value by pattern matching on it but "
"still retain the value as a whole for using it in further computations:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:729
#, no-wrap
msgid ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:741
msgid ""
"In `baz`, variable `t` is *bound* to the triple as a whole, which is then "
"reused to construct the resulting quadruple. Remember, that `(Nat,Bool,"
"Weekday,String)` is just sugar for `Pair Nat (Bool,Weekday,String)`, and "
"`(length s, t)` is just sugar for `MkPair (length s) t`. Hence, the "
"implementation above is correct as is confirmed by the type checker."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:842
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, fuzzy, no-wrap
msgid "Exercises part 3"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:748
#, no-wrap
msgid ""
"1. Define a record type for time spans by pairing a `UnitOfTime`\n"
"with an integer representing the duration of the time span in\n"
"the given unit of time. Define also a function for converting\n"
"a time span to an `Integer` representing the duration in seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:752
#, no-wrap
msgid ""
"2. Implement an equality check for time spans: Two time spans\n"
"should be considered equal, if and only if they correspond to\n"
"the same number of seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:757
#, no-wrap
msgid ""
"3. Implement a function for pretty printing time spans:\n"
"The resulting string should display the time span in its\n"
"given unit, plus show the number of seconds in parentheses,\n"
"if the unit is not already seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:761
#, no-wrap
msgid ""
"4. Implement a function for adding two time spans. If the\n"
"two time spans use different units of time, use the smaller\n"
"unit of time to ensure a lossless conversion.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:762
#, no-wrap
msgid "Generic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:772
msgid ""
"Sometimes, a concept is general enough that we'd like to apply it not only "
"to a single type, but to all kinds of types. For instance, we might not want "
"to define data types for lists of integers, lists of strings, and lists of "
"booleans, as this would lead to a lot of code duplication.  Instead, we'd "
"like to have a single generic list type *parameterized* by the type of "
"values it stores. This section explains how to define and use generic types."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:773
#, no-wrap
msgid "Maybe"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:786
msgid ""
"Consider the case of parsing a `Weekday` from user input. Surely, such a "
"function should return `Saturday`, if the string input was `\"Saturday\"`, "
"but what if the input was `\"sdfkl332\"`? We have several options here.  For "
"instance, we could just return a default result (`Sunday` perhaps?). But is "
"this the behavior programmers expect when using our library? Maybe not. To "
"silently continue with a default value in the face of invalid user input is "
"hardly ever the best choice and may lead to a lot of confusion."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:792
msgid ""
"In an imperative language, our function would probably throw an exception. "
"We could do this in Idris as well (there is function `idris_crash` in the "
"*Prelude* for this), but doing so, we would abandon totality! A high price "
"to pay for such a common thing as a parsing error."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:803
msgid ""
"In languages like Java, our function might also return some kind of `null` "
"value (leading to the dreaded `NullPointerException`s if not handled "
"properly in client code). Our solution will be similar, but instead of "
"silently returning `null`, we will make the possibility of failure visible "
"in the types! We define a custom data type, which encapsulates the "
"possibility of failure. Defining new data types in Idris is very cheap (in "
"terms of the amount of code needed), therefore this is often the way to go "
"in order to increase type safety.  Here's an example how to do this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:804
#, no-wrap
msgid ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:823
msgid ""
"But assume now, we'd also like to read `Bool` values from user input. We'd "
"now have to write a custom data type `MaybeBool` and so on for all types "
"we'd like to read from `String`, and the conversion of which might fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:827
msgid ""
"Idris, like many other programming languages, allows us to generalize this "
"behavior by using *generic data types*. Here's an example:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:828
#, no-wrap
msgid ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:839
msgid "It is important to go to the REPL and look at the types:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:840
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Optin a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:857
msgid ""
"We need to introduce some jargon here. `Option` is what we call a *type "
"constructor*. It is not yet a saturated type: It is a function from `Type` "
"to `Type`.  However, `Option Bool` is a type, as is `Option Weekday`.  Even "
"`Option (Option Bool)` is a valid type. `Option` is a type constructor "
"*parameterized* over a *parameter* of type `Type`.  `Some` and `None` are "
"`Option`s *data constructors*: The functions used to create values of type "
"`Option a` for a type `a`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:860
msgid ""
"Let's see some other use cases for `Option`. Below is a safe division "
"operation:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:861
#, no-wrap
msgid ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:872
msgid ""
"The possibility of returning some kind of *null* value in the face of "
"invalid input is so common, that there is a data type like `Option` already "
"in the *Prelude*: `Maybe`, with data constructors `Just` and `Nothing`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:884
msgid ""
"It is important to understand the difference between returning `Maybe "
"Integer` in a function, which might fail, and returning `null` in languages "
"like Java: In the former case, the possibility of failure is visible in the "
"types. The type checker will force us to treat `Maybe Integer` differently "
"than `Integer`: Idris will *not* allow us to forget to eventually handle the "
"failure case.  Not so, if `null` is silently returned without adjusting the "
"types. Programmers may (and often *will*) forget to handle the `null` case, "
"leading to unexpected and sometimes hard to debug runtime exceptions."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:885
#, no-wrap
msgid "Either"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:896
msgid ""
"While `Maybe` is very useful to quickly provide a default value to signal "
"some kind of failure, this value (`Nothing`) is not very informative. It "
"will not tell us *what exactly* went wrong. For instance, in case of our "
"`Weekday` reading function, it might be interesting later on to know the "
"value of the invalid input string. And just like with `Maybe` and `Option` "
"above, this concept is general enough that we might encounter other types of "
"invalid values.  Here's a data type to encapsulate this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:897
#, no-wrap
msgid "data Validated e a = Invalid e | Valid a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:907
msgid ""
"`Validated` is a type constructor parameterized over two type parameters `e` "
"and `a`. It's data constructors are `Invalid` and `Valid`, the former "
"holding a value describing some error condition, the latter the result in "
"case of a successful computation.  Let's see this in action:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:908
#, no-wrap
msgid ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:929
msgid ""
"Again, this is such a general concept that a data type similar to "
"`Validated` is already available from the *Prelude*: `Either` with data "
"constructors `Left` and `Right`.  It is very common for functions to "
"encapsulate the possibility of failure by returning an `Either err val`, "
"where `err` is the error type and `val` is the desired return type. This is "
"the type safe (and total!) alternative to throwing a catchable exception in "
"an imperative language."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:934
msgid ""
"Note, however, that the semantics of `Either` are not always \"`Left` is an "
"error and `Right` a success\". A function returning an `Either` just means "
"that it can have to different types of results, each of which are *tagged* "
"with the corresponding data constructor."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:935
#, no-wrap
msgid "List"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:941
msgid ""
"One of the most important data structures in pure functional programming is "
"the singly linked list. Here is its definition (called `Seq` in order for it "
"not to collide with `List`, which is of course already available from the "
"Prelude):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:942
#, no-wrap
msgid "data Seq a = Nil | (::) a (Seq a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:953
msgid ""
"This calls for some explanations. `Seq` consists of two *data constructors*: "
"`Nil` (representing an empty sequence of values) and `(::)` (also called the "
"*cons operator*), which prepends a new value of type `a` to an already "
"existing list of values of the same type. As you can see, we can also use "
"operators as data constructors, but please do not overuse this. Use clear "
"names for your functions and data constructors and only introduce new "
"operators when it truly helps readability!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:956
msgid ""
"Here is an example of how to use the `List` constructors (I use `List` here, "
"as this is what you should use in your own code):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:957
#, no-wrap
msgid ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:966
msgid ""
"However, there is a more concise way of writing the above. Idris accepts "
"special syntax for constructing data types consisting exactly of the two "
"constructors `Nil` and `(::)`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:967
#, no-wrap
msgid ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:980
msgid ""
"The two definitions `ints` and `ints2` are treated identically by the "
"compiler.  Note, that list syntax can also be used in pattern matches."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:991
msgid ""
"There is another thing that's special about `Seq` and `List`: Each of them "
"is defined in terms of itself (the cons operator accepts a value and another "
"`Seq` as arguments). We call such data types *recursive* data types, and "
"their recursive nature means, that in order to decompose or consume them, we "
"typically require recursive functions. In an imperative language, we might "
"use a for loop or similar construct to iterate over the values of a `List` "
"or a `Seq`, but these things do not exist in a language without in-place "
"mutation. Here's how to sum a list of integers:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:992
#, no-wrap
msgid ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1004
msgid ""
"Recursive functions can be hard to grasp at first, so I'll break this down a "
"bit. If we invoke `intSum` with the empty list, the first pattern matches "
"and the function returns zero immediately.  If, however, we invoke `intSum` "
"with a non-empty list - `[7,5,9]` for instance - the following happens:"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1008
msgid ""
"The second pattern matches and splits the list into two parts: Its head "
"(`7`) is bound to variable `n` and its tail (`[5,9]`) is bound to `ns`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1009
#, no-wrap
msgid "   7 + intSum [5,9]\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1015
msgid ""
"In a second invocation, `intSum` is called with a new list: `[5,9]`.  The "
"second pattern matches and `n` is bound to `5` and `ns` is bound to `[9]`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1016
#, no-wrap
msgid "   7 + (5 + intSum [9])\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1023
msgid ""
"In a third invocation `intSum` is called with list `[9]`.  The second "
"pattern matches and `n` is bound to `9` and `ns` is bound to `[]`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1024
#, no-wrap
msgid "   7 + (5 + (9 + intSum [])\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1030
msgid ""
"In a fourth invocation, `intSum` is called with list `[]` and returns `0` "
"immediately:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1031
#, no-wrap
msgid "   7 + (5 + (9 + 0)\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1037
msgid "In the third invocation, `9` and `0` are added and `9` is returned:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1038
#, no-wrap
msgid "   7 + (5 + 9)\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DataTypes.md:1044
msgid "In the second invocation, `5` and `9` are added and `14` is returned:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1045
#, no-wrap
msgid "   7 + 14\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DataTypes.md:1051
msgid ""
"Finally, our initial invocation of `intSum` adds `7` and `14` and returns "
"`21`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1055
msgid ""
"Thus, the recursive implementation of `intSum` leads to a sequence of nested "
"calls to `intSum`, which terminates once the argument is the empty list."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1056
#, fuzzy, no-wrap
msgid "Generic Functions"
msgstr "### 派生函数"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1062
msgid ""
"In order to fully appreciate the versatility that comes with generic data "
"types, we also need to talk about generic functions.  Like generic types, "
"these are parameterized over one or more type parameters."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1068
msgid ""
"Consider for instance the case of breaking out of the `Option` data type. In "
"case of a `Some`, we'd like to return the stored value, while for the `None` "
"case we provide a default value. Here's how to do this, specialized to "
"`Integer`s:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1069
#, no-wrap
msgid ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1080
msgid ""
"It's pretty obvious that this, again, is not general enough.  Surely, we'd "
"also like to break out of `Option Bool` or `Option String` in a similar "
"fashion. That's exactly what the generic function `fromOption` does:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1081
#, no-wrap
msgid ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1095
msgid ""
"The lower-case `a` is again a *type parameter*. You can read the type "
"signature as follows: \"For any type `a`, given a *value* of type `a`, and "
"an `Option a`, we can return a value of type `a`.\" Note, that `fromOption` "
"knows nothing else about `a`, other than it being a type. It is therefore "
"not possible, to conjure a value of type `a` out of thin air. We *must* have "
"a value available to deal with the `None` case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1098
msgid ""
"The pendant to `fromOption` for `Maybe` is called `fromMaybe` and is "
"available from module `Data.Maybe` from the *base* library."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1104
msgid ""
"Sometimes, `fromOption` is not general enough. Assume we'd like to print the "
"value of a freshly parsed `Bool`, giving some generic error message in case "
"of a `None`. We can't use `fromOption` for this, as we have an `Option Bool` "
"and we'd like to return a `String`. Here's how to do this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1105
#, no-wrap
msgid ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1121
#, no-wrap
msgid ""
"Function `option` is parameterized over *two* type parameters:\n"
"`a` represents the type of values stored in the `Option`,\n"
"while `b` is the return type. In case of a `Just`, we need\n"
"a way to convert the stored `a` to a `b`, an that's done\n"
"using the function argument of type `a -> b`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1126
msgid ""
"In Idris, lower-case identifiers in function types are treated as *type "
"parameters*, while upper-case identifiers are treated as types or type "
"constructors that must be in scope."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, fuzzy, no-wrap
msgid "Exercises part 4"
msgstr ""
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 4 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1137
msgid ""
"If this is your first time programming in a purely functional language, the "
"exercises below are *very* important. Do not skip any of them! Take your "
"time and work through them all. In most cases, the types should be enough to "
"explain what's going on, even though they might appear cryptic in the "
"beginning. Otherwise, have a look at the comments (if any)  of each exercise."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1140
msgid ""
"Remember, that lower-case identifiers in a function signature are treated as "
"type parameters."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1142
msgid "Implement the following generic functions for `Maybe`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1143
#, no-wrap
msgid ""
"   -- make sure to map a `Just` to a `Just`.\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- keep the value in a `Just` only if the given predicate holds\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the first value that is not a `Nothing` (if any)\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the last value that is not a `Nothing` (if any)\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- this is another general way to extract a value from a `Maybe`.\n"
"   -- Make sure the following holds:\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1177
msgid "Implement the following generic functions for `Either`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1178
#, no-wrap
msgid ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- In case of both `Either`s being `Left`s, keep the\n"
"   -- value stored in the first `Left`.\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- Keep the first value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- Keep the last value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1207
msgid "Implement the following generic functions for `List`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1208
#, no-wrap
msgid ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- return the first value of a list, if it is non-empty\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the first value of a list, if it is non-empty\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- return the last value of a list, if it is non-empty\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the last value of a list,\n"
"   -- if it is non-empty\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- accumulate the values in a list using the given\n"
"   -- accumulator function and initial value\n"
"   --\n"
"   -- Examples:\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1245
msgid ""
"Assume we store user data for our web application in the following record:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1246
#, fuzzy, no-wrap
msgid ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"
msgstr ""
"记录专辑在哪里\n"
"  构造函数 MkAlbum\n"
"  名称：字符串\n"
"  艺术家：艺术家\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1260
#, no-wrap
msgid ""
"   Using `LoginError` from an earlier exercise,\n"
"   implement function `login`, which, given a list of `Client`s\n"
"   plus a value of type `Credentials` will return either a `LoginError`\n"
"   in case no valid credentials where provided, or the first `Client`\n"
"   for whom the credentials match.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1264
msgid ""
"Using your data type for chemical elements from an earlier exercise, "
"implement a function for calculating the molar mass of a molecular formula."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1268
#, no-wrap
msgid ""
"   Use a list of elements each paired with its count\n"
"   (a natural number) for representing formulae. For\n"
"   instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1269
#, no-wrap
msgid ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1276
#, no-wrap
msgid ""
"   Hint: You can use function `cast` to convert a natural\n"
"   number to a `Double`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1277
#, no-wrap
msgid "Alternative Syntax for Data Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1285
msgid ""
"While the examples in the section about parameterized data types are short "
"and concise, there is a slightly more verbose but much more general form for "
"writing such definitions, which makes it much clearer what's going on.  In "
"my opinion, this more general form should be preferred in all but the most "
"simple data definitions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1290
msgid ""
"Here are the definitions of `Option`, `Validated`, and `Seq` again, using "
"this more general form (I put them in their own *namespace*, so Idris will "
"not complain about identical names in the same source file):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1291
#, no-wrap
msgid ""
"-- GADT is an acronym for \"generalized algebraic data type\"\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1318
#, no-wrap
msgid ""
"Here, `Option` is clearly declared as a type constructor\n"
"(a function of type `Type -> Type`), while `Some`\n"
"is a generic function of type `a -> Option a` (where `a` is\n"
"a *type parameter*)\n"
"and `None` is a nullary generic function of type `Option a`\n"
"(`a` again being a type parameter).\n"
"Likewise for `Validated` and `Seq`. Note, that in case\n"
"of `Seq` we had to disambiguate between the different\n"
"`Seq` definitions in the recursive case. Since we will\n"
"usually not define several data types with the same name in\n"
"a source file, this is not necessary most of the time.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:871
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1323
msgid ""
"We covered a lot of ground in this chapter, so I'll summarize the most "
"important points below:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1326
#, no-wrap
msgid ""
"* Enumerations are data types consisting of a finite\n"
"number of possible *values*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1330
#, no-wrap
msgid ""
"* Sum types are data types with more than one data\n"
"constructor, where each constructor describes a\n"
"*choice* that can be made.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1333
#, no-wrap
msgid ""
"* Product types are data types with a single constructor\n"
"used to group several values of possibly different types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1337
#, no-wrap
msgid ""
"* We use pattern matching to deconstruct immutable\n"
"values in Idris. The possible patterns correspond to\n"
"a data type's data constructors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1341
#, no-wrap
msgid ""
"* We can *bind* variables to values in a pattern or\n"
"use an underscore as a placeholder for a value that's\n"
"not needed on the right hand side of an implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1344
#, no-wrap
msgid ""
"* We can pattern match on an intermediary result by introducing\n"
"a *case block*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1349
#, no-wrap
msgid ""
"* The preferred way to define new product types is\n"
"to define them as *records*, since these come with\n"
"additional syntactic conveniences for setting and\n"
"modifying individual *record fields*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1354
#, no-wrap
msgid ""
"* Generic types and functions allow us generalize\n"
"certain concepts and make them available for many\n"
"types by using *type parameters* instead of\n"
"concrete types in function and type signatures.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1361
#, no-wrap
msgid ""
"* Common concepts like *nullary values* (`Maybe`),\n"
"computations that might fail with some error\n"
"condition (`Either`), and handling collections\n"
"of values of the same type at once (`List`) are\n"
"example use cases of generic types and functions\n"
"already provided by the *Prelude*.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:903
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr "下一步是什么"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1366
msgid ""
"In the [next section](Interfaces.md), we will introduce *interfaces*, "
"another approach to *function overloading*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"
