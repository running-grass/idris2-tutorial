# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-03 13:26+0800\n"
"PO-Revision-Date: 2022-08-03 07:47+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2-tutorial/functions1/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr "idris"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr "repl"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:871
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:903
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr "下一步是什么"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, no-wrap
msgid "Functions Part 1"
msgstr "函数第 1 部分"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
#, no-wrap
msgid ""
"Idris is a *functional* programming language. This means,\n"
"that functions are its main form of abstraction (unlike for\n"
"instance in an object oriented language like Java, where\n"
"*objects* and *classes* are the main form of abstraction). It also\n"
"means that we expect Idris to make it very easy for\n"
"us to compose and combine functions to create new\n"
"functions. In fact, in Idris functions are *first class*:\n"
"Functions can take other functions as arguments and\n"
"can return functions as their results.\n"
msgstr ""
"Idris 是一种 *函数式* 编程语言。这意味着，函数是它的主要抽象形式（与 Java "
"等面向对象的语言不同，其中 *objects* 和 *classes* 是抽象的主要形式）。"
"这也意味着我们希望 Idris 能够让我们非常轻松地组合函数以创建新函数。实际上，"
"在 Idris "
"中，函数是*一等*的：函数可以将其他函数作为参数，并且可以将函数作为结果返回。"
"\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
#, no-wrap
msgid ""
"We already learned about the basic shape of top level\n"
"function declarations in Idris in the [introduction](Intro.md),\n"
"so we will continue from what we learned there.\n"
msgstr ""
"我们已经在 [introduction](Intro.md) 中了解了 Idris "
"中顶级函数声明的基本形式，因此我们将从那里学到的内容继续。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr "module Tutorial.Functions1\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, no-wrap
msgid "Functions with more than one Argument"
msgstr "具有多个参数的函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
#, no-wrap
msgid ""
"Let's implement a function, which checks if its three\n"
"`Integer` arguments form a\n"
"[Pythagorean triple](https://en.wikipedia.org/wiki/Pythagorean_triple).\n"
"We get to use a new operator for this: `==`, the equality\n"
"operator.\n"
msgstr ""
"让我们实现一个函数，它检查它的三个 `Integer` 参数是否形成一个 "
"[勾股三元组](https://en.wikipedia.org/wiki/"
"Pythagorean_triple)。我们为此使用一个新的运算符：`==`，相等运算符。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
#, no-wrap
msgid ""
"Let's give this a spin at the REPL before we talk a bit\n"
"about the types:\n"
msgstr "在讨论类型之前，让我们先在 REPL 上试一下：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr "从这个例子可以看出，多参数函数的类型包含一个参数类型的序列（也称为 * 输入类型 *），由函数箭头（`->`）链接起来，其中由输出类型终止（在本例中为 `Bool`）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
#, no-wrap
msgid ""
"The implementation looks a bit like a mathematical equation:\n"
"We list the arguments on the left hand side of `=` and describe the\n"
"computation(s) to perform with them on the right hand\n"
"side. Function implementations in functional programming\n"
"languages often have this more mathematical look compared\n"
"to implementations in imperative  languages, which often\n"
"describe not *what* to compute, but *how* to\n"
"compute it by describing an algorithm as a sequence of\n"
"imperative statements. We will later see that this\n"
"imperative style is also available in Idris, but whenever\n"
"possible we prefer the declarative style.\n"
msgstr ""
"该实现看起来有点像一个数学方程：我们在 `=` 的左侧列出参数，并在右侧描述要使用"
"它们执行的计算。与命令式语言中的实现相比，函数式编程语言中的函数实现通常具有"
"更多的数学外观，命令式语言通常不是描述*要计算什么*，而是通过将算法描述为*如何"
"*来计算它命令式语句的序列。我们稍后会看到这种命令式风格在 Idris "
"中也可用，但只要有可能，我们更喜欢声明式风格。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
#, no-wrap
msgid ""
"As can be seen in the REPL example, functions can be invoked\n"
"by passing the arguments separated by whitespace. No parentheses\n"
"are necessary unless one of the expressions we pass as the\n"
"function's arguments contains itself additional whitespace.\n"
"This comes in very handy when we apply functions\n"
"only partially (see later in this chapter).\n"
msgstr ""
"从 REPL 示例中可以看出，可以通过传递由空格分隔的参数来调用函数。除非我们作为"
"将包含额外的空格的表达式作为函数参数进行传递，否则不需要括号。当我们仅部分应"
"用函数时，这非常方便（见本章后面）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
#, no-wrap
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive\n"
"data type built into the Idris language but just a custom\n"
"data type that you could have written yourself. We will\n"
"learn more about declaring new data types in the\n"
"next chapter.\n"
msgstr ""
"请注意，与 `Integer` 或 `Bits8` 不同，`Bool` 不是 Idris "
"语言中内置的原语数据类型，而只是您可以自己编写的自定义数据类型."
"我们将在下一章了解更多关于声明新数据类型的内容。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, no-wrap
msgid "Function Composition"
msgstr "函数组合"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
#, no-wrap
msgid ""
"Functions can be combined in several ways, the most direct\n"
"probably being the dot operator:\n"
msgstr "函数可以通过多种方式组合，最直接的可能是点运算符：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
#, no-wrap
msgid "Give this a try at the REPL! Does it do what you'd expect?\n"
msgstr "在 REPL 试试这个！它是否符合您的预期？\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
#, no-wrap
msgid ""
"We could have implemented `squareTimes2` without using\n"
"the dot operator as follows:\n"
msgstr "我们可以在不使用点运算符的情况下实现 `squareTimes2`，如下所示：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr "需要注意的是，由点链接的函数，运算符会从右到左调用： `times2 . square`，等同于 `\\n => times2 (square n)` ，而不是 `\\n => square (times2 n)`。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
#, no-wrap
msgid ""
"We can conveniently chain several functions using the\n"
"dot operator to write more complex functions:\n"
msgstr "我们可以方便地使用点运算符链接多个函数来编写更复杂的函数：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
#, no-wrap
msgid ""
"This will first multiply the argument by four, then square\n"
"it twice before converting it to a string (`show`) and\n"
"reversing the resulting `String` (functions `show` and\n"
"`reverse` are part of the Idris *Prelude* and as such are\n"
"available in every Idris program).\n"
msgstr ""
"这将首先将参数乘以四，然后将其平方两次，然后将其转换为字符串 (`show`) "
"并反转结果 `String`（函数 `show` 和 `reverse` 是 Idris *Prelude* 的一部分，"
"因此在每个 Idris 程序中都可用）。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, no-wrap
msgid "Higher-order Functions"
msgstr "高阶函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
#, no-wrap
msgid ""
"Functions can take other functions as arguments. This is\n"
"an incredibly powerful concept and we can go crazy with\n"
"this very easily. But for sanity's sake, we'll start\n"
"slowly:\n"
msgstr "函数可以将其他函数作为参数。这是一个非常强大的概念，我们可以很容易地为此发疯"
"。但为了理智起见，我们将慢慢开始：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
#, no-wrap
msgid ""
"First `isEven` uses the `mod` function to check, whether\n"
"an integer is divisible by two. But the interesting function\n"
"is `testSquare`. It takes two arguments: The first argument\n"
"is of type *function from `Integer` to `Bool`*, and the second\n"
"of type `Integer`. This second argument is squared before\n"
"being passed to the first argument. Again, give this a go\n"
"at the REPL:\n"
msgstr ""
"首先 `isEven` 使用 `mod` 函数来检查一个整数是否可以被 2 整除。但有趣的函数是 "
"`testSquare`。它有两个参数：第一个参数的类型是 *从 `Integer` 到 `Bool` "
"的函数*，第二个参数是 `Integer` "
"类型。在传递给应用第一个参数之前，先把第二个参数进行平方计算。再一次，在 "
"REPL 上试一试：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
#, no-wrap
msgid ""
"Take your time to understand what's going on here. We pass\n"
"function `isEven` as an argument to `testSquare`. The\n"
"second argument is an integer, which will first be squared\n"
"and then passed to `isEven`. While this is not very interesting,\n"
"we will see lots of use cases for passing functions as\n"
"arguments to other functions.\n"
msgstr ""
"花点时间了解这里发生了什么。我们将函数 `isEven` 作为参数传递给 "
"`testSquare`。第二个参数是一个整数，它首先会被平方，然后传递给 `isEven`。虽然"
"这不是很有趣，但我们会看到很多将函数作为参数传递给其他函数的用例。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
#, no-wrap
msgid ""
"I said above, we could go crazy pretty easily.\n"
"Consider for instance the following example:\n"
msgstr "我在上面说过，我们很容易发疯。例如，考虑以下示例：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
#, no-wrap
msgid "And at the REPL:\n"
msgstr "在 REPL 试一下：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
#, no-wrap
msgid ""
"You might be surprised about this behavior, so we'll try\n"
"and break it down. The following two expressions are identical\n"
"in their behavior:\n"
msgstr "您可能会对这种行为感到惊讶，因此我们将尝试对其进行分解。以下两个表达式的行为"
"相同：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
#, no-wrap
msgid ""
"So, `square` raises its argument to the 2nd power,\n"
"`twice square` raises it to its 4th power (by invoking\n"
"`square` twice in succession),\n"
"`twice (twice square)` raises it to its 16th power\n"
"(by invoking `twice square` twice in succession),\n"
"and so on, until `twice (twice (twice (twice square)))`\n"
"raises it to its 65536th power resulting in an impressively\n"
"huge result.\n"
msgstr ""
"因此，`square` 将其参数提升到 2 次方，` 两次 square` 将其提升到 4 次方（"
"通过连续调用 `square` 两次），` twice (twice square)` 将其提升到其 16 次方（"
"通过连续调用 `twice square` 两次），依此类推，直到 `twice (twice (twice ("
"twice square))))` 将其提高到 65536 次方，从而产生了令人印象深刻的巨大结果。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, no-wrap
msgid "Currying"
msgstr "柯里化"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
#, no-wrap
msgid ""
"Once we start using higher-order functions, the concept\n"
"of partial function application (also called *currying*\n"
"after mathematician and logician Haskell Curry) becomes\n"
"very important.\n"
msgstr "一旦我们开始使用高阶函数，偏函数应用的概念（在数学家和逻辑学家 Haskell Curry "
"之后也称为 *柯里化*）变得非常重要。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
#, no-wrap
msgid "Load this file in a REPL session and try the following:\n"
msgstr "在 REPL 会话中加载此文件并尝试以下操作：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr "注意，我们如何在 Idris 中部分应用多参函数，并且返回一个新函数。例如， `isTriple 1` 会将参数 `1` 应用于函数 `isTriple` 并因此返回一个新函数，类型为为 `Integer -> Integer -> Bool`。我们甚至可以使用这种部分应用函数的结果作为一个新的顶级定义：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
#, no-wrap
msgid ""
"We already used partial function application in our `twice`\n"
"examples above to get some impressive results with very\n"
"little code.\n"
msgstr "我们已经在上面的 `twice` "
"示例中使用了偏函数的应用程序，只需很少的代码即可获得一些令人印象深刻的结果。"
"\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, no-wrap
msgid "Anonymous Functions"
msgstr "匿名函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
#, no-wrap
msgid ""
"Sometimes we'd like to pass a small custom function to\n"
"a higher-order function without bothering to write a\n"
"top level definition. For instance, in the following example,\n"
"function `someTest` is very specific and probably not\n"
"very useful in general, but we'd still like to pass it\n"
"to higher-order function `testSquare`:\n"
msgstr ""
"有时我们想将一个小的自定义函数传递给一个高阶函数，而无需编写顶层定义。例如，"
"在下面的示例中，函数 `someTest` 非常具体，一般来说可能不是很有用，"
"但我们仍然希望将它传递给高阶函数 `testSquare`：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
#, no-wrap
msgid "Here's, how to pass it to `testSquare`:\n"
msgstr "下面将展示如何将其传递给 `testSquare`：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
#, no-wrap
msgid ""
"Instead of defining and using `someTest`, we can use an\n"
"anonymous function:\n"
msgstr "我们也可以使用匿名函数，而不用定义和使用 `someTest`：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr ""
"匿名函数有时也称为 *lambdas*（来自[λ演算](https://en.wikipedia.org/wiki/Lambda_calculus)),并且选择了反斜杠，因为它类似于希腊语\n"
"字母 * λ*。 `\\n =>` 语法引入了一个新的参数为 `n` 的匿名函数，实现位于函数箭头的右侧。像其他顶级函数一样，lambda 可以有多个参数，并以逗号分隔：`\\x,y => x * x + y`。当我们将 lambdas 作为参数传递给高阶函数时，它们通常需要用括号括起来或由美元运算符 `($)` 分开（请参阅下一节）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
#, no-wrap
msgid ""
"Note that, in a lambda, arguments are not annotated with types,\n"
"so Idris has to be able to infer them from the current context.\n"
msgstr "请注意，在 lambda 中，参数不使用类型进行注释，因此 Idris "
"必须能够从当前上下文中推断出它们。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, no-wrap
msgid "Operators"
msgstr "操作符"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
#, no-wrap
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into\n"
"the language, but are just regular Idris function with\n"
"some special support for using them in infix notation.\n"
"When we don't use operators in infix notation, we have\n"
"to wrap them in parentheses.\n"
msgstr ""
"在 Idris 中，`.`、`*` 或 `+` 等中缀运算符并未内置于语言中，而只是常规的 "
"Idris 函数对应的中缀符号。当我们使用非中缀表示法的运算符时，我们必须将它们包"
"裹在括号中。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr "举个例子，让我们为类型为 `Bits8 -> Bits8` 的函数自定义操作符：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr ""
"除了声明和定义操作符本身，我们还必须指定它的固定性：`infixr 4 >>>` 表示，`(>>>)` 关联到右边（意思是，那个\n"
"`f >>> g >>> h` 将被解释为 `f >>> (g >>> h)`)优先级为 `4`。你也可以在 REPL 中 看看 *Prelude* 导出的运算符的固定性：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
#, no-wrap
msgid ""
"When you mix infix operators in an expression, those with\n"
"a higher priority bind more tightly. For instance, `(+)`\n"
"is left associated with a priority of 8, while `(*)`\n"
"is left associated with a priority of 9. Hence,\n"
"`a * b + c` is the same as `(a * b) + c` instead of `a * (b + c)`.\n"
msgstr ""
"当您在表达式中混合使用中缀运算符时，具有较高优先级的运算符绑定得更紧密。例如"
"，`(+)` 的优先级为 8，而 `(*)` 的优先级为 9。因此，`a * b + c ` 与 `(a * b) +"
" c` 相同，而不是 `a * (b + c)`。\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, no-wrap
msgid "Operator Sections"
msgstr "操作符块"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
#, no-wrap
msgid ""
"Operators can be partially applied just like regular\n"
"functions. In this case, the whole expression has to\n"
"be wrapped in parentheses and is called an *operator\n"
"section*. Here are two examples:\n"
msgstr "运算符符可以像常规函数一样被部分应用。在这种情况下，整个表达式必须用括号括起"
"来，称为 * 运算符块 *。这里有两个例子：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr "如您所见，`(< 10)`和 `(10 <)`。第一个测试，它的参数为是否小于10，第二，参数是否大于10。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
#, no-wrap
msgid ""
"One exception where operator sections will not work is\n"
"with the *minus* operator `(-)`. Here is an example to\n"
"demonstrate this:\n"
msgstr "运算符部分不起作用的一个例外是使用 *minus* 运算符 "
"`(-)`。下面是一个例子来证明这一点：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
#, no-wrap
msgid ""
"This is just a higher-order function applying the number ten\n"
"to its function argument. This works very well in the following\n"
"example:\n"
msgstr "这只是一个将数字 10 应用于其函数参数的高阶函数。这在以下示例中非常有效：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToThen (* 2)\n"
"20\n"
msgstr ""
"Tutorial.Functions1> applyToThen (* 2)\n"
"20\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
#, no-wrap
msgid ""
"However, if we want to subtract five from ten, the following\n"
"will fail:\n"
msgstr "但是，如果我们想从 10 中减去 5，以下将失败：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
#, no-wrap
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal\n"
"instead of an operator section. In this special case, we therefore\n"
"have to use an anonymous function instead:\n"
msgstr "这里的问题是，Idris 将 `- 5` "
"视为整数字面量而不是运算符块。在这种特殊情况下，我们因此必须使用匿名函数：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr "非运算符的中缀表示法"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
#, no-wrap
msgid ""
"In Idris, it is possible to use infix notation for\n"
"regular binary functions, by wrapping them in backticks.\n"
"It is even possible to define a precedence (fixity) for\n"
"these and use them in operator sections, just like regular\n"
"operators:\n"
msgstr ""
"在 Idris 中，可以对常规双参数函数使用中缀表示法，方法是将它们包装在反引号中。"
"甚至可以为这些定义优先级（固定性）并在运算符块中使用它们，就像常规运算符一样"
"：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr "*Prelude* 导出的运算符"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
#, no-wrap
msgid ""
"Here is a list of important operators exported by the *Prelude*.\n"
"Most of these are *constrained*, that is they work only\n"
"for types implementing a certain *interface*. Don't worry\n"
"about this right now. We will learn about interfaces in due\n"
"time, and the operators behave as they intuitively should.\n"
"For instance, addition and multiplication work for all\n"
"numeric types, comparison operators work for almost all\n"
"types in the *Prelude* with the exception of functions.\n"
msgstr ""
"以下是 *Prelude* 导出的重要运算符列表。其中大多数具有 * 约束 *，"
"也就是说它们仅适用于实现了某个 * 接口 * 的类型。现在不要担心这个。我们将在适"
"当的时候了解接口，运算符会按照直觉行事。例如，加法和乘法适用于所有数字类型，"
"比较运算符适用于 *Prelude* 中的几乎所有类型，但函数除外。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(.)`: Function composition"
msgstr "`(.)`：函数组合"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(+)`: Addition"
msgstr "`(+)`：加法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(*)`: Multiplication"
msgstr "`(*)`：乘法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(-)`: Subtraction"
msgstr "`(-)`：减法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/)`: Division"
msgstr "`(/)`：除法"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(==)` : True, if two values are equal"
msgstr "`(==)` ：判断两个值是否相等"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/=)` : True, if two values are not equal"
msgstr "`(/=)` ：如果两个值不相等则结果为真"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators"
msgstr "`(<=)`、`(>=)`、`(<)` 和 `(>)` ：比较运算符"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`($)`: Function application"
msgstr "`($)`：函数应用"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
#, no-wrap
msgid ""
"The most special of the above is the last one. It has a\n"
"priority of 0, so all other operators bind more tightly.\n"
"In addition, function application binds more tightly, so\n"
"this can be used to reduce the number of parentheses\n"
"required. For instance, instead of writing\n"
"`isTriple 3 4 (2 + 3 * 1)` we can write\n"
"`isTriple 3 4 $ 2 + 3 * 1`,\n"
"which is exactly the same. Sometimes, this helps readability,\n"
"sometimes, it doesn't. The important thing to remember is\n"
"that `fun $ x y` is just the same as `fun (x y)`.\n"
msgstr ""
"上面最特别的是最后一个。它的优先级为 0，所有其他运算符都比他绑定得更紧密。因"
"此可以使用它来减少所需的括号数量。例如，不写 `isTriple 3 4 (2 + 3 * 1)` "
"我们可以写成 `isTriple 3 4 $ 2 + 3 * "
"1`，这完全一样。有时，这有助于提高可读性，虽然有时并不会。要记住的重要一点是 "
"`fun $ x y` 与 `fun (x y)` 相同。\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr "练习"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot operator and "
"dropping the second arguments (have a look at the implementation of "
"`squareTimes2` to get an idea where this should lead you). This highly "
"concise way of writing function implementations is sometimes called *point-"
"free style* and is often the preferred way of writing small utility "
"functions."
msgstr ""
"通过使用点运算符并删除第二个参数重新实现函数 `testSquare` 和 `twice`（查看 "
"`squareTimes2` 的实现应该可以让你更加了解）。这种编写函数实现的高度简洁的方式"
"有时被称为*无值风格*，并且通常是编写小型实用函数的首选方式。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven` from "
"above and `not` (from the Idris *Prelude*). Use point-free style."
msgstr "通过组合上面的函数 `isEven` 和 `not`（来自 Idris *Prelude*）来声明和实现函数 "
"`isOdd`。使用无值风格。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
msgid ""
"Declare and implement function `isSquareOf`, which checks whether its first "
"`Integer` argument is the square of the second argument."
msgstr "声明并实现函数 `isSquareOf`，检查它的第一个 `Integer` "
"参数是否是第二个参数的平方。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
msgid ""
"Declare and implement function `isSmall`, which checks whether its `Integer` "
"argument is less than or equal to 100. Use one of the comparison operators "
"`<=` or `>=` in your implementation."
msgstr ""
"声明并实现函数 `isSmall`，检查其 `Integer` 参数是否小于或等于 100。"
"在你的实现中使用比较运算符 `<=` 或 `>=` 之一。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
msgid ""
"Declare and implement function `absIsSmall`, which checks whether the "
"absolute value of its `Integer` argument is less than or equal to 100.  Use "
"functions `isSmall` and `abs` (from the Idris *Prelude*) in your "
"implementation, which should be in point-free style."
msgstr ""
"声明并实现函数 `absIsSmall`，检查其 `Integer` 参数的绝对值是否小于等于100。"
"在你的实现中使用函数 `isSmall` 和 `abs `（来自 Idris "
"*Prelude*），最好是无值风格的。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
msgid ""
"In this slightly extended exercise we are going to implement some utilities "
"for working with `Integer` predicates (functions from `Integer` to `Bool`). "
"Implement the following higher-order functions (use boolean operators `&&`, "
"`||`, and function `not` in your implementations):"
msgstr ""
"在这个稍微扩展的练习中，我们将实现一些实用程序来处理 `Integer` 谓词（从 "
"`Integer` 到 `Bool` 的函数）。实现以下高阶函数（在您的实现中使用布尔运算符 "
"`&&`、`||` 和函数 `not`）："

#. type: Plain text
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- 返回真，当且仅当两个谓词都成立\n"
"   和 : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 返回真，当且仅当至少一个谓词成立\n"
"   或 : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 如果谓词不成立，则返回真\n"
"   否定：（整数->布尔）->整数->布尔\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr ""
"   完成这个练习后，在 REPL 中试一试。在下面的例子中，"
"我们通过用反引号包裹来使用两参数函数 `and` 的中缀表示法的\n"
"。这只是一种语法糖，使某些功能应用程序更具可读性：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
msgid ""
"As explained above, Idris allows us to define our own infix operators.  Even "
"better, Idris supports *overloading* of function names, that is, two "
"functions or operators can have the same name, but different types and "
"implementations.  Idris will make use of the types to distinguish between "
"equally named operators and functions."
msgstr ""
"如上所述，Idris 允许我们定义自己的中缀运算符。更好的是，Idris "
"支持函数名的*重载*，即两个函数或运算符可以有相同的名称，但类型和实现不同。 "
"Idris 将使用类型来区分同名的运算符和函数。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr "   这允许我们重新实现函数 `and`、`or` 和 `negate`，在练习 6 "
"中，使用布尔代数中现有的运算符和函数：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr "   实现另外两个函数并在 REPL 上测试它们：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
#, no-wrap
msgid "What we learned in this chapter:\n"
msgstr "我们在本章中学到了什么：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr "* Idris 中的函数可以接受任意数量的参数，由函数类型中的 `->` 分隔。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr "* 函数可以依次使用点运算符进行组合，这会产生高度简洁的代码。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr "* 可以通过传递更少的函数来偏应用函数，参数少于函数的预期。结果是一个新的函数"
"，预期传入剩下的参数。这种技术被称为*柯里化*。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr ""
"* 函数可以作为参数传递给其他函数，\n"
"允许我们轻松组合小型程序单元来创建\n"
"更复杂的行为。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr "* 我们可以将匿名函数 (*lambdas*) "
"传递给高阶函数，如果编写相应的顶层函数太繁琐。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr ""
"* Idris 允许我们定义自己的中缀运算符。这些必须写在括号中，除非它们被声明\n"
"中缀表示法。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr "* 也可以部分应用中缀运算符。这些*运算符块*必须用括号括起来，并且用作运算符的"
"第一个或第二个参数被确定。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr "* Idris 支持名称重载：函数可以具有相同的名称，但拥有不同的实现。Idris "
"将根据所涉及的类型决定使用哪个函数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
#, no-wrap
msgid ""
"Please note, that function and operator names in a module\n"
"must be unique. In order to define two functions with the same\n"
"name, they have to be declared in distinct modules. If Idris\n"
"is not able to decide, which of the two functions to use, we\n"
"can help name resolution by prefixing a function with\n"
"(a part of) its *namespace*:\n"
msgstr ""
"请注意，模块中的函数和运算符名称必须是唯一的。为了定义两个具有相同名称的函数"
"，它们必须在不同的模块中声明。如果 Idris 无法决定使用这两个函数中的哪一个，"
"我们可以通过在函数前面加上其 *命名空间* 的（部分）前缀来帮助名称解析：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -"
"> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
#, no-wrap
msgid ""
"In the [next section](DataTypes.md), we will learn how to define\n"
"our own data types and how to construct and deconstruct\n"
"values of these new types. We will also learn about\n"
"generic types and functions.\n"
msgstr ""
"在 [下一节](DataTypes.md) 中，我们将学习如何定义我们自己的数据类型以及如何构"
"造和解构这些新类型的值。我们还将学习泛型类型和函数。\n"
