# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-08-03 13:26+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:622
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:842
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/Folds.md:145 ../src/Tutorial/Folds.md:241
#: ../src/Tutorial/Folds.md:326 ../src/Tutorial/Folds.md:582
#: ../src/Tutorial/Intro.md:199 ../src/Tutorial/Intro.md:208
#: ../src/Tutorial/Intro.md:223 ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "sh"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
#, no-wrap
msgid "And at the REPL:\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Prim.md:1
#, no-wrap
msgid "Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:7
#, no-wrap
msgid ""
"In the topics we covered so far, we hardly ever talked about primitive\n"
"types in Idris. They where around and we used them in some computations,\n"
"but I never really explained how they work and where they come from,\n"
"nor did I show in detail what we can and can't do with them.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:8
#, no-wrap
msgid ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:17
#, no-wrap
msgid "How Primitives are Implemented"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:19
#, no-wrap
msgid "A Short Note on Backends"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:30
#, no-wrap
msgid ""
"According to [Wikipedia](https://en.wikipedia.org/wiki/Compiler),\n"
"a compiler is \"a computer program that translates computer code\n"
"written in one programming language (the source language) into\n"
"another language (the target language)\". The Idris compiler is\n"
"exactly that: A program translating programs written in Idris\n"
"into programs written in Chez Scheme. This scheme code is then\n"
"parsed and interpreted by a Chez Scheme interpreter, which must\n"
"be installed on the computers we use to run compiled Idris\n"
"programs.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:37
#, no-wrap
msgid ""
"But that's only part of the story. Idris 2 was from the beginning\n"
"designed to support different code generators (so called *backends*),\n"
"which allows us to write Idris code to target different platforms,\n"
"and your Idris installation comes with several additional\n"
"backends available. You can specify the backend to use with the `--cg` command\n"
"line argument (`cg` stands for *code generator*). For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "idris2 --cg racket\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:45
#, no-wrap
msgid ""
"Here is a non-comprehensive list of the backends available with a\n"
"standard Idris installation (the name to be used in the command line\n"
"argument is given in parentheses):\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Racket Scheme (`racket`): This is a different flavour of the scheme "
"programming language, which can be useful to use when Chez Scheme is not "
"available on your operating system."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid "Node.js (`node`): This converts an Idris program to JavaScript."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Browser (`javascript`): Another JavaScript backend which allows you to write "
"web applications which run in the browser in Idris."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"RefC (`refc`): A backend compiling Idris to C code, which is then further "
"compiled by a C compiler."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:57
#, no-wrap
msgid ""
"I plan to at least cover the JavaScript backends in some more detail\n"
"in another part of this Idris guide, as I use them pretty often myself.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:62
#, no-wrap
msgid ""
"There are also several external backends not officially supported by\n"
"the Idris project, amongst which are backends for compiling Idris code\n"
"to Java and Python. You can find a list of external backends on\n"
"the [Idris Wiki](https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-backends).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:63
#, no-wrap
msgid "The Idris Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:69
#, no-wrap
msgid ""
"A *primitive data type* is a type that is built into the Idris compiler\n"
"together with a set of *primitive functions*, which are used to perform\n"
"calculations on the primitives. You will therefore not find a definition\n"
"of a primitive type or function in the source code of the *Prelude*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:71
#, no-wrap
msgid "Here is again the list of primitive types in Idris:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid ""
"* Signed, fixed precision integers:\n"
"  * `Int8`: Integer in the range [-128,127]\n"
"  * `Int16`: Integer in the range [-32768,32767]\n"
"  * `Int32`: Integer in the range [-2147483648,2147483647]\n"
"  * `Int64`: Integer in the range [-9223372036854775808,9223372036854775807]\n"
"* Unsigned, fixed precision integers:\n"
"  * `Bits8`: Integer in the range [0,255]\n"
"  * `Bits16`: Integer in the range [0,65535]\n"
"  * `Bits32`: Integer in the range [0,4294967295]\n"
"  * `Bits64`: Integer in the range [0,18446744073709551615]\n"
"* `Integer`: A signed, arbitrary precision integer.\n"
"* `Double`: A double precision (64 bit) floating point number.\n"
"* `Char`: A unicode character.\n"
"* `String`: A sequence of unicode characters.\n"
"* `%World`: A symbolic representation of the current world state.\n"
"  We learned about this when I showed you how `IO` is implemented.\n"
"  Most of the time, you will not handle values of this type in your own\n"
"  code.\n"
"* `Int`: This one is special. It is a fixed precision, signed integer,\n"
"   but the bit size is somewhat dependent on the backend and\n"
"   (maybe) platform we use.\n"
"   For instance, if you use the default Chez Scheme backend, `Int` is\n"
"   a 64 bit signed integer, while on the JavaScript backends it is a\n"
"   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
"   with very few guarantees, and you should use one of the well\n"
"   specified integer types listed above whenever possible.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:104
#, no-wrap
msgid ""
"It can be instructive to learn, where in the compiler's source\n"
"code the primitive types and functions are defined. This source\n"
"code can be found in folder `src` of the [Idris project](https://github.com/idris-lang/Idris2)\n"
"and the primitive types are the constant constructors of\n"
"data type `Core.TT.Constant`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:105
#, no-wrap
msgid "Primitive Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:112
#, no-wrap
msgid ""
"All calculations operating on primitives are based on two\n"
"kinds of primitive functions: The ones built into the compiler\n"
"(see below) and the ones defined by programmers via the\n"
"foreign function interface (FFI), about which I'll talk in\n"
"another chapter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:119
#, no-wrap
msgid ""
"Built-in primitive functions are functions known to the compiler\n"
"the definition of which can not be found in the *Prelude*. They\n"
"define the core functionality available for the primitive\n"
"types. Typically, you do not invoke these directly (although\n"
"it is perfectly fine to do so in most cases) but via functions\n"
"and interfaces exported by the *Prelude* or the *base* library.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:123
#, no-wrap
msgid ""
"For instance, the primitive function for adding two eight bit\n"
"unsigned integers is `prim__add_Bits8`. You can inspect its\n"
"type and behavior at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:124
#, no-wrap
msgid ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:148
#, no-wrap
msgid ""
"If you look at the source code implementing interface `Num`\n"
"for `Bits8`, you will see that the plus operator just invokes\n"
"`prim__add_Bits8` internally. The same goes for most of the other\n"
"functions in primitive interface implementations.\n"
"For instance, every primitive type with the exception of\n"
"`%World` comes with primitive comparison functions.\n"
"For `Bits8`, these are:\n"
"`prim__eq_Bits8`, `prim__gt_Bits8`, `prim__lt_Bits8`,\n"
"`prim__gte_Bits8`, and `prim__lte_Bits8`.\n"
"Note, that these functions do not return a `Bool` (which\n"
"is *not* a primitive type in Idris), but an `Int`. They are\n"
"therefore not as safe or convenient to use as the corresponding\n"
"operator implementations form interfaces `Eq` and `Comp`.\n"
"On the other hand, they do not go via a conversion to `Bool`\n"
"and might therefore perform slightly better in performance\n"
"critical code (which you can only identify after some\n"
"serious profiling).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:152
#, no-wrap
msgid ""
"As with primitive types, the primitive functions are listed as\n"
"constructors in a data type (`Core.TT.PrimFn`) in the compiler\n"
"sources. We will look at most of these in the following sections.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:153
#, no-wrap
msgid "Consequences of being Primitive"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:163
#, no-wrap
msgid ""
"Primitive functions and types are opaque to the compiler\n"
"in most regards: They have to be defined and implemented by each\n"
"backend individually, therefore, the compiler knows nothing about the inner\n"
"structure of a primitive value nor about the inner workings\n"
"of primitive functions. For instance, in the following recursive\n"
"function, *we* know that the argument in the recursive call\n"
"must be converging towards the base case (unless there is a bug\n"
"in the backend we use), but the compiler does not:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:164
#, no-wrap
msgid ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:174
#, no-wrap
msgid ""
"In these cases, we either must be content with just a\n"
"*covering* function, or we use `assert_smaller` to\n"
"convince the totality checker (the preferred way):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:175
#, no-wrap
msgid ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:184
#, no-wrap
msgid ""
"I have shown you the risks of using `assert_smaller` before, so we\n"
"must be extra careful in making sure that the new function argument\n"
"is indeed smaller with relation to the base case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:189
#, no-wrap
msgid ""
"While Idris knows nothing about the internal workings of primitives\n"
"and related functions, most of these functions still reduce during\n"
"evaluation when fed with values known at compile time. For instance,\n"
"we can trivially proof that for `Bits8` the following equation holds:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:190
#, no-wrap
msgid ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:200
#, no-wrap
msgid ""
"Having no clue about the internal structure of a primitive\n"
"nor about the implementations of primitive functions,\n"
"Idris can't help us proofing any *general* properties of such functions\n"
"and values. Here is an example to demonstrate this. Assume we'd\n"
"like to wrap a list in a data type indexed by the list's length:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:201
#, no-wrap
msgid ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:209
#, no-wrap
msgid ""
"When we concatenate two `LenList`s, the length indices\n"
"should be added. That's how list concatenation affects the\n"
"length of lists. We can safely teach Idris that this is true:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:210
#, no-wrap
msgid ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:217
#, no-wrap
msgid "With the above lemma, we can implement concatenation of `LenList`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:218
#, no-wrap
msgid ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:231
#, no-wrap
msgid ""
"The same is not possible for strings. There are applications where\n"
"pairing a string with its length would be useful (for instance, if we\n"
"wanted to make sure that strings are getting strictly shorter\n"
"during parsing and will therefore eventually be wholly\n"
"consumed), but Idris cannot help us getting these things right.\n"
"There is no way to implement and thus proof the following\n"
"lemma in a safe way:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:232
#, no-wrap
msgid "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "<!-- markdownlint-disable MD026 -->\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "Believe Me!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:239
#, no-wrap
msgid "<!-- markdownlint-enable MD026 -->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:245
#, no-wrap
msgid ""
"In order to implement `concatLenStr`, we have to abandon all\n"
"safety and use the ten ton wrecking ball of type coercion:\n"
"`believe_me`. This primitive function allows us to freely\n"
"coerce a value of any type into a value of any other type.\n"
"Needless to say, this is only safe if we *really* know what we are doing:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:246
#, no-wrap
msgid "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:257
#, no-wrap
msgid ""
"The explicit assignment of variable `x` in `{x = length a + length b}`\n"
"is necessary, because otherwise Idris will complain about an *unsolved\n"
"hole*: It can't infer the type of parameter `x` in the `Refl`\n"
"constructor. We could assign any type to `x` here, because we\n"
"are passing the result to `believe_me` anyway, but I consider it\n"
"to be good practice to assign one of the two sides of the equality\n"
"to make our intention clear.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:262
#, no-wrap
msgid ""
"The higher the complexity of a primitive type, the riskier\n"
"it is to assume even the most basic properties for it to hold.\n"
"For instance, we might act under the delusion that floating\n"
"point addition is associative:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:263
#, no-wrap
msgid ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:270
#, no-wrap
msgid ""
"Well, guess what: That's a lie. And lies lead us straight\n"
"into the `Void`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:271
#, no-wrap
msgid ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:291
#, no-wrap
msgid ""
"Here's what happens in the code above: The call to `doubleAddAssoc`\n"
"returns a proof that `One + (Tiny + Tiny)` is equal to\n"
"`(One + Tiny) + Tiny`. But `One + (Tiny + Tiny)` equals\n"
"`1.0000000000000002`, while `(One + Tiny) + Tiny` equals `1.0`.\n"
"We can therefore pass our (wrong) proof to `wrong`, because it\n"
"is of the correct type, and from this follows a proof of `Void`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:292
#, no-wrap
msgid "Working with Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:297
#, no-wrap
msgid ""
"Module `Data.String` in *base* offers a rich set of functions\n"
"for working with strings. All these are based on the following\n"
"primitive operations built into the compiler:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strLength`: Returns the length of a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strHead`: Extracts the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strTail`: Removes the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strCons`: Prepends a character to a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strAppend`: Appends two strings."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid ""
"`prim__strIndex`: Extracts a character at the given position from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strSubstr`: Extracts the substring between the given positions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:311
#, no-wrap
msgid ""
"Needless to say, not all of these functions are total. Therefore, Idris\n"
"must make sure that invalid calls do not reduce during compile time, as\n"
"otherwise the compiler would crash. If, however we force the evaluation\n"
"of a partial primitive function by compiling and running the corresponding\n"
"program, this program will crash with an error:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:312
#, no-wrap
msgid ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:323
#, no-wrap
msgid ""
"Note, how `prim__strTail \"\"` is not reduced at the REPL and how the\n"
"same expression leads to a runtime exception if we compile and\n"
"execute the program. Valid calls to `prim__strTail` are reduced\n"
"just fine, however:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:324
#, no-wrap
msgid ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:329
#, no-wrap
msgid "Pack and Unpack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:339
#, no-wrap
msgid ""
"Two of the most important functions for working with strings\n"
"are `unpack` and `pack`, which convert a string to a list\n"
"of characters and vice versa. This allows us to conveniently\n"
"implement many string operations by iterating or folding\n"
"over the list of characters instead. This might not always\n"
"be the most efficient thing to do, but unless you plan to\n"
"handle very large amounts of text, they work and perform\n"
"reasonably well.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:340
#, no-wrap
msgid "String Interpolation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:345
#, no-wrap
msgid ""
"Idris allows us to include arbitrary string expressions in\n"
"a string literal by wrapping them in curly braces, the first\n"
"of which has to be escaped with a backslash. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:346
#, no-wrap
msgid ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:356
#, no-wrap
msgid ""
"This is a very convenient way to assemble complex strings\n"
"from values of different types.\n"
"In addition, there is interface `Interpolation`, which\n"
"allows us to use values in interpolated strings without\n"
"having to convert them to strings first:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:357
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:384
#, no-wrap
msgid "Raw and Multiline String Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:388
#, no-wrap
msgid ""
"In string literals, we have to escape certain characters\n"
"like quotes, backslashes or new line characters. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:389
#, no-wrap
msgid ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: \\\\\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:398
#, no-wrap
msgid ""
"Idris allows us to enter raw string literals, where there\n"
"is no need to escape quotes and backslashes, by pre- and\n"
"postfixing the wrapping quote characters with the same number\n"
"of hash characters. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:399
#, no-wrap
msgid ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:411
#, no-wrap
msgid ""
"With raw string literals, it is still possible to use string\n"
"interpolation, but the opening curly brace has to be prefixed\n"
"with a backslash and the same number of hashes as are being used\n"
"for opening and closing the string literal:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:412
#, no-wrap
msgid ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:424
#, no-wrap
msgid ""
"Finally, Idris also allows us to conveniently write multiline\n"
"strings. These can be pre- and postfixed with hashes if we want\n"
"raw multiline string literals, and they also can be combined with\n"
"string interpolation. Multiline literals are opened and closed with\n"
"triple quote characters. Indenting the closing triple quotes\n"
"allows us to indent the whole multiline literal. Whitespace used\n"
"for indentation will not appear in the resulting string. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:425
#, no-wrap
msgid ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:447
#, no-wrap
msgid ""
"Make sure to look at the example strings at the\n"
"REPL to see the effect of interpolation and raw string\n"
"literals and compare it with the syntax we used.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:454
#, no-wrap
msgid ""
"In these exercises, you are supposed to implement a bunch\n"
"of utility functions for consuming and converting strings.\n"
"I don't give the expected types here, because you are\n"
"supposed to come up with those yourself.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:458
msgid ""
"Implement functions similar to `map`, `filter`, and `mapMaybe` for strings. "
"The output type of these should always be a string."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:461
msgid "Implement functions similar to `foldl` and `foldMap` for strings."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:464
msgid ""
"Implement a function similar to `traverse` for strings. The output type "
"should be a wrapped string."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:467
msgid ""
"Implement the bind operator for strings. The output type should again be a "
"string."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:468
#, no-wrap
msgid "Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:475
#, no-wrap
msgid ""
"As listed at the beginning of this chapter, Idris provides different\n"
"fixed-precision signed and unsigned integer types as well as `Integer`,\n"
"an arbitrary precision signed integer type.\n"
"All of them come with the following primitive functions (given\n"
"here for `Bits8` as an example):\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__add_Bits8`: Integer addition."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__sub_Bits8`: Integer subtraction."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mul_Bits8`: Integer multiplication."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__div_Bits8`: Integer division."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mod_Bits8`: Modulo function."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shl_Bits8`: Bitwise left shift."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shr_Bits8`: Bitwise right shift."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__and_Bits8`: Bitwise *and*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__or_Bits8`: Bitwise *or*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__xor_Bits8`: Bitwise *xor*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:493
#, no-wrap
msgid ""
"Typically, you use the functions for addition and multiplication\n"
"through the operators from interface `Num`, the function\n"
"for subtraction through interface `Neg`, and the functions\n"
"for division (`div` and `mod`) through interface `Integral`.\n"
"The bitwise operations are available through interfaces\n"
"`Data.Bits.Bits` and `Data.Bits.FiniteBits`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:497
#, no-wrap
msgid ""
"For all integral types, the following laws are assumed to\n"
"hold for numeric operations (`x`, `y`, and `z` are\n"
"arbitrary value of the same primitive integral type):\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + y = y + x`: Addition is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + (y + z) = (x + y) + z`: Addition is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + 0 = x`: Zero is the neutral element of addition."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x - x = x + (-x) = 0`: `-x` is the additive inverse of `x`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * y = y * x`: Multiplication is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y * z) = (x * y) * z`: Multiplication is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * 1 = x`: One is the neutral element of multiplication."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y + z) = x * y + x * z`: The distributive law holds."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "``y * (x `div` y) + (x `mod` y) = x`` (for `y /= 0`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:515
#, no-wrap
msgid ""
"Please note, that the officially supported backends use\n"
"*Euclidian modulus* for calculating `mod`:\n"
"For `y /= 0`, ``x `mod` y`` is always a non-negative value\n"
"strictly smaller than `abs y`, so that the law given above\n"
"does hold. If `x` or `y` are negative numbers, this is different\n"
"to what many other languages do but for good reasons as explained\n"
"in the following [article](https://www.microsoft.com/en-us/research/publication/division-and-modulus-for-computer-scientists/).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:516
#, no-wrap
msgid "Unsigned Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:526
#, no-wrap
msgid ""
"The unsigned fixed precision integer types (`Bits8`, `Bits16`,\n"
"`Bits32`, and `Bits64`) come with implementations of all\n"
"integral interfaces (`Num`, `Neg`, and `Integral`) and\n"
"the two interfaces for bitwise operations (`Bits` and `FiniteBits`).\n"
"All functions with the exception of `div` and `mod` are\n"
"total. Overflows are handled by calculating the remainder\n"
"modulo `2^bitsize`. For instance, for `Bits8`, all operations\n"
"calculate their results modulo 256:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:527
#, no-wrap
msgid ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:538
#, no-wrap
msgid "Signed Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:549
#, no-wrap
msgid ""
"Like the unsigned integer types, the signed fixed precision\n"
"integer types (`Int8`, `Int16`, `Int32`, and `Int64`) come with\n"
"implementations of all integral interfaces and\n"
"the two interfaces for bitwise operations (`Bits` and `FiniteBits`).\n"
"Overflows are handled by calculating the remainder\n"
"modulo `2^bitsize` and adding the lower bound (a negative number)\n"
"if the result is still out of range. For instance, for `Int8`, all operations\n"
"calculate their results modulo 256, subtracting 128 if the\n"
"result is still out of bounds:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:550
#, no-wrap
msgid ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:557
#, no-wrap
msgid "Bitwise Operations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:568
#, no-wrap
msgid ""
"Module `Data.Bits` exports interfaces for performing bitwise\n"
"operations on integral types. I'm going to show a couple of\n"
"examples on unsigned 8-bit numbers (`Bits8`) to explain the concept\n"
"to readers new to bitwise arithmetics. Note, that this is much easier\n"
"to grasp for unsigned integer types than for the signed versions.\n"
"Those have to include information about the *sign* of numbers in their\n"
"bit pattern, and it is assumed that signed integers in Idris use\n"
"a [two's complement representation](https://en.wikipedia.org/wiki/Two%27s_complement),\n"
"about which I will not go into the details here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:573
#, no-wrap
msgid ""
"An unsigned 8-bit binary number is represented internally as\n"
"a sequence of eight bits (with values 0 or 1), each of which\n"
"corresponds to a power of 2. For instance,\n"
"the number 23 (= 16 + 4 + 2 + 1) is represented as `0001 0111`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:574
#, no-wrap
msgid ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:583
#, no-wrap
msgid ""
"We can use function `testBit` to check if the bit at the given\n"
"position is set or not:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:584
#, no-wrap
msgid ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:595
#, no-wrap
msgid ""
"Likewise, we can use functions `setBit` and `clearBit` to\n"
"set or unset a bit at a certain position:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:596
#, no-wrap
msgid ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:610
#, no-wrap
msgid ""
"There are also operators `(.&.)` (bitwise *and*) and `(.|.)`\n"
"(bitwise *or*) as well as function `xor` (bitwise *exclusive or*)\n"
"for performing boolean operations on integral values.\n"
"For instance `x .&. y` has exactly those bits set, which both `x`\n"
"and `y` have set, while `x .|. y` has all bits set that are either\n"
"set in `x` or `y` (or both), and ``x `xor` y`` has those bits\n"
"set that are set in exactly one of the two values:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:611
#, no-wrap
msgid ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:621
#, no-wrap
msgid "And here are the examples at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:622
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:637
#, no-wrap
msgid ""
"Finally, it is possible to shift all bits to the right or left\n"
"by a certain number of steps by using functions `shiftR` and\n"
"`shiftL`, respectively (overflowing bits will just be dropped).\n"
"A left shift can therefore be viewed as a multiplication by a\n"
"power of two, while a right shift can be seen as a division\n"
"by a power of two:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:638
#, no-wrap
msgid ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:647
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:657
#, no-wrap
msgid ""
"Bitwise operations are often used in specialized code or\n"
"certain high-performance applications. As programmers, we\n"
"have to know they exist and how they work.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:658
#, no-wrap
msgid "Integer Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:666
#, no-wrap
msgid ""
"So far, we always required an implementation of `Num` in order to\n"
"be able to use integer literals for a given type. However,\n"
"it is actually only necessary to implement a function `fromInteger`\n"
"converting an `Integer` to the type in question. As we will\n"
"see in the last section, such a function can even restrict\n"
"the values allowed as valid literals.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:671
#, no-wrap
msgid ""
"For instance, assume we'd like to define a data type for\n"
"representing the charge of a chemical molecule. Such a value\n"
"can be positive or negative and (theoretically) of almost\n"
"arbitrary magnitude:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:672
#, no-wrap
msgid ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:683
#, no-wrap
msgid ""
"It makes sense to be able to sum up charges, but not to\n"
"multiply them. They should therefore have an implementation\n"
"of `Monoid` but not of `Num`. Still, we'd like to have\n"
"the convenience of integer literals when using constant\n"
"charges at compile time. Here's how to do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:684
#, no-wrap
msgid ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:695
#, no-wrap
msgid "Alternative Bases"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:702
#, no-wrap
msgid ""
"In addition to the well known decimal literals, it is also\n"
"possible to use integer literals in binary, octal, or\n"
"hexadecimal representation. These have to be prefixed\n"
"with a zero following by a `b`, `o`, or `x` for\n"
"binary, octal, and hexadecimal, respectively:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:703
#, no-wrap
msgid ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:716
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.&.)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:719
#, no-wrap
msgid ""
"   Hint: Have a look at the functions available from interface\n"
"   `Bits` to find a value suitable as the neutral element.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:722
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.|.)`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:725
msgid ""
"Use bitwise operations to implement a function, which tests if a given value "
"of type `Bits64` is even or not."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:727
msgid "Convert a value of type `Bits64` to a string in binary representation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:729
msgid ""
"Convert a value of type `Bits64` to a string in hexadecimal representation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:732
#, no-wrap
msgid ""
"   Hint: Use `shiftR` and `(.&. 15)` to access subsequent packages of\n"
"   four bits.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:733
#, no-wrap
msgid "Refined Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:741
#, no-wrap
msgid ""
"We often do not want to allow all values of a type in a certain\n"
"context. For instance, `String` as an arbitrary sequence of\n"
"UTF-8 characters (several of which are not even printable), is\n"
"too general most of the time. Therefore, it is usually advisable\n"
"to rule out invalid values early on, by pairing a value with\n"
"an erased proof of validity.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:749
#, no-wrap
msgid ""
"We have learned how we can write elegant predicates, with\n"
"which we can proof our functions to be total, and from which we\n"
"can - in the ideal case - derive other, related predicates. However,\n"
"when we define predicates on primitives they are to a certain degree\n"
"doomed to live in isolation, unless we come up with a set of\n"
"primitive axioms (implemented most likely using `believe_me`), with\n"
"which we can manipulate our predicates.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:750
#, no-wrap
msgid "Use Case: ASCII Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:756
#, no-wrap
msgid ""
"String encodings is a difficult topic, so in many low level routines\n"
"it makes sense to rule out most characters from the beginning. Assume\n"
"therefore, we'd like to make sure the strings we accept in our\n"
"application only consist of ASCII characters:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:757
#, no-wrap
msgid ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:767
#, no-wrap
msgid ""
"We can now *refine* a string value by pairing it with an erased\n"
"proof of validity:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:768
#, no-wrap
msgid ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:779
#, no-wrap
msgid ""
"It is now *impossible* to at runtime or compile time create\n"
"a value of type `Ascii` without first validating the wrapped\n"
"string. With this, it is already pretty easy to safely wrap strings at\n"
"compile time in a value of type `Ascii`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:780
#, no-wrap
msgid ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:800
#, no-wrap
msgid ""
"And yet, it would be much more convenient to still use string\n"
"literals for this, without having to sacrifice the comfort of\n"
"safety. To do so, we can't use interface `FromString`, as its\n"
"function `fromString` would force us to convert *any* string,\n"
"even an invalid one. However, we actually don't need an implementation of\n"
"`FromString` to support string literals, just like we didn't\n"
"require an implementation of `Num` to support integer literals.\n"
"What we really need is a function named `fromString`. Now, when\n"
"string literals are desugared, they are converted to invocations\n"
"of `fromString` with the given string value as its argument.\n"
"For instance, literal `\"Hello\"` gets desugared to `fromString \"Hello\"`.\n"
"This happens before type checking and filling in of (auto) implicit\n"
"values. It is therefore perfectly fine, to define a custom `fromString`\n"
"function with an erased auto implicit argument as a proof of\n"
"validity:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:801
#, no-wrap
msgid ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> Ascii\n"
"fromString s = MkAscii s prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:808
#, no-wrap
msgid ""
"With this, we can us (valid) string literals for coming up with\n"
"values of type `Ascii` directly:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:809
#, no-wrap
msgid ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:817
#, no-wrap
msgid ""
"In order to at runtime create values of type `Ascii` from strings\n"
"of an unknown source, we can use a refinement function returning\n"
"some kind of failure type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:818
#, no-wrap
msgid ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:829
#, no-wrap
msgid "Disadvantages of Boolean Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:834
#, no-wrap
msgid ""
"For many use cases, what we described above for ASCII strings can\n"
"take us very far. However, one drawback of this approach is that we\n"
"can't safely perform any computations with the proofs at hand.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:839
#, no-wrap
msgid ""
"For instance, we know it will be perfectly fine to concatenate\n"
"two ASCII strings, but in order to convince Idris of this, we\n"
"will have to use `believe_me`, because we will not be able to\n"
"proof the following lemma otherwise:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:840
#, no-wrap
msgid ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:861
#, no-wrap
msgid ""
"The same goes for all operations extracting a substring from\n"
"a given string: We will have to implement according rules using\n"
"`believe_me`. Finding a reasonable set of axioms to conveniently\n"
"deal with refined primitives can therefore be challenging at times,\n"
"and whether such axioms are even required very much depends\n"
"on the use case at hand.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:862
#, no-wrap
msgid "Use Case: Sanitized HTML"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:869
#, no-wrap
msgid ""
"Assume you write a simple web application for scientific\n"
"discourse between registered users. To keep things simple, we\n"
"only consider unformatted text input here. Users can write arbitrary\n"
"text in a text field and upon hitting Enter, the message is\n"
"displayed to all other registered users.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:871
#, no-wrap
msgid "Assume now a user decides to enter the following text:\n"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/Prim.md:872
#, no-wrap
msgid "html"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:872
#, no-wrap
msgid "<script>alert(\"Hello World!\")</script>\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:884
#, no-wrap
msgid ""
"Well, it could have been (much) worse. Still, unless we take measures\n"
"to prevent this from happening, this might embed a JavaScript\n"
"program in our web page we never intended to have there!\n"
"What I described here, is a well known security vulnerability called\n"
"[cross-site scripting](https://en.wikipedia.org/wiki/Cross-site_scripting).\n"
"It allows users of web pages to enter malicious JavaScript code in\n"
"text fields, which will then be included in the page's HTML structure\n"
"and executed when it is being displayed to other users.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:891
#, no-wrap
msgid ""
"We want to make sure, that this cannot happen on our own web page.\n"
"In order to protect us from this attack, we could for instance disallow\n"
"certain characters like `'<'` or `'>'` completely (although this might not\n"
"be enough!), but if our chat service is targeted at programmers,\n"
"this will be overly restrictive. An alternative\n"
"is to escape certain characters before rendering them on the page.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:892
#, no-wrap
msgid ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:910
#, no-wrap
msgid ""
"What we now want to do is to store a string together with\n"
"a proof that is was properly escaped. This is another form\n"
"of existential quantification: \"Here is a string, and there\n"
"once existed another string, which we passed to `escape`\n"
"and arrived at the string we have now\". Here's how to encode\n"
"this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:911
#, no-wrap
msgid ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:925
#, no-wrap
msgid ""
"Whenever we now embed a string of unknown origin in our web page,\n"
"we can request a value of type `Escaped` and have the very\n"
"strong guarantee that we are no longer vulnerable to cross-site\n"
"scripting attacks. Even better, it is also possible to safely\n"
"embed string literals known at compile time without the need\n"
"to escape them first:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:926
#, no-wrap
msgid ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:941
#, no-wrap
msgid ""
"In this massive set of exercises, you are going to build\n"
"a small library for working with predicates on primitives.\n"
"We want to keep the following goals in mind:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"We want to use the usual operations of propositional logic to combine "
"predicates: Negation, conjuction (logical *and*), and disjunction (logical "
"*or*)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"All predicates should be erased at runtime. If we proof something about a "
"primitive number, we want to make sure not to carry around a huge proof of "
"validity."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"Calculations on predicates should make no appearance at runtime (with the "
"exception of `decide`; see below)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"Recursive calculations on predicates should be tail recursive if they are "
"used in implementations of `decide`. This might be tough to achieve. If you "
"can't find a tail recursive solution for a given problem, use what feels "
"most natural instead."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:980
#, no-wrap
msgid ""
"A note on efficiency: In order to be able to run\n"
"computations on our predicates, we try to convert primitive\n"
"values to algebraic data types as often and as soon as possible:\n"
"Unsigned integers will be converted to `Nat` using `cast`,\n"
"and strings will be converted to `List Char` using `unpack`.\n"
"This allows us to work with proofs on `Nat` and `List` most\n"
"of the time, and such proofs can be implemented without\n"
"resorting to `believe_me` or other cheats. However, the one\n"
"advantage of primitive types over algebraic data types is\n"
"that they often perform much better. This is especially\n"
"critical when comparing integral types with `Nat`: Operations\n"
"on natural numbers often run with `O(n)` time complexity,\n"
"where `n` is the size of one of the natural numbers involved,\n"
"while with `Bits64`, for instance, many operations run in fast constant\n"
"time (`O(1)`). Luckily, the Idris compiler optimizes many\n"
"functions on natural number to use the corresponding `Integer`\n"
"operations at runtime. This has the advantage that we can\n"
"still use proper induction to proof stuff about natural\n"
"numbers at compile time, while getting the benefit of fast\n"
"integer operations at runtime. However, operations on `Nat` do\n"
"run with `O(n)` time complexity and *compile time*. Proofs\n"
"working on large natural number will therefore drastically\n"
"slow down the compiler. A way out of this is discussed at\n"
"the end of this section of exercises.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:983
#, no-wrap
msgid ""
"Enough talk, let's begin!\n"
"To start with, you are given the following utilities:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:984
#, no-wrap
msgid ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1025
#, no-wrap
msgid ""
"We also want to run decidable computations at compile time. This\n"
"is often much more efficient than running a direct proof search on\n"
"an inductive type. We therefore come up with a predicate witnessing\n"
"that a `Dec0` value is actually a `Yes0` together with two\n"
"utility functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1026
#, no-wrap
msgid ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1045
#, no-wrap
msgid ""
"Finally, as we are planning to refine mostly primitives, we will\n"
"at times require some sledge hammer to convince Idris that\n"
"we know what we are doing:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1046
#, no-wrap
msgid ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in `unsafeRefineOn`\"\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:1058
msgid "We start with equality proofs. Implement `Decidable` for `Equal v`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1061
#, no-wrap
msgid ""
"   Hint: Use `DecEq` from module `Decidable.Equality` as a constraint\n"
"         and make sure that `v` is available at runtime.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:1063
msgid "We want to be able to negate a predicate:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1064
#, no-wrap
msgid ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1070
#, no-wrap
msgid "   Implement `Decidable` for `Neg p` using a suitable constraint.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:1072
msgid "We want to describe the conjunction of two predicates:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1073
#, no-wrap
msgid ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1079
#, no-wrap
msgid "   Implement `Decidable` for `(p && q)` using suitable constraints.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:1083
msgid ""
"Come up with a data type called `(||)` for the disjunction (logical *or*) of "
"two predicates and implement `Decidable` using suitable constraints."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:1086
msgid ""
"Proof [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)  "
"by implementing the following propositions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1087
#, no-wrap
msgid ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1100
#, no-wrap
msgid ""
"   The last of De Morgan's implications is harder to type and proof\n"
"   as we need a way to come up with values of type `p v` and `q v`\n"
"   and show that not both can exist. Here is a way to encode this\n"
"   (annotated with quantity 0 as we will need to access an erased\n"
"   contraposition):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1101
#, no-wrap
msgid ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1111
#, no-wrap
msgid ""
"   When you implement `negAnd`, remember that you can freely access\n"
"   erased (implicit) arguments, because `negAnd` itself can only be\n"
"   used in an erased context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1117
#, no-wrap
msgid ""
"So far, we implemented the tools to algebraically describe\n"
"and combine several predicate. It is now time to come up\n"
"with some examples. As a first use case, we will focus on\n"
"limiting the valid range of natural numbers. For this,\n"
"we use the following data type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1118
#, no-wrap
msgid ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1128
#, no-wrap
msgid ""
"This is similar to `Data.Nat.LTE` but I find operator\n"
"notation often to be clearer.\n"
"We also can define and use the following aliases:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1129
#, no-wrap
msgid ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Prim.md:1171
msgid ""
"Coming up with a value of type `m <= n` by pattern matching on `m` and `n` "
"is highly inefficient for large values of `m`, as it will require `m` "
"iterations to do so. However, while in an erased context, we don't need to "
"hold a value of type `m <= n`. We only need to show, that such a value "
"follows from a more efficient computation. Such a computation is `compare` "
"for natural numbers: Although this is implemented in the *Prelude* with a "
"pattern match on its arguments, it is optimized by the compiler to a "
"comparison of integers which runs in constant time even for very large "
"numbers.  Since `Prelude.(<=)` for natural numbers is implemented in terms "
"of `compare`, it runs just as efficiently."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1175
#, no-wrap
msgid ""
"   We therefore need to proof the following two lemmas (make\n"
"   sure to not confuse `Prelude.(<=)` with `Prim.(<=)` in\n"
"   these declarations):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1176
#, no-wrap
msgid ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1185
#, no-wrap
msgid ""
"   They come with a quantity of 0, because they are just as inefficient\n"
"   as the other computations we discussed above. We therefore want\n"
"   to make absolutely sure that they will never be used at runtime!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1190
#, no-wrap
msgid ""
"   Now, implement `Decidable Nat (<= n)`, making use of `test0`,\n"
"   `fromLTE`, and `toLTE`.\n"
"   Likewise, implement `Decidable Nat (m <=)`, because we require\n"
"   both kinds of predicates.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1193
#, no-wrap
msgid ""
"   Note: You should by know figure out yourself that `n` must be\n"
"   available at runtime and how to make sure that this is the case.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Prim.md:1198
msgid ""
"Proof that `(<=)` is reflexive and transitive by declaring and implementing "
"corresponding propositions. As we might require the proof of transitivity to "
"chain several values of type `(<=)`, it makes sense to also define a short "
"operator alias for this."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Prim.md:1200
msgid "Proof that from `n > 0` follows `IsSucc n` and vise versa."
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Prim.md:1207
msgid ""
"Declare and implement safe division and modulo functions for `Bits64`, by "
"requesting an erased proof that the denominator is strictly positive when "
"cast to a natural number. In case of the modulo function, return a refined "
"value carrying an erased proof that the result is strictly smaller than the "
"modulus:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1208
#, no-wrap
msgid ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Prim.md:1218
msgid ""
"We will use the predicates and utilities we defined so far to convert a "
"value of type `Bits64` to a string of digits in base `b` with `2 <= b && b "
"<= 16`.  To do so, implement the following skeleton definitions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1223
#, no-wrap
msgid ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1228
#, no-wrap
msgid ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1230
#, no-wrap
msgid "    base : Bits64 -> Maybe Base\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1235
#, no-wrap
msgid ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> Base\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1241
#, no-wrap
msgid ""
"    Finally, implement `digits`, using `safeDiv` and `safeMod`\n"
"    in your implementation. This might be challenging, as you will\n"
"    have to manually transform some proofs to satisfy the type\n"
"    checker. You might also require `assert_smaller` in the\n"
"    recursive step.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1245
#, no-wrap
msgid ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1255
#, no-wrap
msgid ""
"We will now turn our focus on strings. Two of the most\n"
"obvious ways in which we can restrict the strings we\n"
"accept are by limiting the set of characters and\n"
"limiting their lengths. More advanced refinements might\n"
"require strings to match a certain pattern or regular\n"
"expression. In such cases, we might either go for a\n"
"boolean check or use a custom data type representing the\n"
"different parts of the pattern, but we will not cover\n"
"these topics here.\n"
msgstr ""

#. type: Bullet: '11. '
#: ../src/Tutorial/Prim.md:1258
msgid "Implement the following aliases for useful predicates on characters."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1262
#, no-wrap
msgid ""
"    Hint: Use `cast` to convert characters to natural numbers,\n"
"    use `(<=)` and `InRange` to specify regions of characters,\n"
"    and use `(||)` to combine regions of characters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1266
#, no-wrap
msgid ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1269
#, no-wrap
msgid ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1272
#, no-wrap
msgid ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1275
#, no-wrap
msgid ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1278
#, no-wrap
msgid ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1281
#, no-wrap
msgid ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1284
#, no-wrap
msgid ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1287
#, no-wrap
msgid ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1290
#, no-wrap
msgid ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1294
#, no-wrap
msgid ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"
msgstr ""

#. type: Bullet: '12. '
#: ../src/Tutorial/Prim.md:1301
msgid ""
"The advantage of this more modular approach to predicates on primitives is "
"that we can safely run calculations on our predicates and get the strong "
"guarantees from the existing proofs on inductive types like `Nat` and "
"`List`. Here are some examples of such calculations and conversions, all of "
"which can be implemented without cheating:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1304
#, no-wrap
msgid ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1306
#, no-wrap
msgid "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1308
#, no-wrap
msgid "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1310
#, no-wrap
msgid "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1312
#, no-wrap
msgid "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1314
#, no-wrap
msgid "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1317
#, no-wrap
msgid ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1324
#, no-wrap
msgid ""
"    The following (`asciiToLatin`) is trickier. Remember that\n"
"    `(<=)` is transitive. However, in your invocation of the proof\n"
"    of transitivity, you will not be able to apply direct proof search using\n"
"    `%search` because the search depth is too small. You could\n"
"    increase the search depth, but it is much more efficient\n"
"    to use `safeDecideOn` instead.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1327
#, no-wrap
msgid ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1330
#, no-wrap
msgid ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1334
#, no-wrap
msgid ""
"Before we turn our full attention to predicates on strings,\n"
"we have to cover lists first, because we will often treat\n"
"strings as lists of characters.\n"
msgstr ""

#. type: Bullet: '13. '
#: ../src/Tutorial/Prim.md:1336
msgid "Implement `Decidable` for `Head`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1341
#, no-wrap
msgid ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Bullet: '14. '
#: ../src/Tutorial/Prim.md:1343
msgid "Implement `Decidable` for `Length`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1350
#, no-wrap
msgid ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"
msgstr ""

#. type: Bullet: '15. '
#: ../src/Tutorial/Prim.md:1354
msgid ""
"The following predicate is a proof that all values in a list of values "
"fulfill the given predicate. We will use this to limit the valid set of "
"characters in a string."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1363
#, no-wrap
msgid ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1365
#, no-wrap
msgid "    Implement `Decidable` for `All`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1373
#, no-wrap
msgid ""
"    For a real challenge, try to make your implementation of\n"
"    `decide` tail recursive. This will be important for real world\n"
"    applications on the JavaScript backends, where we might want to\n"
"    refine strings of thousands of characters without overflowing the\n"
"    stack at runtime. In order to come up with a tail recursive implementation,\n"
"    you will need an additional data type `AllSnoc` witnessing that a predicate\n"
"    holds for all elements in a `SnocList`.\n"
msgstr ""

#. type: Bullet: '16. '
#: ../src/Tutorial/Prim.md:1379
msgid ""
"It's time to come to an end here. An identifier in Idris is a sequence of "
"alphanumeric characters, possibly separated by underscore characters (`_`). "
"In addition, all identifiers must start with a letter.  Given this "
"specification, implement predicate `IdentChar`, from which we can define a "
"new wrapper type for identifiers:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1382
#, no-wrap
msgid ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1388
#, no-wrap
msgid ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1391
#, no-wrap
msgid ""
"    Implement a factory method `identifier` for converting strings\n"
"    of unknown source at runtime:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1395
#, no-wrap
msgid ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1398
#, no-wrap
msgid ""
"    In addition, implement `fromString` for `Identifier` and verify,\n"
"    that the following is a valid identifier:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1403
#, no-wrap
msgid ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1409
#, no-wrap
msgid ""
"Final remarks: Proofing stuff about the primitives can be challenging,\n"
"both when deciding on what axioms to use and when trying to make\n"
"things perform well at runtime and compile time. I'm experimenting\n"
"with a library, which deals with these issues. It is not yet finished,\n"
"but you can have a look at it [here](https://github.com/stefan-hoeck/idris2-prim).\n"
msgstr ""
