# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-02 13:19+0800\n"
"PO-Revision-Date: 2022-08-02 13:19+0800\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:262 ../src/Tutorial/Dependent.md:445
#: ../src/Tutorial/DPair.md:349 ../src/Tutorial/Eq.md:280
#: ../src/Tutorial/Folds.md:374 ../src/Tutorial/Functor.md:382
#: ../src/Tutorial/Interfaces.md:190 ../src/Tutorial/IO.md:318
#: ../src/Tutorial/Predicates.md:306 ../src/Tutorial/Prim.md:449
#: ../src/Tutorial/Traverse.md:248
msgid "### Exercises part 1"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:437 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:654 ../src/Tutorial/Eq.md:556
#: ../src/Tutorial/Folds.md:669 ../src/Tutorial/Functor.md:963
#: ../src/Tutorial/Interfaces.md:353 ../src/Tutorial/IO.md:729
#: ../src/Tutorial/Predicates.md:673 ../src/Tutorial/Prim.md:713
#: ../src/Tutorial/Traverse.md:575
msgid "### Exercises part 2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:743 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1129 ../src/Tutorial/Eq.md:827
#: ../src/Tutorial/Folds.md:989 ../src/Tutorial/Functor.md:1233
#: ../src/Tutorial/Interfaces.md:625 ../src/Tutorial/IO.md:950
#: ../src/Tutorial/Predicates.md:1021 ../src/Tutorial/Prim.md:937
#: ../src/Tutorial/Traverse.md:1017
msgid "### Exercises part 3"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1320 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1192 ../src/Tutorial/Eq.md:1086
#: ../src/Tutorial/Folds.md:1052 ../src/Tutorial/Functions1.md:525
#: ../src/Tutorial/Functions2.md:925 ../src/Tutorial/Functor.md:1396
#: ../src/Tutorial/Interfaces.md:793 ../src/Tutorial/IO.md:1096
#: ../src/Tutorial/Predicates.md:1359 ../src/Tutorial/Traverse.md:1110
msgid "## Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
msgid "<!-- vi: filetype=idris2 -->"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:15 ../src/Tutorial/DPair.md:37
#: ../src/Tutorial/Eq.md:20 ../src/Tutorial/Folds.md:33
#: ../src/Tutorial/Functions2.md:21 ../src/Tutorial/Functor.md:27
#: ../src/Tutorial/IO.md:19 ../src/Tutorial/Predicates.md:28
#: ../src/Tutorial/Prim.md:16 ../src/Tutorial/Traverse.md:30
msgid "%default total ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:2
msgid "# Sigma Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
msgid ""
"So far in our examples of dependently typed programming, type indices such "
"as the length of vectors were known at compile time or could be calculated "
"from values known at compile time. In real applications, however, such "
"information is often not available until runtime, where values depend on the "
"decisions made by users or the state of the surrounding world.  For "
"instance, if we store a file's content as a vector of lines of text, the "
"length of this vector is in general unknown until the file has been loaded "
"into memory.  As a consequence, the types of values we work with depend on "
"other values only known at runtime, and we can often only figure out these "
"types by pattern matching on the values they depend on.  To express these "
"dependencies, we need so called [*sigma types*](https://en.wikipedia.org/"
"wiki/Dependent_type#%CE%A3_type): Dependent pairs and their generalization, "
"dependent records."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:21
msgid "```idris module Tutorial.DPair"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:23
msgid "import Control.Monad.State"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:32
msgid ""
"import Data.DPair import Data.Either import Data.HList import Data.List "
"import Data.List1 import Data.Singleton import Data.String import Data.Vect"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:34
msgid "import Text.CSV"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:39
msgid "## Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
msgid ""
"We've already seen several examples of how useful the length index of a "
"vector is to describe more precisely in the types what a function can and "
"can't do. For instance, `map` or `traverse` operating on a vector will "
"return a vector of exactly the same length. The types guarantee that this is "
"true, therefore the following function is perfectly safe and provably total:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:51
msgid ""
"```idris parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)  "
"parseAndDrop = map (drop 3) . traverse parsePositive ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
msgid ""
"Since the argument of `traverse parsePositive` is of type `Vect (3 + n) "
"String`, its result will be of type `Maybe (Vect (3 + n) Nat)`. It is "
"therefore safe to use this in a call to `drop 3`. Note, how all of this is "
"known at compile time: We encoded the prerequisite that the first argument "
"is a vector of at least three elements in the length index and could derive "
"the length of the result from this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:62
msgid "### Vectors of Unknown Length"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
msgid ""
"However, this is not always possible. Consider the following function, "
"defined on `List` and exported by `Data.List`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:70
msgid ""
"```repl Tutorial.Relations> :t takeWhile Data.List.takeWhile : (a -> Bool) -"
"> List a -> List a ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
msgid ""
"This will take the longest prefix of the list argument, for which the given "
"predicate returns `True`. In this case, it depends on the list elements and "
"the predicate, how long this prefix will be.  Can we write such a function "
"for vectors? Let's give it a try:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:79
msgid "```idris takeWhile' : (a -> Bool) -> Vect n a -> Vect m a ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not be "
"able to do so in a provably total way. The question is: What is the problem "
"here? In order to understand this, we have to realize what the type of "
"`takeWhile'` promises: \"For all predicates operating on values on type `a`, "
"and for all vectors holding values of this type, and for all lengths `m`, I "
"give you a vector of length `m` holding values of type `a`\".  All three "
"arguments are said to be [*universally quantified*](https://en.wikipedia.org/"
"wiki/Universal_quantification): The caller of our function is free to choose "
"the predicate, the input vector, the type of values the vector holds, and "
"*the length of the output vector*. Don't believe me? See here:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:97
msgid ""
"```idris -- This looks like trouble: We got a non-empty vector of `Void`...  "
"voids : Vect 7 Void voids = takeWhile' (const True) []"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:102
msgid ""
"-- ...from which immediately follows a proof of `Void` proofOfVoid : Void "
"proofOfVoid = head voids ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
msgid ""
"See how I could freely decide on the value of `m` when invoking "
"`takeWhile'`? Although I passed `takeWhile'` an empty vector (the only "
"existing vector holding values of type `Void`), the function's type promises "
"me to return a possibly non-empty vector holding values of the same type, "
"from which I freely extracted the first one."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to implement "
"`takeWhile'` without cheating (for instance, by turning totality checking "
"off and looping forever).  So, the question remains, how to express the "
"result of `takeWhile'` in a type. The answer to this is: \"Use a *dependent "
"pair*\", a vector paired with a value corresponding to its length."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:122
#, no-wrap
msgid ""
"```idris\n"
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
msgid ""
"This corresponds to [*existential quantification*](https://en.wikipedia.org/"
"wiki/Existential_quantification)  in predicate logic: There is a natural "
"number, which corresponds to the length of the vector I have here. Note, how "
"from the outside of `AnyVect a`, the length of the wrapped vector is no "
"longer visible at the type level but we can still inspect it and learn "
"something about it at runtime, since it is wrapped up together with the "
"actual vector. We can implement `takeWhile` in such a way that it returns a "
"value of type `AnyVect a`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:139
#, no-wrap
msgid ""
"```idris\n"
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
msgid ""
"This works in a provably total way, because callers of this function can no "
"longer choose the length of the resulting vector themselves. Our function, "
"`takeWhile`, decides on this length and returns it together with the vector, "
"and the type checker verifies that we make no mistakes when pairing the two "
"values. In fact, the length can be inferred automatically by Idris, so we "
"can replace it with underscores, if we so desire:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:155
#, no-wrap
msgid ""
"```idris\n"
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
msgid ""
"To summarize: Parameters in generic function types are universally "
"quantified, and their values can be decided on at the call site of such "
"functions. Dependent record types allow us to describe existentially "
"quantified values. Callers cannot choose such values freely: They are "
"returned as part of a function's result."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.  "
"The type of `takeWhile'` can also be written like so:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:168
msgid ""
"```idris takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a "
"```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
msgid ""
"Universally quantified arguments are desugared to implicit erased arguments "
"by Idris. The above is a less verbose version of the following function "
"type, the likes of which we have seen before:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:182
#, no-wrap
msgid ""
"```idris\n"
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
msgid ""
"In Idris, we are free to choose whether we want to be explicit about "
"universal quantification. Sometimes it can help understanding what's going "
"on at the type level. Other languages - for instance [PureScript](https://"
"www.purescript.org/) - are more strict about this: There, explicit "
"annotations on universally quantified parameters are [mandatory](https://"
"github.com/purescript/documentation/blob/master/language/Differences-from-"
"Haskell.md#explicit-forall)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:191
msgid "### The Essence of Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
msgid ""
"It can take some time and experience to understand what's going on here. At "
"least in my case, it took many sessions programming in Idris, before I "
"figured out what dependent pairs are about: They pair a *value* of some type "
"with a second value of a type calculated from the first value.  For "
"instance, a natural number `n` (the value)  paired with a vector of length "
"`n` (the second value, the type of which *depends* on the first value).  "
"This is such a fundamental concept of programming with dependent types, that "
"a general dependent pair type is provided by the *Prelude*. Here is its "
"implementation (primed for disambiguation):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:209
#, no-wrap
msgid ""
"```idris\n"
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
msgid ""
"It is essential to understand what's going on here. There are two "
"parameters: A type `a`, and a function `p`, calculating a *type* from a "
"*value* of type `a`. Such a value (`fst`) is then used to calculate the "
"*type* of the second value (`snd`).  For instance, here is `AnyVect a` "
"represented as a `DPair`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:220
msgid ""
"```idris AnyVect' : (a : Type) -> Type AnyVect' a = DPair Nat (\\n => Vect n "
"a)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.  Idris "
"provides special syntax for describing dependent pairs, as they are "
"important building blocks for programming in languages with first class "
"types:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:230
msgid ""
"```idris AnyVect'' : (a : Type) -> Type AnyVect'' a = (n : Nat ** Vect n a)  "
"```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''` get's "
"desugared to the right hand side of `AnyVect'`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:238
msgid ""
"```repl Tutorial.Relations> (n : Nat ** Vect n Int)  DPair Nat (\\n => Vect "
"n Int)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop this "
"information. (We still need to put the whole expression in parentheses.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:247
msgid ""
"```idris AnyVect3 : (a : Type) -> Type AnyVect3 a = (n ** Vect n a)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
msgid ""
"This allows us to pair a natural number `n` with a vector of length `n`, "
"which is exactly what we did with `AnyVect`. We can therefore rewrite "
"`takeWhile` to return a `DPair` instead of our custom type `AnyVect`. Note, "
"that like with regular pairs, we can use the same syntax `(x ** y)` for "
"creating and pattern matching on dependent pairs:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:262
#, no-wrap
msgid ""
"```idris\n"
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
msgid ""
"Just like with regular pairs, we can use the dependent pair syntax to define "
"dependent triples and larger tuples:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:270
msgid ""
"```idris AnyMatrix : (a : Type) -> Type AnyMatrix a = (m ** n ** Vect m "
"(Vect n a))  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:272
msgid "### Erased Existentials"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
msgid ""
"Sometimes, it is possible to determine the value of an index by pattern "
"matching on a value of the indexed type.  For instance, by pattern matching "
"on a vector, we can learn about its length index. In these cases, it is not "
"strictly necessary to carry around the index at runtime, and we can write a "
"special version of a dependent pair where the first argument has quantity "
"zero. Module `Data.DPair` from *base* exports data type `Exists` for this "
"use case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
msgid ""
"As an example, here is a version of `takeWhile` returning a value of type "
"`Exists`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:293
#, no-wrap
msgid ""
"```idris\n"
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
msgid ""
"In order to restore an erased value, data type `Singleton` from *base* "
"module `Data.Singleton` can be useful: It is parameterized by the *value* it "
"stores:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:302
msgid "```idris true : Singleton True true = Val True ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
msgid ""
"This is called a *singleton* type: A type corresponding to exactly one "
"value. It is a type error to return any other value for constant `true`, and "
"Idris knows this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:311
msgid "```idris true' : Singleton True true' = Val _ ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
msgid ""
"We can use this to conjure the (erased!) length of a vector out of thin air:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:320
#, no-wrap
msgid ""
"```idris\n"
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
msgid ""
"This function comes with much stronger guarantees than `Data.Vect.length`: "
"The latter claims to just return *any* natural number, while `vectLength` "
"*must* return exactly `n` in order to type check. As a demonstration, here "
"is a well-typed bogus implementation of `length`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:331
msgid "```idris bogusLength : Vect n a -> Nat bogusLength = const 0 ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
msgid ""
"This would not be accepted as a valid implementation of `vectLength`, as you "
"may quickly verify yourself."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)  we can "
"convert an erased existential to a proper dependent pair:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:343
msgid ""
"```idris toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)  toDPair "
"(Evidence _ as) = let Val m = vectLength as in (m ** as)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms of `length`, "
"and note how Idris will fail to unify the result of `length` with the actual "
"length of the vector."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
msgid ""
"Declare and implement a function for filtering a vector similar to `Data."
"List.filter`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
msgid ""
"Declare and implement a function for mapping a partial function over the "
"values of a vector similar to `Data.List.mapMaybe`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
msgid ""
"Declare and implement a function similar to `Data.List.dropWhile` for "
"vectors. Use `Data.DPair.Exists` as your return type."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use the function from "
"exercise 3 in your implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:365
msgid "## Use Case: Nucleic Acids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
msgid ""
"We'd like to come up with a small, simplified library for running "
"computations on nucleic acids: RNA and DNA. These are built from five types "
"of nucleobases, three of which are used in both types of nucleic acids and "
"two bases specific for each type of acid. We'd like to make sure that only "
"valid bases are in strands of nucleic acids.  Here's a possible encoding:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:375
msgid "```idris data BaseType = DNABase | RNABase"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:382
#, no-wrap
msgid ""
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:385
msgid "NucleicAcid : BaseType -> Type NucleicAcid = List . Nucleobase"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:388
msgid "RNA : Type RNA = NucleicAcid RNABase"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:391
msgid "DNA : Type DNA = NucleicAcid DNABase"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:398
msgid ""
"encodeBase : Nucleobase b -> Char encodeBase Adenine = 'A' encodeBase "
"Cytosine = 'C' encodeBase Guanine = 'G' encodeBase Thymine = 'T' encodeBase "
"Uracile = 'U'"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:402
msgid "encode : NucleicAcid b -> String encode = pack . map encodeBase ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
msgid "It is a type error to use `Uracile` in a strand of DNA:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:410
#, no-wrap
msgid ""
"```idris\n"
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and "
"`Guanine`: These are again universally quantified, and client code is free "
"to choose a value here. This allows us to use these bases in strands of DNA "
"*and* RNA:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:419
msgid "```idris dna1 : DNA dna1 = [Adenine, Cytosine, Guanine]"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:423
msgid "rna1 : RNA rna1 = [Adenine, Cytosine, Guanine] ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only "
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.  "
"Let's write parsers for strands of DNA and RNA:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:434
#, no-wrap
msgid ""
"```idris\n"
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:438
#, no-wrap
msgid ""
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:442
#, no-wrap
msgid ""
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:445
msgid "readRNA : String -> Maybe RNA readRNA = traverse readRNABase . unpack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:449
msgid ""
"readDNA : String -> Maybe DNA readDNA = traverse readDNABase . unpack ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
msgid ""
"Again, in case of the bases appearing in both kinds of strands, users of the "
"universally quantified `readAnyBase` are free to choose what base type they "
"want, but they will never get a `Thymine` or `Uracile` value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
msgid ""
"We can now implement some simple calculations on sequences of nucleobases. "
"For instance, we can come up with the complementary strand:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:467
#, no-wrap
msgid ""
"```idris\n"
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:476
#, no-wrap
msgid ""
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were dozens of "
"bases with only few specialized ones. Surely, we can do better? "
"Unfortunately, the following won't work:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:489
msgid ""
"```idris complementBase' : Nucleobase b -> Nucleobase b complementBase' "
"Adenine = ?what_now complementBase' Cytosine = Guanine complementBase' "
"Guanine = Cytosine complementBase' Thymine = Adenine complementBase' Uracile "
"= Adenine ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
msgid ""
"All goes well with the exception of the `Adenine` case. Remember: Parameter "
"`b` is universally quantified, and the *callers* of our function can decide "
"what `b` is supposed to be. We therefore can't just return `Thymine`: Idris "
"will respond with a type error since callers might want a `Nucleobase "
"RNABase` instead.  One way to go about this is to take an additional "
"unerased argument (explicit or implicit) representing the base type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:507
#, no-wrap
msgid ""
"```idris\n"
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
msgid ""
"This is again an example of a dependent *function* type (also called a [*pi "
"type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)): The input "
"and output types both *depend* on the *value* of the first argument.  We can "
"now use this to calculate the complement of any nucleic acid:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:517
msgid ""
"```idris complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b "
"complement b = map (complementBase b)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence of "
"nucleobases from user input, accepting two strings: The first telling us, "
"whether the user plans to enter a DNA or RNA sequence, the second being the "
"sequence itself. What should be the type of such a function? Well, we're "
"describing computations with side effects, so something involving `IO` seems "
"about right. User input almost always needs to be validated or translated, "
"so something might go wrong and we need an error type for this case. "
"Finally, our users can decide whether they want to enter a strand of RNA or "
"DNA, so this distinction should be encoded as well."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
msgid ""
"Of course, it is always possible to write a custom sum type for such a use "
"case:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:539
#, no-wrap
msgid ""
"```idris\n"
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
msgid ""
"This has all possible outcomes encoded in a single data type.  However, it "
"is lacking in terms of flexibility. If we want to handle errors early on and "
"just extract a strand of RNA or DNA, we need yet another data type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:548
msgid "```idris data RNAOrDNA = ItsRNA RNA | ItsDNA DNA ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
msgid ""
"This might be the way to go, but for results with many options, this can get "
"cumbersome quickly. Also: Why come up with a custom data type when we "
"already have the tools to deal with this at our hands?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
msgid "Here is how we can encode this with a dependent pair:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:561
#, no-wrap
msgid ""
"```idris\n"
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:568
#, no-wrap
msgid ""
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:577
#, no-wrap
msgid ""
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid sequence. "
"Assume now we implement a function for transcribing a strand of DNA to RNA, "
"and we'd like to convert a sequence of nucleobases from user input to the "
"corresponding RNA sequence.  Here's how to do this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:590
msgid ""
"```idris transcribeBase : Nucleobase DNABase -> Nucleobase RNABase "
"transcribeBase Adenine = Uracile transcribeBase Cytosine = Guanine "
"transcribeBase Guanine = Cytosine transcribeBase Thymine = Adenine"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:593
msgid "transcribe : DNA -> RNA transcribe = map transcribeBase"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:596
msgid "printRNA : RNA -> IO ()  printRNA = putStrLn . encode"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:606
#, no-wrap
msgid ""
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
msgid ""
"By pattern matching on the first value of the dependent pair we could "
"determine, whether the second value is an RNA or DNA sequence.  In the first "
"case, we had to transcribe the sequence first, in the second case, we could "
"invoke `printRNA` directly."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence to the "
"corresponding protein sequence. Still, this example shows how to deal with a "
"simplified real world scenario: Data may be encoded differently and coming "
"from different sources. By using precise types, we are forced to first "
"convert values to the correct format. Failing to do so leads to a compile "
"time exception instead of an error at runtime or - even worse - the program "
"silently running a bogus computation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:622
msgid "### Dependent Records vs Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization of dependent "
"pairs: We can have an arbitrary number of fields and use the values stored "
"therein to calculate the types of other values. For very simple cases like "
"the example with nucleobases, it doesn't matter too much, whether we use a "
"`DPair`, a custom dependent record, or even a sum type. In fact, the three "
"encodings are equally expressive:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:634
msgid "```idris Acid1 : Type Acid1 = (b ** NucleicAcid b)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:639
#, no-wrap
msgid ""
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:644
#, no-wrap
msgid ""
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
msgid ""
"It is trivial to write lossless conversions between these encodings, and "
"with each encoding we can decide with a simple pattern match, whether we "
"currently have a sequence of RNA or DNA. However, dependent types can depend "
"on more than one value, as we will see in the exercises. In such cases, sum "
"types and dependent pairs quickly become unwieldy, and you should go for an "
"encoding as a dependent record."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
msgid ""
"Sharpen your skills in using dependent pairs and dependent records! In "
"exercises 2 to 7 you have to decide yourself, when a function should return "
"a dependent pair or record, when a function requires additional arguments, "
"on which you can pattern match, and what other utility functions might be "
"necessary."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic* (meaning: of "
"the same structure) by writing lossless conversion functions from `Acid1` to "
"`Acid2` and back. Likewise for `Acid1` and `Acid3`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
msgid ""
"Sequences of nucleobases can be encoded in one of two directions: [*Sense* "
"and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).  "
"Declare a new data type to describe the sense of a sequence of nucleobases, "
"and add this as an additional parameter to type `Nucleobase` and types `DNA` "
"and `RNA`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
msgid ""
"Refine the types of `complement` and `transcribe`, so that they reflect the "
"changing of *sense*. In case of `transcribe`, a strand of antisense DNA is "
"converted to a strand of sense RNA."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
msgid ""
"Define a dependent record storing the base type and sense together with a "
"sequence of nucleobases."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that the *sense* of a sequence "
"is read from the input string.  Sense strands are encoded like so: \"5-"
"CGGTAG-3\". Antisense strands are encoded like so: \"3-CGGTAG-5\"."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
msgid "Adjust `encode` in such a way that it includes the sense in its output."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that the sense "
"and base type are stored together with the sequence, and that "
"`transcribeProg` always prints the *sense* RNA strand (after transcription, "
"if necessary)."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
msgid "Enjoy the fruits of your labour and test your program at the REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
msgid ""
"Note: Instead of using a dependent record, we could again have used a sum "
"type of four constructors to encode the different types of sequences. "
"However, the number of constructors required corresponds to the *product* of "
"the number of values of each type level index. Therefore, this number can "
"grow quickly and sum type encodings can lead to lengthy blocks of pattern "
"matches in these cases."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:705
msgid "## Use Case: CSV Files with a Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
msgid ""
"In this section, we are going to look at an extended example based on our "
"previous work on CSV parsers. We'd like to write a small command-line "
"program, where users can specify a schema for the CSV tables they'd like to "
"parse and load into memory. Before we begin, here is a REPL session running "
"the final program, which you will complete in the exercises:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:719
msgid ""
"```repl Solutions.DPair> :exec main Enter a command: load resources/example "
"Table loaded. Schema: str,str,fin2023,str?,boolean? Enter a command: get 3 "
"Row 3:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:721
#, no-wrap
msgid ""
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:723
#, no-wrap
msgid "Floor | Jansen | 1981    |      | t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:726
msgid "Enter a command: add Mikael,Stanne,1974,, Row prepended:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:728 ../src/Tutorial/DPair.md:735
#, no-wrap
msgid ""
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:730 ../src/Tutorial/DPair.md:737
#, no-wrap
msgid "Mikael | Stanne | 1974    |      |\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:733
msgid "Enter a command: get 1 Row 1:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:742
msgid ""
"Enter a command: delete 1 Deleted row: 1.  Enter a command: get 1 Row 1:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:744
#, no-wrap
msgid ""
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:746
#, no-wrap
msgid "Rob | Halford | 1951    |      |\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:750 ../src/Tutorial/Predicates.md:1357
msgid "Enter a command: quit Goodbye.  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
msgid ""
"This example was inspired by a similar program used as an example in the "
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)  book."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
msgid "We'd like to focus on several things here:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Purity: With the exception of the main program loop, all functions used in "
"the implementation should be pure, which in this context means \"not running "
"in any monad with side effects such as `IO`\"."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Fail early: With the exception of the command parser, all functions updating "
"the table and handling queries should be typed and implemented in such a way "
"that they cannot fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
msgid ""
"We are often well advised to adhere to these two guidelines, as they can "
"make the majority of our functions easier to implement and test."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
msgid ""
"Since we allow users of our library to specify a schema (order and types of "
"columns) for the table they work with, this information is not known until "
"runtime. The same goes for the current size of the table. We will therefore "
"store both values as fields in a dependent record."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:774
msgid "### Encoding the Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
msgid ""
"We need to inspect the table schema at runtime. Although theoretically "
"possible, it is not advisable to operate on Idris types directly here.  We'd "
"rather use a closed custom data type describing the types of columns we "
"understand. In a first try, we only support some Idris primitives:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:783 ../src/Tutorial/Eq.md:29
#: ../src/Tutorial/Predicates.md:495
msgid "```idris data ColType = I64 | Str | Boolean | Float"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:787
msgid "Schema : Type Schema = List ColType ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris types, which we "
"will then use as the index of a heterogeneous list representing the rows in "
"our table:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:798
#, no-wrap
msgid ""
"```idris\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:802
msgid "Row : Schema -> Type Row = HList . map IdrisType ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
msgid ""
"We can now describe a table as a dependent record storing the table's "
"content as a vector of rows. In order to safely index rows of the table and "
"parse new rows to be added, the current schema and size of the table must be "
"known at runtime:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:815
#, no-wrap
msgid ""
"```idris\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
msgid ""
"Finally, we define an indexed data type describing commands operating on the "
"current table. Using the current table as the command's index allows us to "
"make sure that indices for accessing and deleting rows are within bounds and "
"that new rows agree with the current schema. This is necessary to uphold our "
"second design principle: All functions operating on tables must do so "
"without the possibility of failure."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:834
#, no-wrap
msgid ""
"```idris\n"
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
msgid ""
"We can now implement the main application logic: How user entered commands "
"affect the application's current state. As promised, this comes without the "
"risk of failure, so we don't have to wrap the return type in an `Either`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:852
#, no-wrap
msgid ""
"```idris\n"
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
msgid ""
"Please understand, that the constructors of `Command t` are typed in such a "
"way that indices are always within bounds (constructors `Get` and `Delete`), "
"and new rows adhere to the table's current schema (constructor `Prepend`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
msgid ""
"One thing you might not have seen so far is the call to `absurd` on the last "
"line. This is a derived function of the `Uninhabited` interface, which is "
"used to describe types such as `Void` or - in the case above - `Fin 0`, of "
"which there can be no value. Function `absurd` is then just another "
"manifestation of the principle of explosion. If this doesn't make too much "
"sense yet, don't worry. We will look at `Void` and its uses in the next "
"chapter."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:868
msgid "### Parsing Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
msgid ""
"User input validation is an important topic when writing applications. If it "
"happens early, you can keep larger parts of your application pure (which - "
"in this context - means: \"without the possibility of failure\") and "
"provably total.  If done properly, this step encodes and handles most if not "
"all ways in which things can go wrong in your program, allowing you to come "
"up with clear error messages telling users exactly what caused an issue. As "
"you surely have experienced yourself, there are few things more frustrating "
"than a non-trivial computer program terminating with an unhelpful \"There "
"was an error\" message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
msgid ""
"So, in order to treat this important topic with all due respect, we are "
"first going to implement a custom error type. This is not *strictly* "
"necessary for small programs, but once your software gets more complex, it "
"can be tremendously helpful for keeping track of what can go wrong where. In "
"order to figure out what can possibly go wrong, we first need to decide on "
"how the commands should be entered.  Here, we use a single keyword for each "
"command, together with an optional number of arguments separated from the "
"keyword by a single space character. For instance: `\"new i64,boolean,str,str"
"\"`, for initializing an empty table with a new schema. With this settled, "
"here is a list of things that can go wrong, and the messages we'd like to "
"print:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A bogus command is entered. We repeat the input with a message that we don't "
"know the command plus a list of commands we know about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid schema was entered. In this case, we list the position of the "
"first unknown type, the string we found there, and a list of types we know "
"about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous "
"position, the string encountered there, plus the expected type. In case of a "
"too small or too large number of fields, we also print a corresponding error "
"message."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An index was out of bounds. This can happen, when users try to access or "
"delete specific rows. We print the current number of rows plus the value "
"entered."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A value not representing a natural number was entered as an index.  We print "
"an according error message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
msgid ""
"That's a lot of stuff to keep track off, so let's encode this in a sum type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:921
#, no-wrap
msgid ""
"```idris\n"
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
msgid ""
"In order to conveniently construct our error messages, it is best to use "
"Idris' string interpolation facilities: We can enclose arbitrary string "
"expressions in a string literal by enclosing them in curly braces, the first "
"of which must be escaped with a backslash. Like so: `\"foo \\{myExpr a b "
"c}\"`.  We can pair this with multiline string literals to get nicely "
"formatted error messages."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:936 ../src/Tutorial/Eq.md:460
#, no-wrap
msgid ""
"```idris\n"
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:939
msgid ""
"showSchema : Schema -> String showSchema = concat . intersperse \",\" . map "
"showColType"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:945
#, no-wrap
msgid ""
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:951
#, no-wrap
msgid ""
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:956
#, no-wrap
msgid ""
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:962
#, no-wrap
msgid ""
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:968
#, no-wrap
msgid ""
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:974
#, no-wrap
msgid ""
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:981
#, no-wrap
msgid ""
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:984
msgid "showError (NoNat x) = \"Not a natural number: \\{x}\" ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
msgid ""
"We can now write parsers for the different commands. We need facilities to "
"parse vector indices, schemata, and CSV rows.  Since we are using a CSV "
"format for encoding and decoding rows, it makes sense to also encode the "
"schema as a comma-separated list of values:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:996
#, no-wrap
msgid ""
"```idris\n"
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:999
msgid "fromCSV : String -> List String fromCSV = forget . split (',' ==)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1006
#, no-wrap
msgid ""
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1010
msgid ""
"readSchema : String -> Either Error Schema readSchema = traverse (uncurry "
"readColType) . zipWithIndex . fromCSV ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
msgid ""
"We also need to decode CSV content based on the current schema.  Note, how "
"we can do so in a type safe manner by pattern matching on the schema, which "
"will not be known until runtime. Unfortunately, we need to reimplement CSV-"
"parsing, because we want to add the expected type to the error messages (a "
"thing that would be much harder to do with interface `CSVLine` and error "
"type `CSVError`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1028
#, no-wrap
msgid ""
"```idris\n"
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1037
#, no-wrap
msgid ""
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
msgid ""
"There is no hard and fast rule about whether to pass an index as an implicit "
"argument or not. Some considerations:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Pattern matching on explicit arguments comes with less syntactic overhead."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"If an argument can be inferred from the context most of the time, consider "
"passing it as an implicit to make your function nicer to use in client code."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Use explicit (possibly erased) arguments for values that can't be inferred "
"by Idris most of the time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
msgid ""
"All that is missing now is a way to parse indices for accessing the current "
"table's rows. We use the conversion for indices to start at one instead of "
"zero, which feels more natural for most non-programmers."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1060
#, no-wrap
msgid ""
"```idris\n"
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
msgid ""
"We are finally able to implement a parser for user commands.  Function `Data."
"String.words` is used for splitting a string at space characters. In most "
"cases, we expect the name of the command plus a single argument without "
"additional spaces.  CSV rows can have additional space characters, however, "
"so we use `Data.String.unwords` on the split string."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1080
#, no-wrap
msgid ""
"```idris\n"
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1082
msgid "### Running the Application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
msgid ""
"All that's left to do is to write functions for printing the results of "
"commands to users and run the application in a loop until command `\"quit\"` "
"is entered."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1095 ../src/Tutorial/Predicates.md:1294
#, no-wrap
msgid ""
"```idris\n"
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1101
#, no-wrap
msgid ""
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1111
#, no-wrap
msgid ""
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1122
#, no-wrap
msgid ""
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1127 ../src/Tutorial/Predicates.md:1334
msgid "covering main : IO ()  main = runProg $ MkTable [] _ [] ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
msgid ""
"The challenges presented here all deal with enhancing our table editor in "
"several interesting ways. Some of them are more a matter of style and less a "
"matter of learning to write dependently typed programs, so feel free to "
"solve these as you please. Exercises 1 to 3 should be considered to be "
"mandatory."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
msgid "Add support for storing Idris types `Integer` and `Nat` in CSV columns"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need runtime access to `n` "
"in order for this to work."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
msgid ""
"Add support for optional types to CSV columns. Since missing values should "
"be encoded by empty strings, it makes no sense to allow for nested optional "
"types, meaning that types like `Maybe Nat` should be allowed while `Maybe "
"(Maybe Nat)` should not."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
msgid ""
"Add a command for printing the whole table. Bonus points if all columns are "
"properly aligned."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
msgid ""
"Add support for simple queries: Given a column number and a value, list all "
"rows where entries match the given value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
msgid ""
"Add support for loading and saving tables from and to disk.  A table should "
"be stored in two files: One for the schema and one for the CSV content."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
msgid ""
"You can find an implementation of these additions in the solutions. A small "
"example table can be found in folder `resources`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
msgid ""
"Note: There are of course tons of projects to pursue from here, such as "
"writing a proper query language, calculating new rows from existing ones, "
"accumulating values in a column, concatenating and zipping tables, and so "
"on.  We will stop for now, probably coming back to this in later examples."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
msgid ""
"Dependent pairs and records are necessary to at runtime inspect the values "
"defining the types we work with. By pattern matching on these values, we "
"learn about the types and possible shapes of other values, allowing us to "
"reduce the number of potential bugs in our programs."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
msgid ""
"In the [next chapter](Eq.md) we start learning about how to write data "
"types, which we use as proofs that certain contracts between values hold. "
"These will eventually allow us to define pre- and post conditions for our "
"function arguments and output types."
msgstr ""
