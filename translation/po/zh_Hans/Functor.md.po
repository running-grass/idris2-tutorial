# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-02 13:19+0800\n"
"PO-Revision-Date: 2022-08-02 14:09+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2-tutorial/functor/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:262 ../src/Tutorial/Dependent.md:445
#: ../src/Tutorial/DPair.md:349 ../src/Tutorial/Eq.md:280
#: ../src/Tutorial/Folds.md:374 ../src/Tutorial/Functor.md:382
#: ../src/Tutorial/Interfaces.md:190 ../src/Tutorial/IO.md:318
#: ../src/Tutorial/Predicates.md:306 ../src/Tutorial/Prim.md:449
#: ../src/Tutorial/Traverse.md:248
#, fuzzy
msgid "### Exercises part 1"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 1 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:437 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:654 ../src/Tutorial/Eq.md:556
#: ../src/Tutorial/Folds.md:669 ../src/Tutorial/Functor.md:963
#: ../src/Tutorial/Interfaces.md:353 ../src/Tutorial/IO.md:729
#: ../src/Tutorial/Predicates.md:673 ../src/Tutorial/Prim.md:713
#: ../src/Tutorial/Traverse.md:575
#, fuzzy
msgid "### Exercises part 2"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 2 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:743 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1129 ../src/Tutorial/Eq.md:827
#: ../src/Tutorial/Folds.md:989 ../src/Tutorial/Functor.md:1233
#: ../src/Tutorial/Interfaces.md:625 ../src/Tutorial/IO.md:950
#: ../src/Tutorial/Predicates.md:1021 ../src/Tutorial/Prim.md:937
#: ../src/Tutorial/Traverse.md:1017
#, fuzzy
msgid "### Exercises part 3"
msgstr ""
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"### 练习第 3 部分\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1320 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1192 ../src/Tutorial/Eq.md:1086
#: ../src/Tutorial/Folds.md:1052 ../src/Tutorial/Functions1.md:525
#: ../src/Tutorial/Functions2.md:925 ../src/Tutorial/Functor.md:1396
#: ../src/Tutorial/Interfaces.md:793 ../src/Tutorial/IO.md:1096
#: ../src/Tutorial/Predicates.md:1359 ../src/Tutorial/Traverse.md:1110
#, fuzzy
msgid "## Conclusion"
msgstr ""
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Functions1.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, fuzzy
msgid "<!-- vi: filetype=idris2 -->"
msgstr ""
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Functions1.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:15 ../src/Tutorial/DPair.md:37
#: ../src/Tutorial/Eq.md:20 ../src/Tutorial/Folds.md:33
#: ../src/Tutorial/Functions2.md:21 ../src/Tutorial/Functor.md:27
#: ../src/Tutorial/IO.md:19 ../src/Tutorial/Predicates.md:28
#: ../src/Tutorial/Prim.md:16 ../src/Tutorial/Traverse.md:30
#, fuzzy
msgid "%default total ```"
msgstr ""
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```"

#. type: Plain text
#: ../src/Tutorial/Eq.md:849 ../src/Tutorial/Folds.md:1003
#: ../src/Tutorial/Functor.md:424 ../src/Tutorial/Traverse.md:292
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
"   ```\n"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"   ```伊德里斯\n"
"   数据 Crud : (i : Type) -> (a : Type) -> Type where\n"
"     创建：（值：a）-> Crud i a\n"
"     更新：（id：i）->（value：a）-> Crud i a\n"
"     阅读：（id：i）-> Crud i a\n"
"     删除 : (id : i) -> Crud i a\n"
"   ```\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"   ```伊德里斯\n"
"   数据 Crud : (i : Type) -> (a : Type) -> Type where\n"
"     创建：（值：a）-> Crud i a\n"
"     更新：（id：i）->（value：a）-> Crud i a\n"
"     阅读：（id：i）-> Crud i a\n"
"     删除 : (id : i) -> Crud i a\n"
"   ```\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1014 ../src/Tutorial/Functor.md:437
#: ../src/Tutorial/Traverse.md:303
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
"   ```\n"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"   ```伊德里斯\n"
"   数据响应：（e，i，a：Type）-> Type where\n"
"     创建 : (id : i) -> (value : a) -> 响应 e i a\n"
"     更新：（id：i）->（值：a）->响应 e i a\n"
"     找到：（值：列表 a）-> 响应 e i a\n"
"     已删除 : (id : i) -> 响应 e i a\n"
"     错误 : (err : e) -> 响应 e i a\n"
"   ```\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:177 ../src/Tutorial/Functor.md:632
#, fuzzy, no-wrap
msgid ""
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"记录电子邮件在哪里\n"
"  构造函数 MkEmail\n"
"  值：字符串\n"
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:181 ../src/Tutorial/Functor.md:636
#: ../src/Tutorial/Interfaces.md:542
#, fuzzy, no-wrap
msgid ""
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"记录密码在哪里\n"
"  构造函数 MkPassword\n"
"  值：字符串\n"
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:2
#, fuzzy
msgid "# Functor and Friends"
msgstr "# 函子和朋友"

#. type: Plain text
#: ../src/Tutorial/Functor.md:6
#, fuzzy
msgid ""
"Programming, like mathematics, is about abstraction. We try to model parts "
"of the real world, reusing recurring patterns by abstracting over them."
msgstr ""
"编程，就像数学一样，是关于抽象的。我们尝试对现实世界的某些部分进行建模，通过"
"对它们进行抽象来重用重复出现的模式。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:17
#, fuzzy
msgid ""
"In this chapter, we will learn about several related interfaces, which are "
"all about abstraction and therefore can be hard to understand at the "
"beginning. Especially figuring out *why* they are useful and *when* to use "
"them will take time and experience. This chapter therefore comes with tons "
"of exercises, most of which can be solved with only a few short lines of "
"code. Don't skip them.  Come back to them several times until these things "
"start feeling natural to you. You will then realize that their initial "
"complexity has vanished."
msgstr ""
"在本章中，我们将学习几个相关的接口，它们都是关于抽象的，因此一开始可能很难理"
"解。尤其是弄清楚 *为什么* 有用以及 *何时* 使用它们需要时间和经验。因此，本章"
"包含大量练习，其中大部分练习只需几行代码即可解决。不要跳过它们。回到他们身边"
"几次，直到这些事情开始对你来说很自然。然后你会意识到它们最初的复杂性已经消失"
"了。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:20
#, fuzzy
msgid "```idris module Tutorial.Functor"
msgstr "```idris 模块 Tutorial.Functor"

#. type: Plain text
#: ../src/Tutorial/Functor.md:24 ../src/Tutorial/IO.md:14
#, fuzzy
msgid "import Data.List1 import Data.String import Data.Vect"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"导入 Data.List1 导入 Data.String 导入 Data.Vect\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:29
#, fuzzy
msgid "## Functor"
msgstr "## 函子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:42
#, fuzzy
msgid ""
"What do type constructors like `List`, `List1`, `Maybe`, or `IO` have in "
"common? First, all of them are of type `Type -> Type`. Second, they all put "
"values of a given type in a certain *context*. With `List`, the *context* is "
"*non-determinism*: We know there to be zero or more values, but we don't "
"know the exact number until we start taking the list apart by pattern "
"matching on it. Likewise for `List1`, though we know for sure that there is "
"at least one value. For `Maybe`, we are still not sure about how many values "
"there are, but the possibilities are much smaller: Zero or one. With `IO`, "
"the context is a different one: Arbitrary side effects."
msgstr ""
"`List`、`List1`、`Maybe` 或 `IO` 等类型构造函数有什么共同点？首先，它们都是类"
"型 `Type -> Type`。其次，它们都将给定类型的值放在某个 * 上下文 * 中。对于 "
"`List`，*context* 是 *non-determinism*：我们知道有零个或多个值，但在开始之前"
"我们不知道确切的数字通过对其进行模式匹配将列表分开。对于 `List1` 也是如此，尽"
"管我们确定至少有一个值。对于 `Maybe`，我们仍然不确定有多少个值，但可能性要小"
"得多：零或一。使用 `IO`，上下文是不同的：任意副作用。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:49
#, fuzzy
msgid ""
"Although the type constructors discussed above are quite different in how "
"they behave and when they are useful, there are certain operations that keep "
"coming up when working with them. The first such operation is *mapping a "
"pure function over the data type, without affecting its underlying "
"structure*."
msgstr ""
"尽管上面讨论的类型构造函数在它们的行为方式和何时有用方面有很大不同，但在使用"
"它们时会不断出现某些操作。第一个这样的操作是*在数据类型上映射一个纯函数，而不"
"影响其底层结构*。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:53
#, fuzzy
msgid ""
"For instance, given a list of numbers, we'd like to multiply each number by "
"two, without changing their order or removing any values:"
msgstr ""
"例如，给定一个数字列表，我们希望将每个数字乘以 2，而不更改它们的顺序或删除任"
"何值："

#. type: Plain text
#: ../src/Tutorial/Functor.md:59
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"multBy2List : Num a => List a -> List a\n"
"multBy2List [] = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:62
#, fuzzy
msgid ""
"But we might just as well convert every string in a list of strings to upper "
"case characters:"
msgstr "但是我们也可以将字符串列表中的每个字符串都转换为大写字符："

#. type: Plain text
#: ../src/Tutorial/Functor.md:68
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"toUpperList : 列表字符串 -> 列表字符串\n"
"toUpperList [] = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:72
#, fuzzy
msgid ""
"Sometimes, the type of the stored value changes. In the next example, we "
"calculate the lengths of the strings stored in a list:"
msgstr ""
"有时，存储值的类型会发生变化。在下一个示例中，我们计算存储在列表中的字符串的"
"长度："

#. type: Plain text
#: ../src/Tutorial/Functor.md:78
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"toLengthList : 列表字符串 -> 列表 Nat\n"
"toLengthList [] = []\n"
"toLengthList (x :: xs) = 长度 x :: toLengthList xs\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:83
#, fuzzy
msgid ""
"I'd like you to appreciate, just how boring these functions are. They are "
"almost identical, with the only interesting part being the function we apply "
"to each element. Surely, there must be a pattern to abstract over:"
msgstr ""
"我希望你能体会到，这些功能是多么无聊。它们几乎相同，唯一有趣的部分是我们应用"
"于每个元素的函数。当然，必须有一个抽象的模式："

#. type: Plain text
#: ../src/Tutorial/Functor.md:89
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"mapList : (a -> b) -> 列表 a -> 列表 b\n"
"地图列表 f [] = []\n"
"地图列表 f (x :: xs) = f x :: 地图列表 f xs\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:94
#, fuzzy
msgid ""
"This is often the first step of abstraction in functional programming: Write "
"a (possibly generic) higher-order function.  We can now concisely implement "
"all examples shown above in terms of `mapList`:"
msgstr ""
"这通常是函数式编程中抽象的第一步：编写一个（可能是通用的）高阶函数。我们现在"
"可以根据 `mapList` 简洁地实现上面显示的所有示例："

#. type: Plain text
#: ../src/Tutorial/Functor.md:98
#, fuzzy
msgid ""
"```idris multBy2List' : Num a => List a -> List a multBy2List' = mapList (2 "
"*)"
msgstr ""
"```idris multBy2List' : Num a => List a -> List a multBy2List' = mapList (2 "
"*)"

#. type: Plain text
#: ../src/Tutorial/Functor.md:101
#, fuzzy
msgid ""
"toUpperList' : List String -> List String toUpperList' = mapList toUpper"
msgstr "toUpperList' : 列表字符串 -> 列表字符串 toUpperList' = mapList toUpper"

#. type: Plain text
#: ../src/Tutorial/Functor.md:105
#, fuzzy
msgid ""
"toLengthList' : List String -> List Nat toLengthList' = mapList length ```"
msgstr ""
"toLengthList' : 列表字符串 -> 列表 Nat toLengthList' = mapList 长度 ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:110
#, fuzzy
msgid ""
"But surely we'd like to do the same kind of thing with `List1` and `Maybe`! "
"After all, they are just container types like `List`, the only difference "
"being some detail about the number of values they can or can't hold:"
msgstr ""
"但我们肯定想对 `List1` 和 `Maybe` 做同样的事情！毕竟，它们只是像 `List` 这样"
"的容器类型，唯一的区别是关于它们可以或不可以保存的值的数量的一些细节："

#. type: Plain text
#: ../src/Tutorial/Functor.md:116
#, fuzzy
msgid ""
"```idris mapMaybe : (a -> b) -> Maybe a -> Maybe b mapMaybe f Nothing = "
"Nothing mapMaybe f (Just v) = Just (f v)  ```"
msgstr ""
"```idris mapMaybe : (a -> b) -> Maybe a -> Maybe b mapMaybe f Nothing = "
"Nothing mapMaybe f (Just v) = Just (f v) ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:125
#, fuzzy
msgid ""
"Even with `IO`, we'd like to be able to map pure functions over effectful "
"computations. The implementation is a bit more involved, due to the nested "
"layers of data constructors, but if in doubt, the types will surely guide "
"us. Note, however, that `IO` is not publicly exported, so its data "
"constructor is unavailable to us. We can use functions `toPrim` and "
"`fromPrim`, however, for converting `IO` from and to `PrimIO`, which we can "
"freely dissect:"
msgstr ""
"即使使用 `IO`，我们也希望能够将纯函数映射到有效的计算上。由于数据构造函数的嵌"
"套层，实现有点复杂，但如果有疑问，类型肯定会指导我们。但是请注意，`IO` 不是公"
"开导出的，因此我们无法使用它的数据构造函数。我们可以使用函数 `toPrim` 和 "
"`fromPrim`，但是，将 `IO` 与 `PrimIO` 相互转换，我们可以自由剖析："

#. type: Plain text
#: ../src/Tutorial/Functor.md:134
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  其中 mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          让 MkIORes va w2 = prim w\n"
"           在 MkIORes (f va) w2\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:138
#, fuzzy
msgid ""
"From the concept of *mapping a pure function over values in a context* "
"follow some derived functions, which are often useful. Here are some of them "
"for `IO`:"
msgstr ""
"从 * 将纯函数映射到上下文中的值的概念 * 遵循一些派生函数，这些函数通常很有"
"用。以下是 `IO` 中的一些："

#. type: Plain text
#: ../src/Tutorial/Functor.md:142
#, fuzzy
msgid "```idris mapConstIO : b -> IO a -> IO b mapConstIO = mapIO . const"
msgstr "```idris mapConstIO : b -> IO a -> IO b mapConstIO = mapIO 。常量"

#. type: Plain text
#: ../src/Tutorial/Functor.md:146
#, fuzzy
msgid "forgetIO : IO a -> IO ()  forgetIO = mapConstIO ()  ```"
msgstr "忘记IO：IO a -> IO（）忘记IO = mapConstIO（）```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:151
#, fuzzy
msgid ""
"Of course, we'd want to implement `mapConst` and `forget` as well for "
"`List`, `List1`, and `Maybe` (and dozens of other type constructors with "
"some kind of mapping function), and they'd all look the same and be equally "
"boring."
msgstr ""
"当然，我们也想为 `List`、`List1` 和 `Maybe` 实现 `mapConst` 和 `forget` ]（以"
"及其他几十个具有某种映射函数的类型构造函数），它们看起来都一样并且同样无聊。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:161
#, fuzzy
msgid ""
"When we come upon a recurring class of functions with several useful derived "
"functions, we should consider defining an interface. But how should we go "
"about this here? When you look at the types of `mapList`, `mapMaybe`, and "
"`mapIO`, you'll see that it's the `List`, `List1`, and `IO` types we need to "
"get rid of. These are not of type `Type` but of type `Type -> Type`. "
"Luckily, there is nothing preventing us from parametrizing an interface over "
"something else than a `Type`."
msgstr ""
"当我们遇到具有几个有用的派生函数的重复函数类时，我们应该考虑定义一个接口。但"
"是我们应该怎么做呢？当您查看 `mapList`、`mapMaybe` 和 `mapIO` 的类型时，您会"
"发现它是 `List`、`我们需要去掉 List1` 和 `IO` 类型。这些不是 `Type` 类型，而"
"是 `Type -> Type` 类型。幸运的是，除了 `Type` 之外，没有什么能阻止我们对接口"
"进行参数化。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:166
#, fuzzy
msgid ""
"The interface we are looking for is called `Functor`.  Here is its "
"definition and an example implementation (I appended a tick at the end of "
"the names for them not to overlap with the interface and functions exported "
"by the *Prelude*):"
msgstr ""
"我们要找的接口叫做`Functor`。这是它的定义和一个示例实现（我在名称末尾附加了一"
"个勾号，以免它们与 *Prelude* 导出的接口和函数重叠）："

#. type: Plain text
#: ../src/Tutorial/Functor.md:170
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
msgstr ""
"```伊德里斯\n"
"interface Functor' (0 f : Type -> Type) 其中\n"
"  地图' : (a -> b) -> f a -> f b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:175
#, fuzzy, no-wrap
msgid ""
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"
"```\n"
msgstr ""
"实现函子'也许在哪里\n"
"  地图'_无=无\n"
"  map' f (Just v) = Just $ f v\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:179
#, fuzzy
msgid ""
"Note, that we had to give the type of parameter `f` explicitly, and in that "
"case it needs to be annotated with quantity zero if you want it to be erased "
"at runtime (which you almost always want)."
msgstr ""
"请注意，我们必须明确给出参数 `f` 的类型，在这种情况下，如果您希望它在运行时被"
"擦除（您几乎总是想要），则需要用数量零进行注释。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:186
#, fuzzy
msgid ""
"Now, reading type signatures consisting only of type parameters like the one "
"of `map'` can take some time to get used to, especially when some type "
"parameters are applied to other parameters as in `f a`. It can be very "
"helpful to inspect these signatures together with all implicit arguments at "
"the REPL (I formatted the output to make it more readable):"
msgstr ""
"现在，读取仅包含类型参数（如 `map'` 之一）的类型签名可能需要一些时间来适应，"
"尤其是当某些类型参数应用于其他参数时，例如 `f a` .检查这些签名以及 REPL 中的"
"所有隐式参数会非常有帮助（我对输出进行了格式化以使其更具可读性）："

#. type: Plain text
#: ../src/Tutorial/Functor.md:197
#, fuzzy, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"
"```\n"
msgstr ""
"```repl\n"
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map'：{0 b：类型}\n"
"                      -> {0 a：类型}\n"
"                      -> {0 f : 类型 -> 类型}\n"
"                      -> 函子'f\n"
"                      => (a -> b)\n"
"                      -> 一个\n"
"                      -> f b\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:200
#, fuzzy
msgid ""
"It can also be helpful to replace type parameter `f` with a concrete value "
"of the same type:"
msgstr "将类型参数 `f` 替换为相同类型的具体值也很有帮助："

#. type: Plain text
#: ../src/Tutorial/Functor.md:205
#, fuzzy
msgid ""
"```repl Tutorial.Functor> :t map' {f = Maybe} map' : (?a -> ?b) -> Maybe ?a -"
"> Maybe ?b ```"
msgstr ""
"```repl Tutorial.Functor> :t map' {f = Maybe} map' : (?a -> ?b) -> Maybe ?a -"
"> Maybe ?b ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:209
#, fuzzy
msgid ""
"Remember, being able to interpret type signatures is paramount to "
"understanding what's going on in an Idris declaration. You *must* practice "
"this and make use of the tools and utilities given to you."
msgstr ""
"请记住，能够解释类型签名对于理解 Idris 声明中发生的事情至关重要。您 * 必须* "
"练习这一点，并利用提供给您的工具和实用程序。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:211
#, fuzzy
msgid "### Derived Functions"
msgstr "### 派生函数"

#. type: Plain text
#: ../src/Tutorial/Functor.md:215
#, fuzzy
msgid ""
"There are several functions and operators directly derivable from interface "
"`Functor`. Eventually, you should know and remember all of them as they are "
"highly useful. Here they are together with their types:"
msgstr ""
"有几个函数和运算符可以直接从接口 `Functor` 派生。最终，您应该知道并记住所有这"
"些，因为它们非常有用。在这里，它们与它们的类型一起："

#. type: Plain text
#: ../src/Tutorial/Functor.md:219
#, fuzzy
msgid ""
"```repl Tutorial.Functor> :t (<$>)  Prelude.<$> : Functor f => (a -> b) -> f "
"a -> f b"
msgstr ""
"```repl Tutorial.Functor> :t (<$>) Prelude.<$> : Functor f => (a -> b) -> f "
"a -> f b"

#. type: Plain text
#: ../src/Tutorial/Functor.md:222
#, fuzzy
msgid ""
"Tutorial.Functor> :t (<&>)  Prelude.<&> : Functor f => f a -> (a -> b) -> f b"
msgstr ""
"Tutorial.Functor> :t (<&>) Prelude.<&> : Functor f => f a -> (a -> b) -> f b"

#. type: Plain text
#: ../src/Tutorial/Functor.md:225
#, fuzzy
msgid "Tutorial.Functor> :t ($>)  Prelude.$> : Functor f => f a -> b -> f b"
msgstr "Tutorial.Functor> :t ($>) Prelude.$> : Functor f => f a -> b -> f b"

#. type: Plain text
#: ../src/Tutorial/Functor.md:228
#, fuzzy
msgid "Tutorial.Functor> :t (<$)  Prelude.<$ : Functor f => b -> f a -> f b"
msgstr "Tutorial.Functor> :t (<$) Prelude.<$ : Functor f => b -> f a -> f b"

#. type: Plain text
#: ../src/Tutorial/Functor.md:232
#, fuzzy
msgid ""
"Tutorial.Functor> :t ignore Prelude.ignore : Functor f => f a -> f ()  ```"
msgstr ""
"Tutorial.Functor> :t 忽略 Prelude.ignore : Functor f => f a -> f () ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:235
#, fuzzy
msgid ""
"`(<$>)` is an operator alias for `map` and allows you to sometimes drop some "
"parentheses. For instance:"
msgstr "`(<$>)` 是 `map` 的运算符别名，有时您可以去掉一些括号。例如："

#. type: Plain text
#: ../src/Tutorial/Functor.md:239
#, fuzzy
msgid ""
"```idris tailShowReversNoOp : Show a => List1 a -> List String "
"tailShowReversNoOp xs = map (reverse . show) (tail xs)"
msgstr ""
"```idris tailShowReversNoOp : Show a => List1 a -> List String "
"tailShowReversNoOp xs = map (reverse . show) (tail xs)"

#. type: Plain text
#: ../src/Tutorial/Functor.md:243
#, fuzzy
msgid ""
"tailShowReverse : Show a => List1 a -> List String tailShowReverse xs = "
"reverse . show <$> tail xs ```"
msgstr ""
"tailShowReverse ：显示 a => List1 a -> 列表字符串 tailShowReverse xs = "
"reverse 。显示 <$> 尾 xs ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:249
#, fuzzy
msgid ""
"`(<&>)` is an alias for `(<$>)` with the arguments flipped.  The other three "
"(`ignore`, `($>)`, and `(<$)`) are all used to replace the values in a "
"context with a constant. They are often useful when you don't care about the "
"values themselves but want to keep the underlying structure."
msgstr ""
"`(<&>)` 是 `(<$>)` 的别名，参数被翻转。其他三个（`ignore`、`($>)` 和 `(<$)`）"
"都用于将上下文中的值替换为常量。当您不关心值本身但想要保留底层结构时，它们通"
"常很有用。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:251
#, fuzzy
msgid "### Functors with more than one Type Parameter"
msgstr "### 具有多个类型参数的函子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:259
#, fuzzy
msgid ""
"The type constructors we looked at so far where all of type `Type -> Type`. "
"However, we can also implement `Functor` for other type constructors. The "
"only prerequisite is that the type parameter we'd like to change with "
"function `map` must be the last in the argument list. For instance, here is "
"the `Functor` implementation for `Either e` (note, that `Either e` has of "
"course type `Type -> Type` as required):"
msgstr ""
"到目前为止，我们看到的类型构造函数都是 `Type -> Type`。但是，我们也可以为其他"
"类型的构造函数实现 `Functor`。唯一的先决条件是我们想用函数 `map` 更改的类型参"
"数必须是参数列表中的最后一个。例如，这里是 `Either e` 的 `Functor` 实现（注"
"意， `Either e` 当然有类型 `Type -> Type` 为必需的）："

#. type: Plain text
#: ../src/Tutorial/Functor.md:265
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"实现函子'（e）其中\n"
"  地图'_（左ve）=左ve\n"
"  地图' f (右 va) = 右 $ f va\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:269
#, fuzzy
msgid ""
"Here is another example, this time for a type constructor of type `Bool -> "
"Type -> Type` (you might remember this from the exercises in the [last "
"chapter](IO.md)):"
msgstr ""
"这是另一个例子，这次是一个类型为 `Bool -> Type -> Type` 的类型构造函数（你可"
"能还记得 [上一章](IO.md) 的练习中的这个）："

#. type: Plain text
#: ../src/Tutorial/Functor.md:274
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""
"```伊德里斯\n"
"数据 List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  无：List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:279
#, fuzzy, no-wrap
msgid ""
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"
"```\n"
msgstr ""
"实现函子 (List01 ne) 其中\n"
"  地图_ [] = []\n"
"  地图 f (x :: xs) = f x :: 地图 f xs\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:281
#, fuzzy
msgid "### Functor Composition"
msgstr "### 函子组合"

#. type: Plain text
#: ../src/Tutorial/Functor.md:284
#, fuzzy
msgid ""
"The nice thing about functors is how they can be paired and nested with "
"other functors and the results are functors again:"
msgstr "函子的好处是它们可以如何与其他函子配对和嵌套，结果又是函子："

#. type: Plain text
#: ../src/Tutorial/Functor.md:290
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
msgstr ""
"```伊德里斯\n"
"记录产品 (f,g : Type -> Type) (a : Type) 其中\n"
"  构造函数 MkProduct\n"
"  fst : f\n"
"  snd : g 一个\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:294
#, fuzzy, no-wrap
msgid ""
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"
"```\n"
msgstr ""
"实现 Functor f => Functor g => Functor (Product f g) 其中\n"
"  映射 f (MkProduct l r) = MkProduct (映射 f l) (映射 f r)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:297
#, fuzzy
msgid ""
"The above allows us to conveniently map over a pair of functors. Note, "
"however, that Idris needs some help with inferring the types involved:"
msgstr ""
"以上允许我们方便地映射一对函子。但是请注意，Idris 需要一些帮助来推断所涉及的"
"类型："

#. type: Plain text
#: ../src/Tutorial/Functor.md:301
#, fuzzy
msgid ""
"```idris toPair : Product f g a -> (f a, g a)  toPair (MkProduct fst snd) = "
"(fst, snd)"
msgstr ""
"```idris toPair : Product f g a -> (f a, g a) toPair (MkProduct fst snd) = "
"(fst, snd)"

#. type: Plain text
#: ../src/Tutorial/Functor.md:304
#, fuzzy
msgid "fromPair : (f a, g a) -> Product f g a fromPair (x,y) = MkProduct x y"
msgstr "fromPair : (f a, g a) -> 产品 f g a fromPair (x,y) = MkProduct x y"

#. type: Plain text
#: ../src/Tutorial/Functor.md:310
#, fuzzy, no-wrap
msgid ""
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"
"```\n"
msgstr ""
"productExample : 显示一个\n"
"               =>（要么 e a，列出 a）\n"
"               ->（要么是字符串，要么是列表字符串）\n"
"产品示例 = toPair 。地图显示。 fromPair {f = 任意一个 e, g = 列表}\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:313
#, fuzzy
msgid ""
"More often, we'd like to map over several layers of nested functors at once. "
"Here's how to do this with an example:"
msgstr "更多时候，我们想一次映射多层嵌套函子。以下是如何通过示例执行此操作："

#. type: Plain text
#: ../src/Tutorial/Functor.md:318
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
msgstr ""
"```伊德里斯\n"
"记录 Comp (f,g : Type -> Type) (a : Type) 其中\n"
"  构造函数 MkComp\n"
"  unComp : f (g a)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:321
#, fuzzy, no-wrap
msgid ""
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
msgstr ""
"实现 Functor f => Functor g => Functor (Comp f g) 其中\n"
"  映射 f (MkComp v) = MkComp $ 映射 f <$> v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:325
#, fuzzy
msgid ""
"compExample : Show a => List (Either e a) -> List (Either e String)  "
"compExample = unComp . map show . MkComp {f = List, g = Either e} ```"
msgstr ""
"compExample : 显示 a => List (Either e a) -> List (Either e String) "
"compExample = unComp 。地图显示。 MkComp {f = 列表，g = e} ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:327
#, fuzzy
msgid "#### Named Implementations"
msgstr "#### 命名实现"

#. type: Plain text
#: ../src/Tutorial/Functor.md:334
#, fuzzy
msgid ""
"Sometimes, there are more ways to implement an interface for a given type. "
"For instance, for numeric types we can have a `Monoid` representing addition "
"and one representing multiplication.  Likewise, for nested functors, `map` "
"can be interpreted as a mapping over only the first layer of values, or a "
"mapping over several layers of values."
msgstr ""
"有时，有更多方法可以为给定类型实现接口。例如，对于数字类型，我们可以有一个 "
"`Monoid` 代表加法和一个代表乘法。同样，对于嵌套函子，`map` 可以解释为仅对第一"
"层值的映射，或对若干层值的映射。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:339
#, fuzzy
msgid ""
"One way to go about this is to define single-field wrappers as shown with "
"data type `Comp` above. However, Idris also allows us to define additional "
"interface implementations, which must then be given a name. For instance:"
msgstr ""
"解决此问题的一种方法是定义单字段包装器，如上面的数据类型 `Comp` 所示。然而，"
"Idris 也允许我们定义额外的接口实现，然后必须给它一个名字。例如："

#. type: Plain text
#: ../src/Tutorial/Functor.md:344
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"[Compose'] Functor f => Functor g => Functor (f . g) 其中\n"
"  地图 f = (地图 . 地图) f\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:350
#, fuzzy
msgid ""
"Note, that this defines a new implementation of `Functor`, which will *not* "
"be considered during implicit resolution in order to avoid ambiguities. "
"However, it is possible to explicitly choose to use this implementation by "
"passing it as an explicit argument to `map`, prefixed with an `@`:"
msgstr ""
"请注意，这定义了 `Functor` 的新实现，在隐式解析期间将考虑 *not* 以避免歧义。"
"但是，可以通过将其作为显式参数传递给 `map` 来显式选择使用此实现，并以 `@` 为"
"前缀："

#. type: Plain text
#: ../src/Tutorial/Functor.md:355
#, fuzzy
msgid ""
"```idris compExample2 : Show a => List (Either e a) -> List (Either e "
"String)  compExample2 = map @{Compose} show ```"
msgstr ""
"```idris compExample2 : Show a => List (Either e a) -> List (Either e "
"String) compExample2 = map @{Compose} show ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:358
#, fuzzy
msgid ""
"In the example above, we used `Compose` instead of `Compose'`, since the "
"former is already exported by the *Prelude*."
msgstr ""
"在上面的示例中，我们使用 `Compose` 代替 `Compose'`，因为前者已经由 *Prelude* "
"导出。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:360
#, fuzzy
msgid "### Functor Laws"
msgstr "### 函子定律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:365
#, fuzzy
msgid ""
"Implementations of `Functor` are supposed to adhere to certain laws, just "
"like implementations of `Eq` or `Ord`. Again, these laws are not verified by "
"Idris, although it would be possible (and often cumbersome) to do so."
msgstr ""
"`Functor` 的实现应该遵守某些规律，就像 `Eq` 或 `Ord` 的实现一样。同样，这些法"
"律并未得到 Idris 的验证，尽管这样做是可能的（而且通常很麻烦）。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:370
#, fuzzy, no-wrap
msgid ""
"1. `map id = id`: Mapping the identity function over a functor\n"
"    must not have any visible effect such as changing a container's\n"
"    structure or affecting the side effects perfomed when\n"
"    running an `IO` action.\n"
msgstr ""
"1. `map id = id`：将恒等函数映射到函子上\n"
"    不得有任何可见的效果，例如更改容器的\n"
"    结构或影响时执行的副作用\n"
"    运行 `IO` 动作。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:373
#, fuzzy
msgid ""
"`map (f . g) = map f . map g`: Sequencing two mappings must be identical to "
"a single mapping using the composition of the two functions."
msgstr ""
"`map (f . g) = 映射 f . map g`：使用两个函数的组合对两个映射进行排序必须与单"
"个映射相同。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:380
#, fuzzy
msgid ""
"Both of these laws request, that `map` is preserving the *structure* of "
"values. This is easier to understand with container types like `List`, "
"`Maybe`, or `Either e`, where `map` is not allowed to add or remove any "
"wrapped value, nor - in case of `List` - change their order. With `IO`, this "
"can best be described as `map` not performing additional side effects."
msgstr ""
"这两条定律都要求 `map` 保留值的 *structure*。使用 `List`、`Maybe` 或 `Ei` 等"
"容器类型更容易理解，其中不允许添加或删除 `map`任何包装的值，也不 - 在 `List` "
"的情况下 - 更改它们的顺序。使用 `IO`，这可以最好地描述为 `map` 没有执行额外的"
"副作用。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:385
#, fuzzy
msgid ""
"Write your own implementations of `Functor'` for `Maybe`, `List`, `List1`, "
"`Vect n`, `Either e`, and `Pair a`."
msgstr ""
"为 `Maybe`、`List`、`List1`、`Vect n`、` 编写自己的 `Functor'` 实现e` 和 ` "
"对 a`。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:388
#, fuzzy
msgid ""
"Write a named implementation of `Functor` for pairs of functors (similar to "
"the one implemented for `Product`)."
msgstr "为仿函数对编写 `Functor` 的命名实现（类似于为 `Product` 实现的实现）。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:391
#, fuzzy
msgid ""
"Implement `Functor` for data type `Identity` (which is available from "
"`Control.Monad.Identity` in *base*):"
msgstr ""
"为数据类型 `Identity` 实现 `Functor`（可从 *base* 中的 `Control.Monad."
"Identity` 获得）："

#. type: Plain text
#: ../src/Tutorial/Functor.md:397
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   记录身份在哪里\n"
"     构造函数 ID\n"
"     值：一个\n"
"   ```\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:404
#, fuzzy
msgid ""
"Here is a curious one: Implement `Functor` for `Const e` (which is also "
"available from `Control.Applicative.Const` in *base*). You might be confused "
"about the fact that the second type parameter has absolutely no relevance at "
"runtime, as there is no value of that type. Such types are sometimes called "
"*phantom types*. They can be quite useful for tagging values with additional "
"typing information."
msgstr ""
"这是一个奇怪的问题：为 `Const e` 实现 `Functor`（也可以从 *base* 中的 "
"`Control.Applicative.Const` 获得）。您可能会对第二个类型参数在运行时绝对没有"
"相关性这一事实感到困惑，因为没有该类型的值。这种类型有时被称为*幻像类型*。它"
"们对于使用附加类型信息标记值非常有用。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:407
#, fuzzy, no-wrap
msgid ""
"   Don't let the above confuse you: There is only one possible implementation.\n"
"   As usual, use holes and let the compiler guide you if you get lost.\n"
msgstr ""
"   不要让上述内容使您感到困惑：只有一种可能的实现。\n"
"   像往常一样，使用孔，如果你迷路了，让编译器指导你。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:413
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   记录 Const (e,a : Type) 其中\n"
"     构造函数 MkConst\n"
"     价值：e\n"
"   ```\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:416
#, fuzzy
msgid ""
"Here is a sum type for describing CRUD operations (Create, Read, Update, and "
"Delete) in a data store:"
msgstr ""
"这是用于描述数据存储中的 CRUD 操作（创建、读取、更新和删除）的求和类型："

#. type: Plain text
#: ../src/Tutorial/Functor.md:426
#, fuzzy, no-wrap
msgid "   Implement `Functor` for `Crud i`.\n"
msgstr "   为 `Crud i` 实现 `Functor`。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:428
#, fuzzy
msgid "Here is a sum type for describing responses from a data server:"
msgstr "以下是用于描述来自数据服务器的响应的 sum 类型："

#. type: Plain text
#: ../src/Tutorial/Functor.md:439
#, fuzzy, no-wrap
msgid "   Implement `Functor` for `Repsonse e i`.\n"
msgstr "   为 `Repsonse e i` 实现 `Functor`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:441
#, fuzzy
msgid "Implement `Functor` for `Validated e`:"
msgstr "为 `Validated e` 实现 `Functor`："

#. type: Plain text
#: ../src/Tutorial/Functor.md:447
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   数据验证：（e，a：类型）->类型在哪里\n"
"     无效 : (err : e) -> 已验证 e a\n"
"     有效 : (val : a) -> 已验证 e a\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:449
#, fuzzy
msgid "## Applicative"
msgstr "## 适用"

#. type: Plain text
#: ../src/Tutorial/Functor.md:453
#, fuzzy
msgid ""
"While `Functor` allows us to map a pure, unary function over a value in a "
"context, it doesn't allow us to combine n such values under an n-ary "
"function."
msgstr ""
"虽然 `Functor` 允许我们将纯一元函数映射到上下文中的值上，但它不允许我们在 n "
"元函数下组合 n 个这样的值。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:455
#, fuzzy
msgid "For instance, consider the following functions:"
msgstr "例如，考虑以下函数："

#. type: Plain text
#: ../src/Tutorial/Functor.md:460
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
msgstr ""
"```伊德里斯\n"
"liftMaybe2 : (a -> b -> c) -> 也许 a -> 也许 b -> 也许 c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _ _ = 无\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:464
#, fuzzy, no-wrap
msgid ""
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
msgstr ""
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ [] [] = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:473
#, fuzzy, no-wrap
msgid ""
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"
"```\n"
msgstr ""
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  去哪里：PrimIO a -> PrimIO b -> PrimIO c\n"
"        走吧 pb w =\n"
"          让 MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           在 MkIORes (f va vb) w3\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:478
#, fuzzy
msgid ""
"This behavior is not covered by `Functor`, yet it is a very common thing to "
"do. For instance, we might want to read two numbers from standard input "
"(both operations might fail), calculating the product of the two. Here's the "
"code:"
msgstr ""
"`Functor` 没有涵盖这种行为，但这是很常见的事情。例如，我们可能想从标准输入中"
"读取两个数字（这两个操作都可能失败），计算两者的乘积。这是代码："

#. type: Plain text
#: ../src/Tutorial/Functor.md:486
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"multNumbers : Num a => Neg a => IO (也许是 a)\n"
"多数字 = 做\n"
"  s1 <- 获取线\n"
"  s2 <- 获取线\n"
"  纯 $liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:490
#, fuzzy
msgid ""
"And it won't stop here. We might just as well want to have `liftMaybe3` for "
"ternary functions and three `Maybe` arguments and so on, for arbitrary "
"numbers of arguments."
msgstr ""
"它不会止步于此。对于三元函数，我们可能还希望有 `liftMaybe3` 和三个 `Maybe` 参"
"数等等，对于任意数量的参数。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:493
#, fuzzy
msgid ""
"But there is more: We'd also like to lift pure values into the context in "
"question. With this, we could do the following:"
msgstr ""
"但还有更多：我们还想将纯粹的价值观提升到所讨论的背景中。有了这个，我们可以做"
"以下事情："

#. type: Plain text
#: ../src/Tutorial/Functor.md:498
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
msgstr ""
"```伊德里斯\n"
"liftMaybe3 : (a -> b -> c -> d) -> 也许 a -> 也许 b -> 也许 c -> 也许 d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _ _ _ = 没有\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:501
#, fuzzy
msgid "pureMaybe : a -> Maybe a pureMaybe = Just"
msgstr "pureMaybe : a -> Maybe a pureMaybe = Just"

#. type: Plain text
#: ../src/Tutorial/Functor.md:507
#, fuzzy, no-wrap
msgid ""
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"
"```\n"
msgstr ""
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (纯 100)\n"
"  其中 calc : a -> a -> a -> a\n"
"        计算 x y z = x * y + z\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:511
#, fuzzy
msgid ""
"As you'll of course already know, I am now going to present a new interface "
"to encapsulate this behavior. It's called `Applicative`.  Here is its "
"definition and an example implementation:"
msgstr ""
"正如您当然已经知道的那样，我现在将提供一个新接口来封装这种行为。它被称为 "
"`Applicative`。这是它的定义和示例实现："

#. type: Plain text
#: ../src/Tutorial/Functor.md:516
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
msgstr ""
"```伊德里斯\n"
"接口 Functor' f => Applicative' f 其中\n"
"  应用程序：f (a -> b) -> f a -> f b\n"
"  纯' : a -> f a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:520
#, fuzzy, no-wrap
msgid ""
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
msgstr ""
"实施应用'也许在哪里\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  应用程序 _ _ = 无\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:523
#, fuzzy, no-wrap
msgid ""
"  pure' = Just\n"
"```\n"
msgstr ""
"  纯' = 只是\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:527
#, fuzzy
msgid ""
"Interface `Applicative` is of course already exported by the *Prelude*.  "
"There, function `app` is an operator sometimes called *app* or *apply*: "
"`(<*>)`."
msgstr ""
"接口 `Applicative` 当然已经由 *Prelude* 导出。在那里，函数 `app` 是一个有时称"
"为 *app* 或 *apply* 的运算符：`(<*>)`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:530
#, fuzzy
msgid ""
"You may wonder, how functions like `liftMaybe2` or `liftIO3` are related to "
"operator *apply*. Let me demonstrate this:"
msgstr ""
"您可能想知道，像 `liftMaybe2` 或 `liftIO3` 这样的函数如何与运算符 *apply* 相"
"关联。让我演示一下："

#. type: Plain text
#: ../src/Tutorial/Functor.md:534
#, fuzzy
msgid ""
"```idris liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA2 "
"fun fa fb = pure fun <*> fa <*> fb"
msgstr ""
"```idris liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA2 "
"fun fa fb = pure fun <*> fa <*> fb"

#. type: Plain text
#: ../src/Tutorial/Functor.md:538
#, fuzzy
msgid ""
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d "
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc ```"
msgstr ""
"liftA3 : 应用 f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d liftA3 fun "
"fa fb fc = pure fun <*> fa <*> fb <*> fc```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:544
#, fuzzy
msgid ""
"It is really important for you to understand what's going on here, so let's "
"break these down. If we specialize `liftA2` to use `Maybe` for `f`, `pure "
"fun` is of type `Maybe (a -> b -> c)`. Likewise, `pure fun <*> fa` is of "
"type `Maybe (b -> c)`, as `(<*>)` will apply the value stored in `fa` to the "
"function stored in `pure fun` (currying!)."
msgstr ""
"了解这里发生的事情对您来说非常重要，所以让我们分解这些内容。如果我们将 "
"`liftA2` 专门用于 `Maybe` 用于 `f`，则 `pure fun` 的类型为 `Maybe (a -> b -> "
"c)`。同样，`pure fun <*> fa` 是 ` 类型的可能 (b -> c)`，因为 `(<*>)` 将应用存"
"储在 [ X288X]fa` 到存储在 `pure fun` 中的函数（柯里化！）。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:550
#, fuzzy
msgid ""
"You'll often see such chains of applications of *apply*, the number of "
"*applies* corresponding to the arity of the function we lift.  You'll "
"sometimes also see the following, which allows us to drop the initial call "
"to `pure`, and use the operator version of `map` instead:"
msgstr ""
"你会经常看到 *apply* 这样的应用链，*applies* 的数量对应于我们提升的函数的数"
"量。您有时还会看到以下内容，这使我们可以放弃对 `pure` 的初始调用，并改用 "
"`map` 的运算符版本："

#. type: Plain text
#: ../src/Tutorial/Functor.md:554
#, fuzzy
msgid ""
"```idris liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c "
"liftA2' fun fa fb = fun <$> fa <*> fb"
msgstr ""
"```idris liftA2' : 应用 f => (a -> b -> c) -> f a -> f b -> f c liftA2' fun "
"fa fb = fun <$> fa <*> fb"

#. type: Plain text
#: ../src/Tutorial/Functor.md:558
#, fuzzy
msgid ""
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d "
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc ```"
msgstr ""
"liftA3' : 应用 f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d liftA3' "
"fun fa fb fc = fun <$> fa <*> fb < *> fc ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:564
#, fuzzy
msgid ""
"So, interface `Applicative` allows us to lift values (and functions!)  into "
"computational contexts and apply them to values in the same contexts. Before "
"we will see an extended example why this is useful, I'll quickly introduce "
"some syntactic sugar for working with applicative functors."
msgstr ""
"因此，接口 `Applicative` 允许我们将值（和函数！）提升到计算上下文中，并将它们"
"应用于相同上下文中的值。在我们将看到一个扩展示例为什么这很有用之前，我将快速"
"介绍一些用于使用应用函子的语法糖。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:566
#, fuzzy
msgid "### Idiom Brackets"
msgstr "### 成语括号"

#. type: Plain text
#: ../src/Tutorial/Functor.md:571
#, fuzzy
msgid ""
"The programming style used for implementing `liftA2'` and `liftA3'` is also "
"referred to as *applicative style* and is used a lot in Haskell for "
"combining several effectful computations with a single pure function."
msgstr ""
"用于实现 `liftA2'` 和 `liftA3'` 的编程风格也称为 *applicative 风格*，在 "
"Haskell 中被大量用于将几个有效的计算与单一的纯函数。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:575
#, fuzzy
msgid ""
"In Idris, there is an alternative to using such chains of operator "
"applications: Idiom brackets. Here's another reimplementation of `liftA2` "
"and `liftA3`:"
msgstr ""
"在 Idris 中，有一个替代使用这种运算符应用程序链的方法：成语方括号。这是 "
"`liftA2` 和 `liftA3` 的另一个重新实现："

#. type: Plain text
#: ../src/Tutorial/Functor.md:579
#, fuzzy
msgid ""
"```idris liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c "
"liftA2'' fun fa fb = [| fun fa fb |]"
msgstr ""
"```idris liftA2'' : 应用 f => (a -> b -> c) -> f a -> f b -> f c liftA2'' "
"fun fa fb = [|有趣的fa fb |]"

#. type: Plain text
#: ../src/Tutorial/Functor.md:583
#, fuzzy
msgid ""
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d "
"liftA3'' fun fa fb fc = [| fun fa fb fc |] ```"
msgstr ""
"liftA3'' : 应用 f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d liftA3'' "
"fun fa fb fc = [|有趣的 fa fb fc |] ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:590
#, fuzzy
msgid ""
"The above implementations will be desugared to the one given for `liftA2` "
"and `liftA3`, again *before disambiguating, type checking, and filling in of "
"implicit values*. Like with the *bind* operator, we can therefore write "
"custom implementations for `pure` and `(<*>)`, and Idris will use these if "
"it can disambiguate between the overloaded function names."
msgstr ""
"在消除歧义、类型检查和填充隐式值 * 之前，上述实现将被简化为 `liftA2` 和 "
"`liftA3` 给定的实现。与 *bind* 运算符一样，我们因此可以为 `pure` 和 `(<*>)` "
"编写自定义实现，如果 Idris 可以在重载的函数名。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:592
#, fuzzy
msgid "### Use Case: CSV Reader"
msgstr "### 用例：CSV 阅读器"

#. type: Plain text
#: ../src/Tutorial/Functor.md:604
#, fuzzy
msgid ""
"In order to understand the power and versatility that comes with applicative "
"functors, we will look at a slightly extended example. We are going to write "
"some utilities for parsing and decoding content from CSV files. These are "
"files where each line holds a list of values separated by commas (or some "
"other delimiter). Typically, they are used to store tabular data, for "
"instance from spread sheet applications. What we would like to do is convert "
"lines in a CSV file and store the result in custom records, where each "
"record field corresponds to a column in the table."
msgstr ""
"为了理解应用函子的强大功能和多功能性，我们将看一个稍微扩展的示例。我们将编写"
"一些实用程序来解析和解码 CSV 文件中的内容。这些文件的每一行都包含一个由逗号"
"（或其他分隔符）分隔的值列表。通常，它们用于存储表格数据，例如来自电子表格应"
"用程序的数据。我们想要做的是转换 CSV 文件中的行并将结果存储在自定义记录中，其"
"中每个记录字段对应于表中的一列。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:609
#, fuzzy
msgid ""
"For instance, here is a simple example file, containing tabular user "
"information from a web store: First name, last name, age (optional), email "
"address, gender, and password."
msgstr ""
"例如，这是一个简单的示例文件，其中包含来自网络商店的表格用户信息：名字、姓"
"氏、年龄（可选）、电子邮件地址、性别和密码。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:615
#, fuzzy
msgid ""
"```repl Jon,Doe,42,jon@doe.ch,m,weijr332sdk Jane,Doe,,jane@doe.ch,f,"
"aa433sd112 Stefan,Hoeck,,nope@goaway.ch,m,password123 ```"
msgstr ""
"```repl Jon,Doe,42,jon@doe.ch,m,weijr332sdk Jane,Doe,,jane@doe.ch,f,"
"aa433sd112 Stefan,Hoeck,,nope@goaway.ch,m,password123 ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:621
#, fuzzy
msgid ""
"And here are the Idris data types necessary to hold this information at "
"runtime. We use again custom string wrappers for increased type safety and "
"because it will allow us to define for each data type what we consider to be "
"valid input:"
msgstr ""
"以下是在运行时保存此信息所必需的 Idris 数据类型。我们再次使用自定义字符串包装"
"器来提高类型安全性，因为它允许我们为每种数据类型定义我们认为是有效输入的内"
"容："

#. type: Plain text
#: ../src/Tutorial/Functor.md:624
#, fuzzy
msgid "```idris data Gender = Male | Female | Other"
msgstr "```idris 数据性别 = 男 |女 |其他"

#. type: Plain text
#: ../src/Tutorial/Functor.md:628
#, fuzzy, no-wrap
msgid ""
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
msgstr ""
"记录名称 where\n"
"  构造函数 MkName\n"
"  值：字符串\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:646
#, fuzzy, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"
"```\n"
msgstr ""
"记录用户在哪里\n"
"  构造函数 MkUser\n"
"  名字：名字\n"
"  姓氏：姓名\n"
"  年龄：也许纳特\n"
"  电子邮件：电子邮件\n"
"  性别：性别\n"
"  密码：密码\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:650
#, fuzzy
msgid ""
"We start by defining an interface for reading fields in a CSV file and "
"writing implementations for the data types we'd like to read:"
msgstr ""
"我们首先定义一个用于读取 CSV 文件中的字段的接口，并为我们想要读取的数据类型编"
"写实现："

#. type: Plain text
#: ../src/Tutorial/Functor.md:655
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"interface CSVField a where\n"
"  read : String -> Maybe a\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"接口 CSVField a where\n"
"  阅读：字符串->也许是\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:659
#, fuzzy
msgid ""
"Below are implementations for `Gender` and `Bool`. I decided to in these "
"cases encode each value with a single lower case character:"
msgstr ""
"下面是 `Gender` 和 `Bool` 的实现。在这些情况下，我决定使用单个小写字符对每个"
"值进行编码："

#. type: Plain text
#: ../src/Tutorial/Functor.md:666
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
msgstr ""
"```伊德里斯\n"
"CSVField 性别 where\n"
"  读“m”=只是男性\n"
"  读“f”=只是女性\n"
"  读“o”=只是其他\n"
"  读 _ = 没有\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:672
#, fuzzy, no-wrap
msgid ""
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"
"```\n"
msgstr ""
"CSVField Bool where\n"
"  读“t” = 正确\n"
"  读“f”=只是假\n"
"  读 _ = 没有\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:675
#, fuzzy
msgid "For numeric types, we can use the parsing functions from `Data.String`:"
msgstr "对于数值类型，我们可以使用 `Data.String` 中的解析函数："

#. type: Plain text
#: ../src/Tutorial/Functor.md:679
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"CSVField Nat where\n"
"  read = parsePositive\n"
msgstr ""
"```伊德里斯\n"
"CSVField Nat where\n"
"  读取 = parsePositive\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:682
#, fuzzy, no-wrap
msgid ""
"CSVField Integer where\n"
"  read = parseInteger\n"
msgstr ""
"CSVField 整数 where\n"
"  读取 = parseInteger\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:686
#, fuzzy, no-wrap
msgid ""
"CSVField Double where\n"
"  read = parseDouble\n"
"```\n"
msgstr ""
"CSVField Double where\n"
"  读取 = parseDouble\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:692
#, fuzzy
msgid ""
"For optional values, the stored type must itself come with an instance of "
"`CSVField`. We can then treat the empty string `\"\"` as `Nothing`, while a "
"non-empty string will be passed to the encapsulated type's field reader.  "
"(Remember that `(<$>)` is an alias for `map`.)"
msgstr ""
"对于可选值，存储的类型本身必须带有 `CSVField` 的实例。然后我们可以将空字符串 "
"`\"\"` 视为 `Nothing`，而将非空字符串传递给封装类型的字段读取器。 （记住 `(<"
"$>)` 是 `map` 的别名。）"

#. type: Plain text
#: ../src/Tutorial/Functor.md:698
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"CSVField a => CSVField (也许是 a) 其中\n"
"  读“”=什么都没有\n"
"  读取 s = 只是 <$> 读取 s\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:703
#, fuzzy
msgid ""
"Finally, for our string wrappers, we need to decide what we consider to be "
"valid values. For simplicity, I decided to limit the length of allowed "
"strings and the set of valid characters."
msgstr ""
"最后，对于我们的字符串包装器，我们需要决定我们认为什么是有效值。为简单起见，"
"我决定限制允许的字符串长度和有效字符集。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:707
#, fuzzy
msgid ""
"```idris readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a "
"readIf p mk s = if p s then Just (mk s) else Nothing"
msgstr ""
"```idris readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a "
"readIf p mk s = if p s then Just (mk s) else Nothing"

#. type: Plain text
#: ../src/Tutorial/Functor.md:712
#, fuzzy, no-wrap
msgid ""
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
msgstr ""
"isValidName : 字符串 -> 布尔值\n"
"isValidName s =\n"
"  让 len = 长度 s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:715
#, fuzzy, no-wrap
msgid ""
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
msgstr ""
"CSV 字段名称 where\n"
"  read = readIf isValidName MkName\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:720
#, fuzzy, no-wrap
msgid ""
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
msgstr ""
"isEmailChar : 字符 -> 布尔值\n"
"isEmailChar '.' = 真\n"
"isEmailChar '@' = True\n"
"isEmailChar c = isAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:725
#, fuzzy, no-wrap
msgid ""
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
msgstr ""
"isValidEmail : 字符串 -> 布尔\n"
"isValidEmail s =\n"
"  让 len = 长度 s\n"
"   in 0 < len && len <= 100 && all isEmailChar (解包)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:728
#, fuzzy, no-wrap
msgid ""
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
msgstr ""
"CSVField 电子邮件地址\n"
"  read = readIf isValidEmail MkEmail\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:732
#, fuzzy, no-wrap
msgid ""
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
msgstr ""
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c = not (isControl c) && not (isSpace c)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:737
#, fuzzy, no-wrap
msgid ""
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
msgstr ""
"isValidPassword : 字符串 -> 布尔\n"
"isValidPassword s =\n"
"  让 len = 长度 s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:741
#, fuzzy, no-wrap
msgid ""
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"
"```\n"
msgstr ""
"CSVField 密码 where\n"
"  read = readIf isValidPassword MkPassword\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:745
#, fuzzy
msgid ""
"In a later chapter, we will learn about refinement types and how to store an "
"erased proof of validity together with a validated value."
msgstr ""
"在后面的章节中，我们将学习细化类型以及如何将已擦除的有效性证明与验证值一起存"
"储。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:749
#, fuzzy
msgid ""
"We can now start to decode whole lines in a CSV file.  In order to do so, we "
"first introduce a custom error type encapsulating how things can go wrong:"
msgstr ""
"我们现在可以开始解码 CSV 文件中的整行。为了做到这一点，我们首先引入一个自定义"
"错误类型来封装事情是如何出错的："

#. type: Plain text
#: ../src/Tutorial/Functor.md:756
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"数据 CSVError : 在哪里输入\n"
"  FieldError : (line, column : Nat) -> (str: String) -> CSVError\n"
"  UnexpectedEndOfInput：（行，列：Nat）-> CSVError\n"
"  ExpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:760
#, fuzzy
msgid ""
"We can now use `CSVField` to read a single field at a given line and "
"position in a CSV file, and return a `FieldError` in case of a failure."
msgstr ""
"我们现在可以使用 `CSVField` 读取 CSV 文件中给定行和位置的单个字段，并在失败的"
"情况下返回 `FieldError`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:766
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField 行 col str =\n"
"  可能（左 $ FieldError line col str）右（读取 str）\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:772
#, fuzzy
msgid ""
"If we know in advance the number of fields we need to read, we can try and "
"convert a list of strings to a `Vect` of the given length. This facilitates "
"reading record values of a known number of fields, as we get the correct "
"number of string variables when pattern matching on the vector:"
msgstr ""
"如果我们事先知道需要读取的字段数量，我们可以尝试将字符串列表转换为给定长度的 "
"`Vect`。这有助于读取已知数量字段的记录值，因为我们在向量上进行模式匹配时得到"
"正确数量的字符串变量："

#. type: Plain text
#: ../src/Tutorial/Functor.md:780
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0 线 _ [] = 右 []\n"
"toVect 0 line col _ = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col [] = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:783
#, fuzzy
msgid ""
"Finally, we can implement function `readUser` to try and convert a single "
"line in a CSV-file to a value of type `User`:"
msgstr ""
"最后，我们可以实现函数 `readUser` 来尝试将 CSV 文件中的一行转换为 `User` 类型"
"的值："

#. type: Plain text
#: ../src/Tutorial/Functor.md:794
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
msgstr ""
"```伊德里斯\n"
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' 行 ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            （读取字段第 3 行 a）\n"
"            （读取字段第 4 行）\n"
"            (readField line 5 g)\n"
"            （读取字段第 6 行 pw）|]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:798
#, fuzzy
msgid ""
"readUser : (line : Nat) -> String -> Either CSVError User readUser line = "
"readUser' line . forget . split (',' ==)  ```"
msgstr ""
"readUser : (line : Nat) -> String -> Either CSVError User readUser line = "
"readUser' line 。忘记 。拆分（'，' ==）```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:800 ../src/Tutorial/Traverse.md:122
#, fuzzy
msgid "Let's give this a go at the REPL:"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"让我们在 REPL 上试一试："

#. type: Plain text
#: ../src/Tutorial/Functor.md:808
#, fuzzy, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"
"```\n"
msgstr ""
"```repl\n"
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"对 (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (仅 46) (MkEmail \"j@f.ch\") 男 (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"左（FieldError 7 6“shortPW”）\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:816
#, fuzzy
msgid ""
"Note, how in the implementation of `readUser'` we used an idiom bracket to "
"map a function of six arguments (`MkUser`)  over six values of type `Either "
"CSVError`. This will automatically succeed, if and only if all of the "
"parsings have succeeded. It would have been notoriously cumbersome resulting "
"in much less readable code to implement `readUser'` with a succession of six "
"nested pattern matches."
msgstr ""
"请注意，在 `readUser'` 的实现中，我们如何使用惯用括号将六个参数 (`MkUser`) 的"
"函数映射到 ` 或 CSVError` 类型的六个值上。当且仅当所有解析都成功时，这将自动"
"成功。众所周知，使用连续六个嵌套模式匹配来实现 `readUser'` 的代码的可读性会大"
"大降低。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:819
#, fuzzy
msgid ""
"However, the idiom bracket above looks still quite repetitive.  Surely, we "
"can do better?"
msgstr "但是，上面的成语括号看起来仍然非常重复。当然，我们可以做得更好吗？"

#. type: Plain text
#: ../src/Tutorial/Functor.md:821
#, fuzzy
msgid "#### A Case for Heterogeneous Lists"
msgstr "#### 异构列表的案例"

#. type: Plain text
#: ../src/Tutorial/Functor.md:827
#, fuzzy
msgid ""
"It is time to learn about a family of types, which can be used as a generic "
"representation for record types, and which will allow us to represent and "
"read rows in heterogeneous tables with a minimal amount of code: "
"Heterogeneous lists."
msgstr ""
"是时候学习一组类型了，它们可以用作记录类型的通用表示，并且允许我们用最少的代"
"码表示和读取异构表中的行：异构列表。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:835
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"命名空间 HList\n"
"  公共出口\n"
"  data HList : (ts : List Type) -> Type where\n"
"    无：HList 无\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:841
#, fuzzy
msgid ""
"A heterogeneous list is a list type indexed over a *list of types*.  This "
"allows us to at each position store a value of the type at the same position "
"in the list index. For instance, here is a variant, which stores three "
"values of types `Bool`, `Nat`, and `Maybe String` (in that order):"
msgstr ""
"异构列表是在类型 * 的 * 列表上索引的列表类型。这允许我们在每个位置将类型的值"
"存储在列表索引中的相同位置。例如，这里有一个变体，它存储了 `Bool`、`Nat` 和 "
"`Maybe String` 类型的三个值（按此顺序）："

#. type: Plain text
#: ../src/Tutorial/Functor.md:846
#, fuzzy
msgid ""
"```idris hlist1 : HList [Bool, Nat, Maybe String] hlist1 = [True, 12, "
"Nothing] ```"
msgstr ""
"```idris hlist1 : HList [Bool, Nat, Maybe String] hlist1 = [True, 12, "
"Nothing] ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:854
#, fuzzy
msgid ""
"You could argue that heterogeneous lists are just tuples storing values of "
"the given types. That's right, of course, however, as you'll learn the hard "
"way in the exercises, we can use the list index to perform compile-time "
"computations on `HList`, for instance when concatenating two such lists to "
"keep track of the types stored in the result at the same time."
msgstr ""
"您可能会争辩说，异构列表只是存储给定类型值的元组。没错，当然，但是，因为您将"
"在练习中学习困难的方法，我们可以使用列表索引对 `HList` 执行编译时计算，例如连"
"接两个这样的列表以保持同时跟踪结果中存储的类型。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:859
#, fuzzy
msgid ""
"But first, we'll make use of `HList` as a means to concisely parse CSV-"
"lines. In order to do that, we need to introduce a new interface for types "
"corresponding to whole lines in a CSV-file:"
msgstr ""
"但首先，我们将使用 `HList` 作为简洁解析 CSV 行的方法。为此，我们需要为对应于 "
"CSV 文件中整行的类型引入一个新接口："

#. type: Plain text
#: ../src/Tutorial/Functor.md:864
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"接口 CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:871
#, fuzzy
msgid ""
"We'll now write two implementations of `CSVLine` for `HList`: One for the "
"`Nil` case, which will succeed if and only if the current list of strings is "
"empty. The other for the *cons* case, which will try and read a single field "
"from the head of the list and the remainder from its tail. We use again an "
"idiom bracket to concatenate the results:"
msgstr ""
"现在，我们将为 `HList` 编写 `CSVLine` 的两个实现：一个针对 `Nil` 的情况，当且"
"仅当当前字符串列表为空时才会成功.另一个用于 *cons* 的情况，它将尝试从列表的头"
"部读取单个字段，并从其尾部读取剩余部分。我们再次使用惯用括号来连接结果："

#. type: Plain text
#: ../src/Tutorial/Functor.md:876
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
msgstr ""
"```伊德里斯\n"
"CSVLine (HList []) 其中\n"
"  decodeAt _ _ [] = 右无\n"
"  decodeAt l c _ = Left (ExpectedEndOfInput l c)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:881
#, fuzzy, no-wrap
msgid ""
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
"```\n"
msgstr ""
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) 其中\n"
"  decodeAt l c [] = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:887
#, fuzzy
msgid ""
"And that's it! All we need to add is two utility function for decoding whole "
"lines before they have been split into tokens, one of which is specialized "
"to `HList` and takes an erased list of types as argument to make it more "
"convenient to use at the REPL:"
msgstr ""
"就是这样！我们需要添加的是两个实用函数，用于在将整行拆分为标记之前对其进行解"
"码，其中一个专用于 `HList` 并将已擦除的类型列表作为参数，以使其更方便使用在 "
"REPL："

#. type: Plain text
#: ../src/Tutorial/Functor.md:891
#, fuzzy
msgid ""
"```idris decode : CSVLine a => (line : Nat) -> String -> Either CSVError a "
"decode line = decodeAt line 1 . forget . split (',' ==)"
msgstr ""
"```idris decode : CSVLine a => (line : Nat) -> String -> Either CSVError a "
"decode line = decodeAt line 1 。忘记 。拆分 (',' ==)"

#. type: Plain text
#: ../src/Tutorial/Functor.md:899
#, fuzzy, no-wrap
msgid ""
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"
"```\n"
msgstr ""
"hdecode : (0 ts : 列表类型)\n"
"        -> CSVLine (HList ts)\n"
"        =>（行：Nat）\n"
"        -> 字符串\n"
"        -> CSVError (HList ts)\n"
"hdecode _ = 解码\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:902
#, fuzzy
msgid ""
"It's time to reap the fruits of our labour and give this a go at the REPL:"
msgstr "是时候收获我们的劳动成果并在 REPL 上试一试了："

#. type: Plain text
#: ../src/Tutorial/Functor.md:909
#, fuzzy
msgid ""
"```repl Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\" Right "
"[False, 100, 12.123] Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,"
"f\" Left (FieldError 3 2 \"\")  ```"
msgstr ""
"```repl Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\" 对 "
"[False, 100, 12.123] Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,"
"f \" 左 (FieldError 3 2 \"\") ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:911
#, fuzzy
msgid "### Applicative Laws"
msgstr "### 适用法律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:914
#, fuzzy
msgid ""
"Again, `Applicative` implementations must follow certain laws. Here they are:"
msgstr "同样，`Applicative` 的实现必须遵循一定的规律。他们来了："

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:917
#, fuzzy
msgid ""
"`pure id <*> fa = fa`: Lifting and applying the identity function has no "
"visible effect."
msgstr "`pure id <*> fa = fa`：提升和应用恒等函数没有可见效果。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:922
#, fuzzy
msgid ""
"`[| f . g |] <*> v = f <*> (g <*> v)`: I must not matter, whether we compose "
"our functions first and then apply them, or whether we apply our functions "
"first and then compose them."
msgstr ""
"`[| F 。 g |] <*> v = f <*> (g <*> v)`：不管是先组合函数然后应用它们，还是先"
"应用函数然后组合它们."

#. type: Plain text
#: ../src/Tutorial/Functor.md:925
#, fuzzy, no-wrap
msgid ""
"  The above might be hard to understand, so here\n"
"  they are again with explicit types and implementations:\n"
msgstr ""
"  上面的可能很难理解，所以这里\n"
"  它们再次具有显式类型和实现：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:929
#, fuzzy, no-wrap
msgid ""
"  ```idris\n"
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
msgstr ""
"  ```伊德里斯\n"
"  compL : 也许 (b -> c) -> 也许 (a -> b) -> 也许 a -> 也许 c\n"
"  compL f g v = [| F 。 g |] <*> v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:933
#, fuzzy, no-wrap
msgid ""
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"
"  ```\n"
msgstr ""
"  compR : 也许 (b -> c) -> 也许 (a -> b) -> 也许 a -> 也许 c\n"
"  compR f g v = f <*> (g <*> v)\n"
"  ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:936
#, fuzzy, no-wrap
msgid ""
"  The second applicative law states, that the two implementations\n"
"  `compL` and `compR` should behave identically.\n"
msgstr ""
"  第二个适用法律规定，这两个实施\n"
"  `compL` 和 `compR` 的行为应该相同。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:939
#, fuzzy
msgid ""
"`pure f <*> pure x = pure (f x)`. This is also called the *homomorphism* "
"law. It should be pretty self-explaining."
msgstr ""
"`纯 f <*> 纯 x = 纯 (f x)`。这也称为 * 同态 * 定律。这应该是不言自明的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:942
#, fuzzy
msgid ""
"`f <*> pure v = pure ($ v) <*> f`. This is called the law of *interchange*."
msgstr "`f <*> 纯 v = 纯 ($ v) <*> f`。这称为*交换*定律。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:944
#, fuzzy, no-wrap
msgid "  This should again be explained with a concrete example:\n"
msgstr "  这应该再次用一个具体的例子来解释：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:948
#, fuzzy, no-wrap
msgid ""
"  ```idris\n"
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
msgstr ""
"  ```伊德里斯\n"
"  interL : 也许 (a -> b) -> a -> 也许 b\n"
"  interL f v = f <*> 纯 v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:952
#, fuzzy, no-wrap
msgid ""
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"
"  ```\n"
msgstr ""
"  interR : 也许 (a -> b) -> a -> 也许 b\n"
"  interR f v = 纯 ($ v) <*> f\n"
"  ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:957
#, fuzzy, no-wrap
msgid ""
"  Note, that `($ v)` has type `(a -> b) -> b`, so this\n"
"  is a function type being applied to `f`, which has\n"
"  a function of type `a -> b` wrapped in a `Maybe`\n"
"  context.\n"
msgstr ""
"  注意，`($ v)` 的类型是 `(a -> b) -> b`，所以这个\n"
"  是应用于 `f` 的函数类型，它有\n"
"  `a -> b` 类型的函数，包裹在 `Maybe` 中\n"
"  语境。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:961
#, fuzzy, no-wrap
msgid ""
"  The law of interchange states that it must not matter\n"
"  whether we apply a pure value from the left or\n"
"  right of the *apply* operator.\n"
msgstr ""
"  交换定律指出，它必须无关紧要\n"
"  我们是从左边应用一个纯值还是\n"
"  *apply* 运算符的右侧。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:965
#, fuzzy
msgid "Implement `Applicative'` for `Either e` and `Identity`."
msgstr "为 ` 或 ` 和 `Identity` 实现 `Applicative'`。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:970
#, fuzzy
msgid ""
"Implement `Applicative'` for `Vect n`. Note: In order to implement `pure`, "
"the length must be known at runtime.  This can be done by passing it as an "
"unerased implicit to the interface implementation:"
msgstr ""
"为 `Vect n` 实现 `Applicative'`。注意：为了实现 `pure`，必须在运行时知道长"
"度。这可以通过将其作为未擦除的隐式传递给接口实现来完成："

#. type: Plain text
#: ../src/Tutorial/Functor.md:974
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   implementation {n : _} -> Applicative' (Vect n) where\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   实现 {n : _} -> Applicative' (Vect n) 其中\n"
"   ```\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:977
#, fuzzy
msgid ""
"Implement `Applicative'` for `Pair e`, with `e` having a `Monoid` constraint."
msgstr "为 `Pair e` 实现 `Applicative'`，其中 `e` 具有 `Monoid` 约束。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:980
#, fuzzy
msgid ""
"Implement `Applicative` for `Const e`, with `e` having a `Monoid` constraint."
msgstr "为 `Const e` 实现 `Applicative`，其中 `e` 具有 `Monoid` 约束。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:985
#, fuzzy
msgid ""
"Implement `Applicative` for `Validated e`, with `e` having a `Semigroup` "
"constraint. This will allow us to use `(<+>)` to accumulate errors in case "
"of two `Invalid` values in the implementation of *apply*."
msgstr ""
"为 `Validated e` 实现 `Applicative`，其中 `e` 具有 `Semigroup` 约束。这将允许"
"我们在 *apply* 的实现中使用 `(<+>)` 来累积两个 `Invalid` 值的错误。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:990
#, fuzzy
msgid ""
"Add an additional data constructor of type `CSVError -> CSVError -> "
"CSVError` to `CSVError` and use this to implement `Semigroup` for `CSVError`."
msgstr ""
"添加一个 `CSVError -> CSVError -> CSVError` 到 `CSVError` 类型的附加数据构造"
"函数，并使用它为 `CSVError` 实现 `Semigroup`。"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:994
#, fuzzy
msgid ""
"Refactor our CSV-parsers and all related functions so that they return "
"`Validated` instead of `Either`. This will only work, if you solved exercise "
"6."
msgstr ""
"重构我们的 CSV 解析器和所有相关函数，使它们返回 `Validated` 而不是 `Either`。"
"这只有在你解决了练习 6 的情况下才有效。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1000
#, fuzzy, no-wrap
msgid ""
"   Two things to note: You will have to adjust very little of\n"
"   the existing code, as we can still use applicative syntax\n"
"   with `Validated`. Also, with this change, we enhanced our CSV-parsers\n"
"   with the ability of error accumulation. Here are some examples\n"
"   from a REPL session:\n"
msgstr ""
"   需要注意的两件事：您将不得不调整很少的\n"
"   现有代码，因为我们仍然可以使用应用语法\n"
"   使用 ` 验证 `。此外，通过此更改，我们增强了 CSV 解析器\n"
"   具有累积误差的能力。这里有些例子\n"
"   来自 REPL 会话：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1010
#, fuzzy, no-wrap
msgid ""
"   ```repl\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
"   ```\n"
msgstr ""
"   ```repl\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   有效[真，12，女]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   无效 (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   无效（应用程序（FieldError 1 1“o”）\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1015
#, fuzzy, no-wrap
msgid ""
"   Behold the power of applicative functors and heterogeneous lists: With\n"
"   only a few lines of code we wrote a pure, type-safe, and total\n"
"   parser with error accumulation for lines in CSV-files, which is\n"
"   very convenient to use at the same time!\n"
msgstr ""
"   看看应用函子和异构列表的力量：\n"
"   仅仅几行代码，我们就编写了一个纯粹的、类型安全的、完全的\n"
"   对 CSV 文件中的行进行错误累积的解析器，即\n"
"   同时使用非常方便！\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Functor.md:1018
#, fuzzy
msgid ""
"Since we introduced heterogeneous lists in this chapter, it would be a pity "
"not to experiment with them a little."
msgstr "由于我们在本章中介绍了异构列表，很遗憾没有对它们进行一些实验。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1027
#, fuzzy, no-wrap
msgid ""
"   This exercise is meant to sharpen your skills in type wizardry.\n"
"   It therefore comes with very few hints. Try to decide yourself\n"
"   what behavior you'd expect from a given function, how to express\n"
"   this in the types, and how to implement it afterwards.\n"
"   If your types are correct and precise enough, the implementations\n"
"   will almost come for free. Don't give up too early if you get stuck.\n"
"   Only if you truly run out of ideas should you have a glance\n"
"   at the solutions (and then, only at the types at first!)\n"
msgstr ""
"   这个练习旨在提高你的字体魔法技能。\n"
"   因此，它带有很少的提示。试着自己做决定\n"
"   您期望从给定函数中获得什么行为，如何表达\n"
"   这在类型中，以及之后如何实现它。\n"
"   如果您的类型足够正确和精确，那么实现\n"
"   几乎是免费的。如果遇到困难，不要过早放弃。\n"
"   只有当你真的没有想法时，你才应该瞥一眼\n"
"   在解决方案上（然后，首先只在类型上！）\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1029
#, fuzzy
msgid "Implement `head` for `HList`."
msgstr "为 `HList` 实现 `head`。"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1031
#, fuzzy
msgid "Implement `tail` for `HList`."
msgstr "为 `HList` 实现 `tail`。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1033
#, fuzzy
msgid "Implement `(++)` for `HList`."
msgstr "为 `HList` 实现 `(++)`。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1037
#, fuzzy
msgid ""
"Implement `index` for `HList`. This might be harder than the other three.  "
"Go back and look how we implemented `indexList` in an [earlier exercise]"
"(Dependent.md) and start from there."
msgstr ""
"为 `HList` 实现 `index`。这可能比其他三个更难。回过头来看看我们如何在 [早期练"
"习](Dependent.md) 中实现 `indexList` 并从那里开始。"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1043
#, fuzzy
msgid ""
"Package *contrib*, which is part of the Idris project, provides `Data.HVect."
"HVect`, a data type for heterogeneous vectors. The only difference to our "
"own `HList` is, that `HVect` is indexed over a vector of types instead of a "
"list of types. This makes it easier to express certain operations at the "
"type level."
msgstr ""
"包 *contrib* 是 Idris 项目的一部分，它提供了 `Data.HVect.HVect`，一种异构向量"
"的数据类型。与我们自己的 `HList` 的唯一区别是，`HVect` 是通过类型向量而不是类"
"型列表来索引的。这使得在类型级别表达某些操作变得更容易。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1046
#, fuzzy, no-wrap
msgid ""
"      Write your own implementation of `HVect` together with functions\n"
"      `head`, `tail`, `(++)`, and `index`.\n"
msgstr ""
"      编写您自己的 `HVect` 实现以及函数\n"
"      `头`、`尾`、`(++)`和`索引`。\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1050
#, fuzzy
msgid ""
"For a real challenge, try implementing a function for transposing a `Vect m "
"(HVect ts)`. You'll first have to be creative about how to even express this "
"in the types."
msgstr ""
"对于真正的挑战，尝试实现一个函数来转置 `Vect m (HVect ts)`。您首先必须对如何"
"在类型中表达这一点有创意。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1057
#, fuzzy, no-wrap
msgid ""
"      Note: In order to implement this, you'll need to pattern match\n"
"      on an erased argument in at least one case to help Idris with\n"
"      type inference. Pattern matching on erased arguments is forbidden\n"
"      (they are erased after all, so we can't inspect them at runtime),\n"
"      *unless* the structure of the value being matched on can be derived\n"
"      from another, un-erased argument.\n"
msgstr ""
"      注意：为了实现这一点，您需要进行模式匹配\n"
"      在至少一个案例中的一个被抹去的论点上，以帮助伊德里斯\n"
"      类型推断。禁止对已擦除参数进行模式匹配\n"
"      （它们毕竟被删除了，所以我们不能在运行时检查它们），\n"
"      *除非*可以推导出被匹配的值的结构\n"
"      来自另一个未被抹去的论点。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1061
#, fuzzy, no-wrap
msgid ""
"      Also, don't worry if you get stuck on this one. It took me several\n"
"      tries to figure it out. But I enjoyed the experience, so I just *had*\n"
"      to include it here. :-)\n"
msgstr ""
"      另外，如果您卡在这个上，请不要担心。我花了好几个\n"
"      试图弄清楚。但是我很享受这种体验，所以我只是*有*\n"
"      把它包括在这里。 :-)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1065
#, fuzzy, no-wrap
msgid ""
"      Note, however, that such a function might be useful when working with\n"
"      CSV-files, as it allows us to convert a table represented as\n"
"      rows (a vector of tuples) to one represented as columns (a tuple of vectors).\n"
msgstr ""
"      但是请注意，这样的功能在使用\n"
"      CSV 文件，因为它允许我们转换表示为的表\n"
"      行（元组向量）到表示为列（向量元组）的行。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Functor.md:1069
#, fuzzy
msgid ""
"Show, that the composition of two applicative functors is again an "
"applicative functor by implementing `Applicative` for `Comp f g`."
msgstr ""
"通过为 `Comp f g` 实现 `Applicative` 来证明两个应用函子的组合再次是一个应用函"
"子。"

#. type: Bullet: '10. '
#: ../src/Tutorial/Functor.md:1073
#, fuzzy
msgid ""
"Show, that the product of two applicative functors is again an applicative "
"functor by implementing `Applicative` for `Prod f g`."
msgstr ""
"通过为 `Prod f g` 实现 `Applicative` 证明两个应用函子的乘积再次是一个应用函"
"子。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1075
#, fuzzy
msgid "## Monad"
msgstr "## 单子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1081
#, fuzzy
msgid ""
"Finally, `Monad`. A lot of ink has been spilled about this one.  However, "
"after what we already saw in the [chapter about `IO`](IO.md), there is not "
"much left to discuss here. `Monad` extends `Applicative` and adds two new "
"related functions: The *bind* operator (`(>>=)`) and function `join`. Here "
"is its definition:"
msgstr ""
"最后，`Monad`。关于这一点已经泼了很多墨水。然而，在我们已经在 [关于 `IO`](IO."
"md) 的章节中看到之后，这里就没有太多要讨论的内容了。 `Monad` 扩展了 "
"`Applicative` 并添加了两个新的相关函数：*bind* 运算符 (`(>>=)`) 和函数 `join "
"`。这是它的定义："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1087
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"接口 Applicative' m => Monad' m 其中\n"
"  绑定：m a -> (a -> m b) -> m b\n"
"  加入' : m (m a) -> m a\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1091
#, fuzzy
msgid ""
"Implementers of `Monad` are free to choose to either implement `(>>=)` or "
"`join` or both. You will show in an exercise, how `join` can be implemented "
"in terms of *bind* and vice versa."
msgstr ""
"`Monad` 的实现者可以自由选择实现 `(>>=)` 或 `join` 或两者。您将在练习中展示如"
"何根据 *bind* 来实现 `join`，反之亦然。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1099
#, fuzzy
msgid ""
"The big difference between `Monad` and `Applicative` is, that the former "
"allows a computation to depend on the result of an earlier computation. For "
"instance, we could decide based on a string read from standard input whether "
"to delete a file or play a song. The result of the first `IO` action "
"(reading some user input) will affect, which `IO` action to run next.  This "
"is not possible with the *apply* operator:"
msgstr ""
"`Monad` 和 `Applicative` 之间的最大区别在于，前者允许计算依赖于早期计算的结"
"果。例如，我们可以根据从标准输入中读取的字符串来决定是删除文件还是播放歌曲。"
"第一个 `IO` 动作（读取一些用户输入）的结果将影响下一个要运行的 `IO` 动作。这"
"对于 *apply* 运算符是不可能的："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1103
#, fuzzy
msgid "```repl (<*>) : IO (a -> b) -> IO a -> IO b ```"
msgstr "```repl (<*>) : IO (a -> b) -> IO a -> IO b ```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1115
#, fuzzy
msgid ""
"The two `IO` actions have already been decided on when they are being passed "
"as arguments to `(<*>)`. The result of the first cannot - in the general "
"case - affect which computation to run in the second. (Actually, with `IO` "
"this would theoretically be possible via side effects: The first action "
"could write some command to a file or overwrite some mutable state, and the "
"second action could read from that file or state, thus deciding on the next "
"thing to do. But this is a speciality of `IO`, not of applicative functors "
"in general. If the functor in question was `Maybe`, `List`, or `Vector`, no "
"such thing would be possible.)"
msgstr ""
"两个 `IO` 动作在作为参数传递给 `(<*>)` 时已经确定。在一般情况下，第一个结果不"
"能影响在第二个中运行哪个计算。 （实际上，使用 `IO` 理论上可以通过副作用实现："
"第一个操作可以将某些命令写入文件或覆盖某些可变状态，而第二个操作可以从该文件"
"或状态读取，从而决定接下来要做的事情。但这是 `IO` 的特长，而不是一般的应用函"
"子。如果有问题的函子是 `Maybe`，`List`，或 `Vector`，这是不可能的。）"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1121
#, fuzzy
msgid ""
"Let's demonstrate the difference with an example. Assume we'd like to "
"enhance our CSV-reader with the ability to decode a line of tokens to a sum "
"type. For instance, we'd like to decode CRUD requests from the lines of a "
"CSV-file:"
msgstr ""
"让我们用一个例子来演示一下区别。假设我们想增强我们的 CSV 阅读器，使其能够将一"
"行标记解码为 sum 类型。例如，我们想从 CSV 文件的行中解码 CRUD 请求："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1129
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"数据 Crud : (i : Type) -> (a : Type) -> Type where\n"
"  创建：（值：a）-> Crud i a\n"
"  更新：（id：i）->（value：a）-> Crud i a\n"
"  阅读：（id：i）-> Crud i a\n"
"  删除 : (id : i) -> Crud i a\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1134
#, fuzzy
msgid ""
"We need a way to on each line decide, which data constructor to choose for "
"our decoding. One way to do this is to put the name of the data constructor "
"(or some other tag of identification) in the first column of the CSV-file:"
msgstr ""
"我们需要一种方法来在每一行上决定为我们的解码选择哪个数据构造函数。一种方法是"
"将数据构造函数的名称（或其他标识标签）放在 CSV 文件的第一列中："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1138
#, fuzzy
msgid "```idris hlift : (a -> b) -> HList [a] -> b hlift f [x] = f x"
msgstr "```idris hlift : (a -> b) -> HList [a] -> b hlift f [x] = f x"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1141
#, fuzzy
msgid "hlift2 : (a -> b -> c) -> HList [a,b] -> c hlift2 f [x,y] = f x y"
msgstr "hlift2 : (a -> b -> c) -> HList [a,b] -> c hlift2 f [x,y] = f x y"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1158
#, fuzzy, no-wrap
msgid ""
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"
"```\n"
msgstr ""
"decodeCRUD : CSV 字段我\n"
"           => CSV 字段\n"
"           =>（行：Nat）\n"
"           ->（s：字符串）\n"
"           -> CSVError (Crud i a)\n"
"解码CRUD l s =\n"
"  让 h ::: t = split (',' ==) s\n"
"   在做\n"
"     MkName n <- readField l 1 h\n"
"     案例 n 的\n"
"       “创建” => hlift 创建 <$> decodeAt l 2 t\n"
"       “更新” => hlift2 更新 <$> decodeAt l 2 t\n"
"       \"Read\" => hlift Read <$> decodeAt l 2 t\n"
"       “删除” => hlift 删除 <$> decodeAt l 2 t\n"
"       _ => 左 (FieldError l 1 n)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1164
#, fuzzy
msgid ""
"I added two utility function for helping with type inference and to get "
"slightly nicer syntax. The important thing to note is, how we pattern match "
"on the result of the first parsing function to decide on the data "
"constructor and thus the next parsing function to use."
msgstr ""
"我添加了两个实用函数来帮助进行类型推断并获得更好的语法。需要注意的重要一点"
"是，我们如何对第一个解析函数的结果进行模式匹配，以决定数据构造函数，从而决定"
"下一个要使用的解析函数。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1166
#, fuzzy
msgid "Here's how this works at the REPL:"
msgstr "以下是 REPL 的工作原理："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1175
#, fuzzy
msgid ""
"```repl Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,"
"jon@doe.ch\" Right (Create (MkEmail \"jon@doe.ch\"))  Tutorial.Functor> "
"decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\" Right (Update "
"12 (MkEmail \"jane@doe.ch\"))  Tutorial.Functor> decodeCRUD {i = Nat} {a = "
"Email} 1 \"Delete,jon@doe.ch\" Left (FieldError 1 2 \"jon@doe.ch\")  ```"
msgstr ""
"```repl Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,"
"jon@doe.ch\" Right (Create (MkEmail \"jon@doe.ch\")) Tutorial.Functor> "
"decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\" Right (Update "
"12 (MkEmail \"jane@doe.ch\")) Tutorial.Functor> decodeCRUD {i = Nat} {a = "
"Email} 1“删除，jon@doe.ch”左（FieldError 1 2“jon@doe.ch”）```"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1184
#, fuzzy
msgid ""
"To conclude, `Monad`, unlike `Applicative`, allows us to chain computations "
"sequentially, where intermediary results can affect the behavior of later "
"computations.  So, if you have n unrelated effectful computations and want "
"to combine them under a pure, n-ary function, `Applicative` will be "
"sufficient. If, however, you want to decide based on the result of an "
"effectful computation what computation to run next, you need a `Monad`."
msgstr ""
"总而言之，`Monad` 与 `Applicative` 不同，它允许我们按顺序链接计算，其中中间结"
"果会影响后续计算的行为。因此，如果您有 n 个不相关的有效计算并希望将它们组合在"
"一个纯 n 元函数下，`Applicative` 就足够了。但是，如果您想根据有效计算的结果来"
"决定接下来要运行什么计算，则需要 `Monad`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1190
#, fuzzy
msgid ""
"Note, however, that `Monad` has one important drawback compared to "
"`Applicative`: In general, monads don't compose.  For instance, there is no "
"`Monad` instance for `Either e . IO`.  We will later learn about monad "
"transformers, which can be composed with other monads."
msgstr ""
"但是请注意，与 `Applicative` 相比，`Monad` 有一个重要的缺点：通常，monad 不会"
"组合。例如， `Either e 没有 `Monad` 实例。 IO`。稍后我们将了解可以与其他 "
"monad 组合的 monad 转换器。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1192
#, fuzzy
msgid "### Monad Laws"
msgstr "### 单子定律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1194
#, fuzzy
msgid "Without further ado, here are the laws for `Monad`:"
msgstr "事不宜迟，以下是 `Monad` 的定律："

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1198
#, fuzzy
msgid ""
"`ma >>= pure = ma` and `pure v >>= f = f v`.  These are monad's identity "
"laws. Here they are as concrete examples:"
msgstr ""
"`ma >>= pure = ma` 和 `pure v >>= f = f v`。这些是 monad 的恒等律。下面是具体"
"的例子："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1202
#, fuzzy, no-wrap
msgid ""
"  ```idris\n"
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
msgstr ""
"  ```伊德里斯\n"
"  id1L : 也许一个 -> 也许一个\n"
"  id1L ma = ma >>= 纯\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1205
#, fuzzy, no-wrap
msgid ""
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
msgstr ""
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = 纯 v >>= f\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1209
#, fuzzy, no-wrap
msgid ""
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"
"  ```\n"
msgstr ""
"  id2R : a -> (a -> 也许 b) -> 也许 b\n"
"  id2R v f = f v\n"
"  ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1212
#, fuzzy, no-wrap
msgid ""
"  These two laws state that `pure` should behave\n"
"  neutrally w.r.t. *bind*.\n"
msgstr ""
"  这两条定律规定 `pure` 应该表现\n"
"  中立地w.r.t. *绑定*。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1218
#, fuzzy
msgid ""
"(m >>= f) >>= g = m >>= (f >=> g)  This is the law of associativity for "
"monad.  You might not have seen the second operator `(>=>)`.  It can be used "
"to sequence effectful computations and has the following type:"
msgstr ""
"(m >>= f) >>= g = m >>= (f >=> g) 这是 monad 的结合律。您可能没有见过第二个运"
"算符 `(>=>)`。它可用于对有效计算进行排序，并具有以下类型："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1223
#, fuzzy, no-wrap
msgid ""
"  ```repl\n"
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
"  ```\n"
msgstr ""
"  ```repl\n"
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
"  ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1229
#, fuzzy
msgid ""
"The above are the *official* monad laws. However, we need to consider a "
"third one, given that in Idris (and Haskell)  `Monad` extends `Applicative`: "
"As `(<*>)` can be implemented in terms of `(>>=)`, the actual implementation "
"of `(<*>)` must behave the same as the implementation in terms of `(>>=)`:"
msgstr ""
"以上是 * 官方的* monad 法则。但是，我们需要考虑第三个，因为在 Idris（和 "
"Haskell）中，`Monad` extends `Applicative`: As `(<*>)` 可以在就 `(>>=)` 而"
"言，`(<*>)` 的实际实现必须与 `(>>=)` 的实现表现相同："

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1231
#, fuzzy
msgid "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`."
msgstr "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:1237
#, fuzzy
msgid ""
"`Applicative` extends `Functor`, because every `Applicative` is also a "
"`Functor`. Proof this by implementing `map` in terms of `pure` and `(<*>)`."
msgstr ""
"`Applicative` 扩展了 `Functor`，因为每个 `Applicative` 也是一个 `Functor`。通"
"过根据 `pure` 和 `(<*>)` 实现 `map` 来证明这一点。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:1241
#, fuzzy
msgid ""
"`Monad` extends `Applicative`, because every `Monad` is also an "
"`Applicative`. Proof this by implementing `(<*>)` in terms of `(>>=)` and "
"`pure`."
msgstr ""
"`Monad` 扩展了 `Applicative`，因为每个 `Monad` 也是一个 `Applicative`。通过根"
"据 `(>>=)` 和 `pure` 实现 `(<*>)` 来证明这一点。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:1244
#, fuzzy
msgid ""
"Implement `(>>=)` in terms of `join` and other functions in the `Monad` "
"hierarchy."
msgstr "根据 `join` 和 `Monad` 层次结构中的其他函数实现 `(>>=)`。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:1247
#, fuzzy
msgid ""
"Implement `join` in terms of `(>>=)` and other functions in the `Monad` "
"hierarchy."
msgstr "根据 `(>>=)` 和 `Monad` 层次结构中的其他函数实现 `join`。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:1250
#, fuzzy
msgid "There is no lawful `Monad` implementation for `Validated e`.  Why?"
msgstr "`Validated e` 没有合法的 `Monad` 实现。为什么？"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:1256
#, fuzzy
msgid ""
"In this slightly extended exercise, we are going to simulate CRUD operations "
"on a data store. We will use a mutable reference (imported from `Data.IORef` "
"from the *base* library)  holding a list of `User`s paired with a unique ID "
"of type `Nat` as our user data base:"
msgstr ""
"在这个稍微扩展的练习中，我们将在数据存储上模拟 CRUD 操作。我们将使用一个可变"
"引用（从 *base* 库中的 `Data.IORef` 导入），其中包含一个 `User` 列表和一个 "
"[X238X 类型的唯一 ID ]Nat` 作为我们的用户数据库："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1261
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   数据库：类型\n"
"   DB = IORef（列表（Nat，用户））\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1267
#, fuzzy, no-wrap
msgid ""
"   Most operations on a database come with a risk of failure:\n"
"   When we try to update or delete a user, the entry in question\n"
"   might no longer be there. When we add a new user, a user\n"
"   with the given email address might already exist. Here is\n"
"   a custom error type to deal with this:\n"
msgstr ""
"   数据库上的大多数操作都有失败的风险：\n"
"   当我们尝试更新或删除用户时，有问题的条目\n"
"   可能不再存在。当我们添加一个新用户时，一个用户\n"
"   与给定的电子邮件地址可能已经存在。这是\n"
"   处理此问题的自定义错误类型：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1274
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   数据 DBError : 键入 where\n"
"     UserExists : 电子邮件 -> Nat -> DBError\n"
"     UserNotFound : Nat -> DBError\n"
"     SizeLimitExceeded：DBError\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1277
#, fuzzy, no-wrap
msgid ""
"   In general, our functions will therefore have a\n"
"   type similar to the following:\n"
msgstr ""
"   一般来说，我们的函数因此会有一个\n"
"   键入类似于以下内容：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1281
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   someDBProg : arg1 -> arg2 -> DB -> IO (DBError a)\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1284
#, fuzzy, no-wrap
msgid ""
"   We'd like to abstract over this, by introducing a new wrapper\n"
"   type:\n"
msgstr ""
"   我们想通过引入一个新的包装器来抽象这个\n"
"   类型：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1290
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   记录 Prog a where\n"
"     构造函数 MkProg\n"
"     runProg : DB -> IO (DBError a)\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1294
#, fuzzy, no-wrap
msgid ""
"   We are now ready to write us some utility functions. Make sure\n"
"   to follow the following business rules when implementing the\n"
"   functions below:\n"
msgstr ""
"   我们现在准备为我们编写一些实用函数。确保\n"
"   在实施时遵循以下业务规则\n"
"   以下功能：\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1297
#, fuzzy
msgid ""
"Email addresses in the DB must be unique. (Consider implementing `Eq Email` "
"to verify this)."
msgstr ""
"数据库中的电子邮件地址必须是唯一的。 （考虑实现 `Eq Email` 来验证这一点）。"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1299
#, fuzzy
msgid "The size limit of 1000 entries must not be exceeded."
msgstr "不得超过 1000 个条目的大小限制。"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1303
#, fuzzy
msgid ""
"Operations trying to lookup a user by their ID must fail with `UserNotFound` "
"in case no entry was found in the DB."
msgstr ""
"如果在 DB 中找不到条目，则尝试通过 ID 查找用户的操作必须失败并显示 "
"`UserNotFound`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1308
#, fuzzy, no-wrap
msgid ""
"   You'll need the following functions from `Data.IORef` when working\n"
"   with mutable references: `newIORef`, `readIORef`, and `writeIORef`.\n"
"   In addition, functions `Data.List.lookup` and `Data.List.find` might\n"
"   be useful to implement some of the functions below.\n"
msgstr ""
"   工作时需要 `Data.IORef` 中的以下功能\n"
"   具有可变引用：`newIORef`、`readIORef` 和 `writeIORef`。\n"
"   此外，函数 `Data.List.lookup` 和 `Data.List.find` 可能\n"
"   对实现以下某些功能很有用。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1310
#, fuzzy
msgid "Implement interfaces `Functor`, `Applicative`, and `Monad` for `Prog`."
msgstr "为 `Prog` 实现接口 `Functor`、`Applicative` 和 `Monad`。"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1312
#, fuzzy
msgid "Implement interface `HasIO` for `Prog`."
msgstr "为 `Prog` 实现接口 `HasIO`。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1314
#, fuzzy
msgid "Implement the following utility functions:"
msgstr "实现以下实用功能："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1317
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"
msgstr ""
"      ```伊德里斯\n"
"      抛出：DBError -> Prog a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1319
#, fuzzy, no-wrap
msgid "      getUsers : Prog (List (Nat,User))\n"
msgstr "      getUsers : Prog (列表 (Nat,User))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1322
#, fuzzy, no-wrap
msgid ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"
msgstr ""
"      -- 检查大小限制！\n"
"      putUsers : 列表 (Nat,User) -> Prog ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1326
#, fuzzy, no-wrap
msgid ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"
msgstr ""
"      -- 用 `getUsers` 和 `putUsers` 来实现\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1330
#, fuzzy
msgid ""
"Implement function `lookupUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found."
msgstr ""
"实现函数`lookupUser`。如果找不到具有给定 ID 的用户，这应该会失败并出现适当的"
"错误。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1334
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1339
#, fuzzy
msgid ""
"Implement function `deleteUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found. Make use of `lookupUser` in "
"your implementation."
msgstr ""
"实现函数`deleteUser`。如果找不到具有给定 ID 的用户，这应该会失败并出现适当的"
"错误。在您的实现中使用 `lookupUser`。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1343
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1349
#, fuzzy
msgid ""
"Implement function `addUser`. This should fail, if a user with the given "
"`Email` already exists, or if the data banks size limit of 1000 entries is "
"exceeded.  In addition, this should create and return a unique ID for the "
"new user entry."
msgstr ""
"实现函数`addUser`。如果具有给定 `Email` 的用户已经存在，或者超过了 1000 个条"
"目的数据库大小限制，这应该会失败。此外，这应该为新用户条目创建并返回一个唯一 "
"ID。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1353
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Functor.md:1358
#, fuzzy
msgid ""
"Implement function `updateUser`. This should fail, if the user in question "
"cannot be found or a user with the updated user's `Email` already exists.  "
"The returned value should be the updated user."
msgstr ""
"实现函数`updateUser`。如果找不到相关用户或更新用户的 `Email` 的用户已经存在，"
"这应该会失败。返回的值应该是更新的用户。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1362
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   8. '
#: ../src/Tutorial/Functor.md:1366
#, fuzzy
msgid ""
"Data type `Prog` is actually too specific. We could just as well abstract "
"over the error type and the `DB` environment:"
msgstr "数据类型 `Prog` 实际上太具体了。我们也可以抽象出错误类型和 `DB` 环境："

#. type: Plain text
#: ../src/Tutorial/Functor.md:1372
#, fuzzy, no-wrap
msgid ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"
msgstr ""
"      ```伊德里斯\n"
"      记录 Prog' env 错误的地方\n"
"        构造函数 MkProg\n"
"        runProg' : env -> IO (要么错误 a)\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1378
#, fuzzy, no-wrap
msgid ""
"      Verify, that all interface implementations you wrote\n"
"      for `Prog` can be used verbatim to implement the same\n"
"      interfaces for `Prog' env err`. The same goes for\n"
"      `throw` with only a slight adjustment in the function's\n"
"      type.\n"
msgstr ""
"      验证您编写的所有接口实现\n"
"      对于 `Prog` 可以逐字使用来实现相同的\n"
"      `Prog' env err` 的接口。这同样适用于\n"
"      `throw` 只需稍微调整函数的\n"
"      类型。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1380
#, fuzzy
msgid "## Background and further Reading"
msgstr "## 背景和延伸阅读"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1388
#, fuzzy
msgid ""
"Concepts like *functor* and *monad* have their origin in *category theory*, "
"a branch of mathematics. That is also where their laws come from.  Category "
"theory was found to have applications in programming language theory, "
"especially functional programming.  It is a highly abstract topic, but there "
"is a pretty accessible introduction for programmers, written by [Bartosz "
"Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-"
"programmers-the-preface/)."
msgstr ""
"*functor* 和 *monad* 等概念起源于数学分支 * 范畴论*。这也是他们的法律的来源。"
"范畴理论被发现在程序设计语言理论，特别是函数式程序设计中有应用。这是一个高度"
"抽象的主题，但有一个非常容易理解的程序员介绍，由 [Bartosz Milewski] (https://"
"bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-"
"preface/ ）。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1394
#, fuzzy
msgid ""
"The usefulness of applicative functors as a middle ground between functor "
"and monad was discovered several years after monads had already been in use "
"in Haskell. They where introduced in the article [*Applicative Programming "
"with Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html), "
"which is freely available online and a highly recommended read."
msgstr ""
"应用函子作为函子和单子之间的中间地带的有用性是在单子已经在 Haskell 中使用几年"
"之后才发现的。它们在文章 [*Applicative Programming with Effects*](https://"
"www.staff.city.ac.uk/~ross/papers/Applicative.html) 中进行了介绍，该文章可在"
"线免费获得，并且强烈推荐阅读。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1401
#, fuzzy
msgid ""
"Interfaces `Functor`, `Applicative`, and `Monad` abstract over programming "
"patterns that come up when working with type constructors of type `Type -> "
"Type`. Such data types are also referred to as *values in a context*, or "
"*effectful computations*."
msgstr ""
"接口 `Functor`、`Applicative` 和 `Monad` 抽象了使用 `Type -> Type` 类型的类型"
"构造函数时出现的编程模式。此类数据类型也称为上下文中的 * 值 *，或 * 有效计算 "
"*。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1404
#, fuzzy
msgid ""
"`Functor` allows us to *map* over values in a context without affecting the "
"context's underlying structure."
msgstr "`Functor` 允许我们在上下文中的值上 *map* 而不影响上下文的底层结构。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1407
#, fuzzy
msgid ""
"`Applicative` allows us to apply n-ary functions to n effectful computations "
"and to lift pure values into a context."
msgstr ""
"`Applicative` 允许我们将 n 元函数应用于 n 个有效计算，并将纯值提升到上下文"
"中。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1411
#, fuzzy
msgid ""
"`Monad` allows us to chain effectful computations, where the intermediary "
"results can affect, which computation to run further down the chain."
msgstr ""
"`Monad` 允许我们链接有效的计算，其中中间结果可能会影响，哪些计算在链中运行得"
"更远。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1415
#, fuzzy
msgid ""
"Unlike `Monad`, `Functor` and `Applicative` compose: The product and "
"composition of two functors or applicatives are again functors or "
"applicatives, respectively."
msgstr ""
"与 `Monad` 不同，`Functor` 和 `Applicative` 组合：两个函子或应用程序的乘积和"
"组合再次分别是函子或应用程序。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1419
#, fuzzy
msgid ""
"Idris provides syntactic sugar for working with some of the interfaces "
"presented here: Idiom brackets for `Applicative`, *do blocks* and the bang "
"operator for `Monad`."
msgstr ""
"Idris 为使用此处介绍的一些接口提供了语法糖：`Applicative`、*do blocks* 的成语"
"方括号和 `Monad` 的 bang 运算符。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1421 ../src/Tutorial/Intro.md:431
msgid "### What's next?"
msgstr "### 下一步是什么？"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1425
#, fuzzy
msgid ""
"In the [next chapter](Folds.md) we get to learn more about recursion, "
"totality checking, and an interface for collapsing container types: "
"`Foldable`."
msgstr ""
"在[下一章]（Folds.md）中，我们将了解更多关于递归、总体检查和折叠容器类型的接"
"口：`Foldable`。"
