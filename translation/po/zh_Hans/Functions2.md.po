# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-02 13:19+0800\n"
"PO-Revision-Date: 2022-08-02 13:19+0800\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1320 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1192 ../src/Tutorial/Eq.md:1086
#: ../src/Tutorial/Folds.md:1052 ../src/Tutorial/Functions1.md:525
#: ../src/Tutorial/Functions2.md:925 ../src/Tutorial/Functor.md:1396
#: ../src/Tutorial/Interfaces.md:793 ../src/Tutorial/IO.md:1096
#: ../src/Tutorial/Predicates.md:1359 ../src/Tutorial/Traverse.md:1110
#, fuzzy
msgid "## Conclusion"
msgstr ""
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Functions1.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃ 结论\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, fuzzy
msgid "<!-- vi: filetype=idris2 -->"
msgstr ""
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Functions1.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"<!-- vi: filetype=idris2 -->\n"
"#-#-#-#-#  DataTypes.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:15 ../src/Tutorial/DPair.md:37
#: ../src/Tutorial/Eq.md:20 ../src/Tutorial/Folds.md:33
#: ../src/Tutorial/Functions2.md:21 ../src/Tutorial/Functor.md:27
#: ../src/Tutorial/IO.md:19 ../src/Tutorial/Predicates.md:28
#: ../src/Tutorial/Prim.md:16 ../src/Tutorial/Traverse.md:30
#, fuzzy
msgid "%default total ```"
msgstr ""
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Predicates.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  Traverse.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Eq.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  Folds.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Prim.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```\n"
"#-#-#-#-#  DPair.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"%默认总数```"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:904 ../src/Tutorial/Functions1.md:576
#: ../src/Tutorial/Functions2.md:955 ../src/Tutorial/Interfaces.md:814
#: ../src/Tutorial/IO.md:1119
#, fuzzy
msgid "### What's next"
msgstr ""
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Dependent.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"＃＃＃ 下一步是什么\n"
"#-#-#-#-#  Functions1.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  IO.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:2
msgid "# Functions Part 2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
msgid ""
"So far, we learned about the core features of the Idris language, which it "
"has in common with several other pure, strongly typed programming languages "
"like Haskell: (Higher order) Functions, algebraic data types, pattern "
"matching, parametric polymorphism (generic types and functions), and ad hoc "
"polymorphism (interfaces and constrained functions)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
msgid ""
"In this chapter, we start to dissect Idris functions and their types for "
"real. We learn about implicit arguments, named arguments, as well as erasure "
"and quantities. But first, we'll look at `let` bindings and `where` blocks, "
"which help us implement functions too complex to fit on a single line of "
"code. Let's get started!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:18
msgid "```idris module Tutorial.Functions2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:23
msgid "## Let Bindings and Local Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
msgid ""
"The functions we looked at so far were simple enough to be implemented "
"directly via pattern matching without the need of additional auxiliary "
"functions or variables. This is not always the case, and there are two "
"important language constructs for introducing and reusing new local "
"variables and functions. We'll look at these in two case studies."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:33
msgid "### Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
msgid ""
"In this example, we'd like to calculate the arithmetic mean and the standard "
"deviation of a list of floating point values.  There are several things we "
"need to consider."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
msgid ""
"First, we need a function for calculating the sum of a list of numeric "
"values. The *Prelude* exports function `sum` for this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:46
msgid "```repl Main> :t sum Prelude.sum : Num a => Foldable t => t a -> a ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
msgid ""
"This is - of course - similar to `sumList` from Exercise 10 of the [last "
"section](Interfaces.md), but generalized to all container types with a "
"`Foldable` implementation. We will learn about interface `Foldable` in a "
"later section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
msgid ""
"In order to also calculate the variance, we need to convert every value in "
"the list to a new value, as we have to subtract the mean from every value in "
"the list and square the result. In the previous section's exercises, we "
"defined function `mapList` for this. The *Prelude* - of course - already "
"exports a similar function called `map`, which is again more general and "
"works also like our `mapMaybe` for `Maybe` and `mapEither` for `Either e`. "
"Here's its type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:67
msgid ""
"```repl Main> :t map Prelude.map : Functor f => (a -> b) -> f a -> f b ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
msgid "Interface `Functor` is another one we'll talk about in a later section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
msgid ""
"Finally, we need a way to calculate the length of a list of values. We use "
"function `length` for this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:78
msgid "```repl Main> :t List.length Prelude.List.length : List a -> Nat ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
msgid ""
"Here, `Nat` is the type of natural numbers (unbounded, unsigned integers). "
"`Nat` is actually not a primitive data type but a sum type defined in the "
"*Prelude* with data constructors `Z : Nat` (for zero)  and `S : Nat -> Nat` "
"(for successor). It might seem highly inefficient to define natural numbers "
"this way, but the Idris compiler treats these and several other *number-"
"like* types specially, and replaces them with primitive integers during code "
"generation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
msgid ""
"We are now ready to give the implementation of `mean` a go.  Since this is "
"Idris, and we care about clear semantics, we will quickly define a custom "
"record type instead of just returning a tuple of `Double`s. This makes it "
"clearer, which floating point number corresponds to which statistic entity:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:97
msgid "```idris square : Double -> Double square n = n * n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:103
#, no-wrap
msgid ""
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:111
#, no-wrap
msgid ""
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
msgid "As usual, we first try this at the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:118
msgid ""
"```repl Tutorial.Functions2> stats [2,4,4,4,5,5,7,9] MkStats 5.0 4.0 2.0 ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
msgid ""
"Seems to work, so let's digest this step by step.  We introduce several new "
"local variables (`len`, `mean`, and `variance`), which all will be used more "
"than once in the remainder of the implementation. To do so, we use a `let` "
"binding. This consists of the `let` keyword, followed by one or more "
"variable assignments, followed by the final expression, which has to be "
"prefixed by `in`. Note, that whitespace is significant again: We need to "
"properly align the three variable names. Go ahead, and try out what happens "
"if you remove a space in front of `mean` or `variance`.  Note also, that the "
"alignment of assignment operators `:=` is optional. I do this, since I "
"thinks it helps readability."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
msgid ""
"Let's also quickly look at the different variables and their types. `len` is "
"the length of the list cast to a `Double`, since this is what's needed later "
"on, where we divide other values of type `Double` by the length. Idris is "
"very strict about this: We are not allowed to mix up numeric types without "
"explicit casts. Please note, that in this case Idris is able to *infer* the "
"type of `len` from the surrounding context. `mean` is straight forward: We "
"`sum` up the values stored in the list and divide by the list's length. "
"`variance` is the most involved of the three: We map each item in the list "
"to a new value using an anonymous function to subtract the mean and square "
"the result. We then sum up the new terms and divide again by the number of "
"values."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:151
msgid "### Use Case 2: Simulating a Simple Web Server"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
msgid ""
"In the second use case, we are going to write a slightly larger application. "
"This should give you an idea about how to design data types and functions "
"around some business logic you'd like to implement."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
msgid ""
"Assume we run a music streaming web server, where users can buy whole albums "
"and listen to them online. We'd like to simulate a user connecting to the "
"server and getting access to one of the albums they bought."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
msgid "We first define a bunch of record types:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:168
#, no-wrap
msgid ""
"```idris\n"
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:173
#, no-wrap
msgid ""
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:177 ../src/Tutorial/Functor.md:632
#, fuzzy, no-wrap
msgid ""
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"记录电子邮件在哪里\n"
"  构造函数 MkEmail\n"
"  值：字符串\n"
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:181 ../src/Tutorial/Functor.md:636
#: ../src/Tutorial/Interfaces.md:542
#, fuzzy, no-wrap
msgid ""
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
msgstr ""
"#-#-#-#-#  Functor.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"记录密码在哪里\n"
"  构造函数 MkPassword\n"
"  值：字符串\n"
"#-#-#-#-#  Functions2.md.po (idris 2-tutorial)  #-#-#-#-#\n"
"#-#-#-#-#  Interfaces.md.po (idris 2-tutorial)  #-#-#-#-#\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:189
#, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
msgid ""
"Most of these should be self-explanatory. Note, however, that in several "
"cases (`Email`, `Artist`, `Password`) we wrap a single value in a new record "
"type. Of course, we *could* have used the unwrapped `String` type instead, "
"but we'd have ended up with many `String` fields, which can be hard to "
"disambiguate.  In order not to confuse an email string with a password "
"string, it can therefore be helpful to wrap both of them in a new record "
"type to drastically increase type safety at the cost of having to "
"reimplement some interfaces.  Utility function `on` from the *Prelude* is "
"very useful for this. Don't forget to inspect its type at the REPL, and try "
"to understand what's going on here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:205
msgid "```idris Eq Artist where (==) = (==) `on` name"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:207
msgid "Eq Email where (==) = (==) `on` value"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:209
msgid "Eq Password where (==) = (==) `on` value"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:212
msgid "Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
msgid ""
"In case of `Album`, we wrap the two fields of the record in a `Pair`, which "
"already comes with an implementation of `Eq`.  This allows us to again use "
"function `on`, which is very convenient."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
msgid ""
"Next, we have to define the data types representing server requests and "
"responses:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:225
#, no-wrap
msgid ""
"```idris\n"
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:230
#, no-wrap
msgid ""
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:237
#, no-wrap
msgid ""
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
msgid ""
"For server responses, we use a custom sum type encoding the possible "
"outcomes of a client request. In practice, the `Success` case would return "
"some kind of connection to start the actual album stream, but we just wrap "
"up the album we found to simulate this behavior."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
msgid ""
"We can now go ahead and simulate the handling of a request at the server. To "
"emulate our user data base, a simple list of users will do. Here's the type "
"of the function we'd like to implement:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:252
msgid "```idris DB : Type DB = List User"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:255
msgid "handleRequest : DB -> Request -> Response ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.  This is "
"often useful to make lengthy type signatures more readable and communicate "
"the meaning of a type in the given context. However, this will *not* "
"introduce a new type, nor will it increase type safety: `DB` is *identical* "
"to `List User`, and as such, a value of type `DB` can be used wherever a "
"`List User` is expected and vice versa. In more complex programs it is "
"therefore usually preferable to define new types by wrapping values in "
"single-field records."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
msgid ""
"The implementation will proceed as follows: It will first try and lookup a "
"`User` by is email address in the data base. If this is successful, it will "
"compare the provided password with the user's actual password. If the two "
"match, it will lookup the requested album in the user's list of albums.  If "
"all of these steps succeed, the result will be an `Album` wrapped in a "
"`Success`. If any of the steps fails, the result will describe exactly what "
"went wrong."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
msgid "Here's a possible implementation:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:282
#, no-wrap
msgid ""
"```idris\n"
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:284
#, no-wrap
msgid "    Nothing => UnknownUser email\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:289
#, no-wrap
msgid ""
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:295
#, no-wrap
msgid ""
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
msgid ""
"I'd like to point out several things in this example. First, note how we can "
"extract values from nested records in a single pattern match.  Second, we "
"defined two *local* functions in a `where` block: `lookupUser`, and "
"`lookupAlbum`. Both of these have access to all variables in the surrounding "
"scope. For instance, `lookupUser` uses the `album` variable from the pattern "
"match in the implementation's first line. Likewise, `lookupAlbum` makes use "
"of the `album` variable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
msgid ""
"A `where` block introduces new local definitions, accessible only from the "
"surrounding scope and from other functions defined later in the same `where` "
"block. These need to be explicitly typed and indented by the same amount of "
"whitespace."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
msgid ""
"Local definitions can also be introduce *before* a function's implementation "
"by using the `let` keyword. This usage of `let` is not to be confused with "
"*let bindings* described above, which are used to bind and reuse the results "
"of intermediate computations. Below is how we could have implemented "
"`handleRequest` with local definitions introduced by the `let` keyword. "
"Again, all definitions have to be properly typed and indented:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:326
#, no-wrap
msgid ""
"```idris\n"
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:331
#, no-wrap
msgid ""
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:335
#, no-wrap
msgid ""
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:338
#, no-wrap
msgid ""
"        Nothing => UnknownUser email\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:340
msgid "### Exercises"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
msgid ""
"The exercises in this section are supposed to increase you experience in "
"writing purely functional code. In some cases it might be useful to use "
"`let` expressions or `where` blocks, but this will not always be required."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
msgid ""
"Exercise 3 is again of utmost importance. `traverseList` is a specialized "
"version of the more general `traverse`, one of the most powerful and "
"versatile functions available in the *Prelude* (check out its type!)."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.  Inspect "
"their types and use these in the implementation of `handleRequest`. This "
"should allow you to completely get rid of the `where` block."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
msgid ""
"Define an enumeration type listing the four [nucleobases](https://en."
"wikipedia.org/wiki/Nucleobase)  occurring in DNA strands. Define also a type "
"alias `DNA` for lists of nucleobases.  Declare and implement function "
"`readBase` for converting a single character (type `Char`) to a nucleobase.  "
"You can use character literals in your implementation like so: `'A'`, `'a'`. "
"Note, that this function might fail, so adjust the result type accordingly."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
msgid ""
"Implement the following function, which tries to convert all values in a "
"list with a function, which might fail. The result should be a `Just` "
"holding the list of converted values in unmodified order, if and only if "
"every single conversion was successful."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:375
#, no-wrap
msgid ""
"   ```idris\n"
"   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
"   ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
msgid ""
"Implement function `readDNA : String -> Maybe DNA` using the functions and "
"types defined in exercises 2 and 3.  You will also need function `unpack` "
"from the *Prelude*."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
msgid ""
"Implement function `complement : DNA -> DNA` to calculate the complement of "
"a strand of DNA."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:387
msgid "## The Truth about Function Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
msgid ""
"So far, when we defined a top level function, it looked something like the "
"following:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:397
#, no-wrap
msgid ""
"```idris\n"
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the "
"values stored in two `Either`s via a binary function. If either of the "
"`Either` arguments is a `Left`, the result is also a `Left`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and `e`.  "
"However, there is a more verbose type for `zipEitherWith`, which is visible "
"in the REPL when entering `:ti zipEitherWith` (the `i` here tells Idris to "
"include `implicit` arguments). You will get a type similar to this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:418
#, no-wrap
msgid ""
"```idris\n"
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
msgid ""
"In order to understand what's going on here, we will have to talk about "
"named arguments, implicit arguments, and quantities."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:423
msgid "### Named Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
msgid "In a function type, we can give each argument a name. Like so:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:431
#, no-wrap
msgid ""
"```idris\n"
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These names "
"can be reused in a function's implementation, as was done for `deflt`, but "
"this is not mandatory: We are free to use different names in the "
"implementation. There are several reasons, why we'd choose to name our "
"arguments: It can serve as documentation, but it also allows us to pass the "
"arguments to a function in arbitrary order when using the following syntax:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:444
msgid ""
"```idris extractBool : Maybe Bool -> Bool extractBool v = fromMaybe { ma = "
"v, deflt = False } ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
msgid "Or even :"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:451
msgid ""
"```idris extractBool2 : Maybe Bool -> Bool extractBool2 = fromMaybe { deflt "
"= False } ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
msgid ""
"The arguments in a record's constructor are automatically named in "
"accordance with the field names:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:461
#, no-wrap
msgid ""
"```idris\n"
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:465
msgid ""
"gorgar : Dragon gorgar = MkDragon { strength = 150, name = \"Gorgar\", "
"hitPoints = 10000 } ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
msgid ""
"For the use cases described above, named arguments are merely a convenience "
"and completely optional. However, Idris is a *dependently typed* programming "
"language: Types can be calculated from and depend on values. For instance, "
"the *result type* of a function can *depend* on the *value* of one of its "
"arguments. Here's a contrived example:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:476
msgid ""
"```idris IntOrString : Bool -> Type IntOrString True = Integer IntOrString "
"False = String"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:481
msgid ""
"intOrString : (v : Bool) -> IntOrString v intOrString False = \"I'm a String"
"\" intOrString True = 1000 ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
msgid ""
"If you see such a thing for the first time, it can be hard to understand "
"what's going on here. First, function `IntOrString` computes a `Type` from a "
"`Bool` value: If the argument is `True`, it returns type `Integer`, if the "
"argument is `False` it returns `String`. We use this to calculate the return "
"type of function `intOrString` based on its boolean argument `v`: If `v` is "
"`True`, the return type is (in accordance with `IntOrString True = Integer`) "
"`Integer`, otherwise it is `String`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the "
"argument of type `Bool` a name (`v`) in order to reference it in the result "
"type `IntOrString v`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
msgid ""
"You might wonder at this moment, why this is useful and why we would ever "
"want to define a function with such a strange type. We will see lots of very "
"useful examples in due time! For now, suffice to say that in order to "
"express dependent function types, we need to name at least some of the "
"function's arguments and refer to them by name in the types of other "
"arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:502
msgid "### Implicit Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
msgid ""
"Implicit arguments are arguments, the values of which the compiler should "
"infer and fill in for us automatically. For instance, in the following "
"function signature, we expect the compiler to infer the value of type "
"parameter `a` automatically from the types of the other arguments (ignore "
"the 0 quantity for the moment; I'll explain it in the next subsection):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:514
msgid ""
"```idris maybeToEither : {0 a : Type} -> Maybe a -> Either String a "
"maybeToEither Nothing = Left \"Nope\" maybeToEither (Just x) = Right x"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:521
msgid ""
"-- Please remember, that the above is -- equivalent to the following: "
"maybeToEither' : Maybe a -> Either String a maybeToEither' Nothing = Left "
"\"Nope\" maybeToEither' (Just x) = Right x ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
msgid ""
"As you can see, implicit arguments are wrapped in curly braces, unlike "
"explicit named arguments, which are wrapped in parentheses.  Inferring the "
"value of an implicit argument is not always possible.  For instance, if we "
"enter the following at the REPL, Idris will fail with an error:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:532
msgid ""
"```repl Tutorial.Functions2> show (maybeToEither Nothing)  Error: Can't find "
"an implementation for Show (Either String ?a).  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)` "
"without knowing what `a` actually is.  Note the question mark in front of "
"the type parameter: `?a`.  If this happens, there are several ways to help "
"the type checker.  We could, for instance, pass a value for the implicit "
"argument explicitly. Here's the syntax to do this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:545
msgid ""
"```repl Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)  \"Left "
"\"Nope\"\" ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
msgid ""
"As you can see, we use the same syntax as shown above for explicit named "
"arguments and the two forms of argument passing can be mixed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
msgid ""
"We could also specify the type of the whole expression using utility "
"function `the` from the *Prelude*:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:557
msgid ""
"```repl Tutorial.Functions2> show (the (Either String Int8) (maybeToEither "
"Nothing))  \"Left \"Nope\"\" ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
msgid "It is instructive to have a look at the type of `the`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:564
msgid ""
"```repl Tutorial.Functions2> :ti the Prelude.the : (0 a : Type) -> a -> a ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
msgid "Compare this with the identity function `id`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:571
msgid ""
"```repl Tutorial.Functions2> :ti id Prelude.id : {0 a : Type} -> a -> a ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
msgid ""
"The only difference between the two: In case of `the`, the type parameter "
"`a` is an *explicit* argument, while in case of `id`, it is an *implicit* "
"argument. Although the two functions have almost identical types (and "
"implementations!), they serve quite different purposes: `the` is used to "
"help type inference, while `id` is used whenever we'd like to return an "
"argument without modifying it at all (which, in the presence of higher-order "
"functions, happens surprisingly often)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
msgid ""
"Both ways to improve type inference shown above are used quite often, and "
"must be understood by Idris programmers."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:587
msgid "### Multiplicities"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared in "
"several of the type signatures in this section. Idris 2, unlike its "
"predecessor Idris 1, is based on a core language called *quantitative type "
"theory* (QTT): Every variable in Idris 2 is associated with one of three "
"possible multiplicities:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`0`, meaning that the variable is *erased* at runtime."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`1`, meaning that the variable is used *exactly once* at runtime."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, "
"here.  We are, however, often interested in multiplicity `0`: A variable "
"with multiplicity `0` is only relevant at *compile time*. It will not make "
"any appearance at runtime, and the computation of such a variable will never "
"affect a program's runtime performance."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
msgid ""
"In the type signature of `maybeToEither` we see that type parameter `a` has "
"multiplicity `0`, and will therefore be erased and is only relevant at "
"compile time, while the `Maybe a` argument has *unrestricted* multiplicity."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
msgid ""
"It is also possible to annotate explicit arguments with multiplicities, in "
"which case the argument must again be put in parentheses. For an example, "
"look again at the type signature of `the`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:615
msgid "### Underscores"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
msgid ""
"It is often desirable, to only write as little code as necessary and let "
"Idris figure out the rest.  We have already learned about one such occasion: "
"Catch-all patterns.  If a variable in a pattern match is not used on the "
"right hand side, we can't just drop it, as this would make it impossible for "
"Idris, which of several arguments we were planning to drop, but we can use "
"an underscore as a placeholder instead:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:629
#, no-wrap
msgid ""
"```idris\n"
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
msgid ""
"But when we look at the type signature of `isRight`, we will note that type "
"parameters `a` and `b` are also only used once, and are therefore of no "
"importance. Let's get rid of them:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:639
#, no-wrap
msgid ""
"```idris\n"
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
msgid ""
"In the detailed type signature of `zipEitherWith`, it should be obvious for "
"Idris that the implicit arguments are of type `Type`.  After all, all of "
"them are later on applied to the `Either` type constructor, which is of type "
"`Type -> Type -> Type`. Let's get rid of them:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:656
#, no-wrap
msgid ""
"```idris\n"
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
msgid "Consider the following contrived example:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:663
msgid ""
"```idris foo : Integer -> String foo n = show (the (Either String Integer) "
"(Right n))  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious that the second "
"argument in `Either String Integer` is `Integer`. Only the `String` argument "
"can't be inferred by Idris. Even better, the `Either` itself is obvious! "
"Let's get rid of the unnecessary noise:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:674
msgid ""
"```idris foo' : Integer -> String foo' n = show (the (_ String _) (Right "
"n))  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
msgid ""
"Please note, that using underscores as in `foo'` is not always desirable, as "
"it can quite drastically obfuscate the written code. Always use a syntactic "
"convenience to make code more readable, and not to show people how clever "
"you are."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:682
msgid "## Programming with Holes"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
msgid ""
"Solved all the exercises so far? Got angry at the type checker for always "
"complaining and never being really helpful? It's time to change that. Idris "
"comes with several highly useful interactive editing features. Sometimes, "
"the compiler is able to implement complete functions for us (if the types "
"are specific enough). Even if that's not possible, there's an incredibly "
"useful and important feature, which can help us when the types are getting "
"too complicated: Holes.  Holes are variables, the names of which are "
"prefixed with a question mark.  We can use them as placeholders whenever we "
"plan to implement a piece of functionality at a later time. In addition, "
"their types and the types and quantities of all other variables in scope can "
"be inspected at the REPL (or in your editor, if you setup the necessary "
"plugin).  Let's see them holes in action."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
msgid ""
"Remember the `traverseList` example from an Exercise earlier in this "
"section? If this was your first encounter with applicative list traversals, "
"this might have been a nasty bit of work. Well, let's just make it a wee bit "
"harder still. We'd like to implement the same piece of functionality for "
"functions returning `Either e`, where `e` is a type with a `Semigroup` "
"implementation, and we'd like to accumulate the values in all `Left`s we "
"meet along the way."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
msgid "Here's the type of the function:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:713
#, no-wrap
msgid ""
"```idris\n"
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
msgid ""
"Now, in order to follow along, you might want to start your own Idris source "
"file, load it into a REPL session and adjust the code as described here. The "
"first thing we'll do, is write a skeleton implementation with a hole on the "
"right hand side:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:722
msgid "```repl traverseEither fun as = ?impl ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
msgid ""
"When you now go to the REPL and reload the file using command `:r`, you can "
"enter `:m` to list all the *metavariables*:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:731
#, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
msgid ""
"Next, we'd like to display the hole's type (including all variables in the "
"surrounding context plus their types):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:742
#, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:745
msgid "impl : Either e (List b)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value of type "
"`List a` called `as`, and a function from `a` to `Either e b` called `fun`. "
"Our goal is to come up with a value of type `Either a (List b)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
msgid ""
"We *could* just return a `Right []`, but that only make sense if our input "
"list is indeed the empty list. We therefore should start with a pattern "
"match on the list:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:759
#, no-wrap
msgid ""
"```repl\n"
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
msgid ""
"The result is two holes, which must be given distinct names. When inspecting "
"`impl_0`, we get the following result:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:769
#, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:772
msgid "impl_0 : Either e (List b)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a "
"value of type `Either e (List b)` with nothing to work with. We know nothing "
"about `a`, so we can't provide an argument with which to invoke `fun`.  "
"Likewise, we know nothing about `e` or `b` either, so we can't produce any "
"values of these either. The *only* option we have is to replace `impl_0` "
"with an empty list wrapped in a `Right`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:783
#, no-wrap
msgid ""
"```idris\n"
"traverseEither fun []        = Right []\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
msgid ""
"The non-empty case is of course slightly more involved. Here's the context "
"of `?impl_1`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:795
#, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:798
msgid "impl_1 : Either e (List b)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
msgid ""
"Since `x` is of type `a`, we can either use it as an argument to `fun` or "
"drop and ignore it. `xs`, on the other hand, is the remainder of the list of "
"type `List a`. We could again drop it or process it further by invoking "
"`traverseEither` recursively. Since the goal is to try and convert *all* "
"values, we should drop neither. Since in case of two `Left`s we are supposed "
"to accumulate the values, we eventually need to run both computations anyway "
"(invoking `fun`, and recursively calling `traverseEither`). We therefore can "
"do both at the same time and analyze the results in a single pattern match "
"by wrapping both in a `Pair`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:816
#, no-wrap
msgid ""
"```repl\n"
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
msgid "Once again, we inspect the context:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:828
#, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:831
msgid "impl_2 : Either e (List b)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
msgid ""
"We'll definitely need to pattern match on pair `p` next to figure out, which "
"of the two computations succeeded:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:843
#, no-wrap
msgid ""
"```repl\n"
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
msgid ""
"At this point we might have forgotten what we actually wanted to do (at "
"least to me, this happens annoyingly often), so we'll just quickly check "
"what our goal is:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:858
#, no-wrap
msgid ""
"```repl\n"
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:861
msgid "impl_6 : Either e (List b)  ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and we "
"have two values of type `e` in scope. According to the spec we want to "
"accumulate these using `e`s `Semigroup` implementation.  We can proceed for "
"the other cases in a similar manner, remembering that we should return a "
"`Right`, if and only if all conversions where successful:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:877
#, no-wrap
msgid ""
"```idris\n"
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
"```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
msgid "To reap the fruits of our labour, let's show off with a small example:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:882
msgid "```idris data Nucleobase = Adenine | Cytosine | Guanine | Thymine"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:889
#, no-wrap
msgid ""
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:892
msgid "DNA : Type DNA = List Nucleobase"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:896
msgid ""
"readDNA : String -> Either (List String) DNA readDNA = traverseEither "
"readNucleobase . unpack ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
msgid "Let's try this at the REPL:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:905
msgid ""
"```repl Tutorial.Functions2> readDNA \"CGTTA\" Right [Cytosine, Guanine, "
"Thymine, Thymine, Adenine] Tutorial.Functions2> readDNA \"CGFTAQ\" Left "
"[\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"] ```"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:907
msgid "### Interactive Editing"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
msgid ""
"There are plugins available for several editors and programming "
"environments, which facilitate interacting with the Idris compiler when "
"implementing your functions.  One editor, which is well supported in the "
"Idris community, is Neovim. Since I am a Neovim user myself, I added some "
"examples of what's possible to the [appendix](../Appendices/Neovim.md). Now "
"would be a good time to start using the utilities discussed there."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
msgid ""
"If you use a different editor, probably with less support for the Idris "
"programming language, you should at the very least have a REPL session open "
"all the time, where the source file you are currently working on is loaded. "
"This allows you to introduce new metavariables and inspect their types and "
"context as you develop your code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that "
"you should get yourselves accustomed to programming with holes and let the "
"type checker help you figure out what to do next."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
msgid "Use *let expressions* to define and reuse local variables."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
msgid ""
"In the [next chapter](Dependent.md)  we'll start using dependent types to "
"help us write provably correct code.  Having a good understanding of how to "
"read Idris' type signatures will be of paramount importance there. Whenever "
"you feel lost, add one or more holes and inspect their context to decide "
"what to do next."
msgstr ""
