# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-02 13:19+0800\n"
"PO-Revision-Date: 2022-08-02 12:48+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2-tutorial/prim/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:262 ../src/Tutorial/Dependent.md:445
#: ../src/Tutorial/DPair.md:349 ../src/Tutorial/Eq.md:280
#: ../src/Tutorial/Folds.md:374 ../src/Tutorial/Functor.md:382
#: ../src/Tutorial/Interfaces.md:190 ../src/Tutorial/IO.md:318
#: ../src/Tutorial/Predicates.md:306 ../src/Tutorial/Prim.md:449
#: ../src/Tutorial/Traverse.md:248
#, fuzzy
msgid "### Exercises part 1"
msgstr "### 练习第 1 部分"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:437 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:654 ../src/Tutorial/Eq.md:556
#: ../src/Tutorial/Folds.md:669 ../src/Tutorial/Functor.md:963
#: ../src/Tutorial/Interfaces.md:353 ../src/Tutorial/IO.md:729
#: ../src/Tutorial/Predicates.md:673 ../src/Tutorial/Prim.md:713
#: ../src/Tutorial/Traverse.md:575
#, fuzzy
msgid "### Exercises part 2"
msgstr "### 练习第 2 部分"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:743 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1129 ../src/Tutorial/Eq.md:827
#: ../src/Tutorial/Folds.md:989 ../src/Tutorial/Functor.md:1233
#: ../src/Tutorial/Interfaces.md:625 ../src/Tutorial/IO.md:950
#: ../src/Tutorial/Predicates.md:1021 ../src/Tutorial/Prim.md:937
#: ../src/Tutorial/Traverse.md:1017
#, fuzzy
msgid "### Exercises part 3"
msgstr "### 练习第 3 部分"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, fuzzy
msgid "<!-- vi: filetype=idris2 -->"
msgstr "<!-- vi: filetype=idris2 -->"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:15 ../src/Tutorial/DPair.md:37
#: ../src/Tutorial/Eq.md:20 ../src/Tutorial/Folds.md:33
#: ../src/Tutorial/Functions2.md:21 ../src/Tutorial/Functor.md:27
#: ../src/Tutorial/IO.md:19 ../src/Tutorial/Predicates.md:28
#: ../src/Tutorial/Prim.md:16 ../src/Tutorial/Traverse.md:30
#, fuzzy
msgid "%default total ```"
msgstr "%默认总数```"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
#, fuzzy
msgid "And at the REPL:"
msgstr "在 REPL："

#. type: Plain text
#: ../src/Tutorial/Prim.md:2
#, fuzzy
msgid "# Primitives"
msgstr "# 原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:7
#, fuzzy
msgid ""
"In the topics we covered so far, we hardly ever talked about primitive types "
"in Idris. They where around and we used them in some computations, but I "
"never really explained how they work and where they come from, nor did I "
"show in detail what we can and can't do with them."
msgstr ""
"到目前为止，在我们讨论的主题中，我们几乎从未讨论过 Idris 中的原始类型。它们在"
"哪里，我们在一些计算中使用它们，但我从来没有真正解释过它们是如何工作的以及它"
"们来自哪里，我也没有详细说明我们可以用它们做什么和不能做什么。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:10
#, fuzzy
msgid "```idris module Tutorial.Prim"
msgstr "```idris 模块 Tutorial.Prim"

#. type: Plain text
#: ../src/Tutorial/Prim.md:13
#, fuzzy
msgid "import Data.Bits import Data.String"
msgstr "导入 Data.Bits 导入 Data.String"

#. type: Plain text
#: ../src/Tutorial/Prim.md:18
#, fuzzy
msgid "## How Primitives are Implemented"
msgstr "## 基元是如何实现的"

#. type: Plain text
#: ../src/Tutorial/Prim.md:20
#, fuzzy
msgid "### A Short Note on Backends"
msgstr "### 关于后端的简短说明"

#. type: Plain text
#: ../src/Tutorial/Prim.md:30
#, fuzzy
msgid ""
"According to [Wikipedia](https://en.wikipedia.org/wiki/Compiler), a compiler "
"is \"a computer program that translates computer code written in one "
"programming language (the source language) into another language (the target "
"language)\". The Idris compiler is exactly that: A program translating "
"programs written in Idris into programs written in Chez Scheme. This scheme "
"code is then parsed and interpreted by a Chez Scheme interpreter, which must "
"be installed on the computers we use to run compiled Idris programs."
msgstr ""
"根据 [Wikipedia]（https://en.wikipedia.org/wiki/Compiler），编译器是“一种计算"
"机程序，它将以一种编程语言（源语言）编写的计算机代码翻译成另一种语言（目标语"
"言） ”。 Idris 编译器就是这样：一个将 Idris 编写的程序翻译成 Chez Scheme "
"编写的程序的程序。然后这个方案代码由 Chez Scheme 解释器解析和解释，"
"它必须安装在我们用来运行已编译 Idris 程序的计算机上。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:37
#, fuzzy
msgid ""
"But that's only part of the story. Idris 2 was from the beginning designed "
"to support different code generators (so called *backends*), which allows us "
"to write Idris code to target different platforms, and your Idris "
"installation comes with several additional backends available. You can "
"specify the backend to use with the `--cg` command line argument (`cg` "
"stands for *code generator*). For instance:"
msgstr ""
"但这只是故事的一部分。 Idris 2 从一开始就设计为支持不同的代码生成器（所谓的 *"
" 后端 *），这允许我们编写 Idris 代码以针对不同的平台，并且您的 Idris "
"安装附带了几个可用的附加后端。您可以指定要与 `--cg` "
"命令行参数一起使用的后端（`cg` 代表 * 代码生成器 *）。例如："

#. type: Plain text
#: ../src/Tutorial/Prim.md:41
#, fuzzy
msgid "```sh idris2 --cg racket ```"
msgstr "```sh idris2 --cg 球拍 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:45
#, fuzzy
msgid ""
"Here is a non-comprehensive list of the backends available with a standard "
"Idris installation (the name to be used in the command line argument is "
"given in parentheses):"
msgstr "以下是标准 Idris "
"安装可用的后端的非全面列表（在括号中给出命令行参数中使用的名称）："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, fuzzy
msgid ""
"Racket Scheme (`racket`): This is a different flavour of the scheme "
"programming language, which can be useful to use when Chez Scheme is not "
"available on your operating system."
msgstr ""
"Racket Scheme (`racket`)：这是方案编程语言的另一种风格，当 Chez Scheme "
"在您的操作系统上不可用时，它很有用。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, fuzzy
msgid "Node.js (`node`): This converts an Idris program to JavaScript."
msgstr "Node.js (`node`)：这会将 Idris 程序转换为 JavaScript。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, fuzzy
msgid ""
"Browser (`javascript`): Another JavaScript backend which allows you to write "
"web applications which run in the browser in Idris."
msgstr "浏览器 (`javascript`)：另一个 JavaScript 后端，允许您编写在 Idris "
"的浏览器中运行的 Web 应用程序。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, fuzzy
msgid ""
"RefC (`refc`): A backend compiling Idris to C code, which is then further "
"compiled by a C compiler."
msgstr "RefC (`refc`)：后端将 Idris 编译为 C 代码，然后由 C 编译器进一步编译。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:57
#, fuzzy
msgid ""
"I plan to at least cover the JavaScript backends in some more detail in "
"another part of this Idris guide, as I use them pretty often myself."
msgstr "我计划至少在本 Idris 指南的另一部分中更详细地介绍 JavaScript "
"后端，因为我自己也经常使用它们。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:62
#, fuzzy
msgid ""
"There are also several external backends not officially supported by the "
"Idris project, amongst which are backends for compiling Idris code to Java "
"and Python. You can find a list of external backends on the [Idris Wiki]"
"(https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-"
"backends)."
msgstr ""
"Idris 项目还没有正式支持几个外部后端，其中包括将 Idris 代码编译为 Java 和 "
"Python 的后端。您可以在 [Idris Wiki](https://github.com/idris-lang/Idris2/"
"wiki/1-%5BLanguage%5D-External-backends) 上找到外部后端列表。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:64
#, fuzzy
msgid "### The Idris Primitives"
msgstr "### 伊德里斯原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:69
#, fuzzy
msgid ""
"A *primitive data type* is a type that is built into the Idris compiler "
"together with a set of *primitive functions*, which are used to perform "
"calculations on the primitives. You will therefore not find a definition of "
"a primitive type or function in the source code of the *Prelude*."
msgstr ""
"* 原始数据类型* 是与一组 * 原始函数* 一起内置到 Idris "
"编译器中的类型，这些函数用于对原始数据执行计算。因此，您不会在 *Prelude* "
"的源代码中找到原始类型或函数的定义。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:71
#, fuzzy
msgid "Here is again the list of primitive types in Idris:"
msgstr "这是 Idris 中的原始类型列表："

#. type: Plain text
#: ../src/Tutorial/Prim.md:98
#, fuzzy, no-wrap
msgid ""
"* Signed, fixed precision integers:\n"
"  * `Int8`: Integer in the range [-128,127]\n"
"  * `Int16`: Integer in the range [-32768,32767]\n"
"  * `Int32`: Integer in the range [-2147483648,2147483647]\n"
"  * `Int64`: Integer in the range [-9223372036854775808,9223372036854775807]\n"
"* Unsigned, fixed precision integers:\n"
"  * `Bits8`: Integer in the range [0,255]\n"
"  * `Bits16`: Integer in the range [0,65535]\n"
"  * `Bits32`: Integer in the range [0,4294967295]\n"
"  * `Bits64`: Integer in the range [0,18446744073709551615]\n"
"* `Integer`: A signed, arbitrary precision integer.\n"
"* `Double`: A double precision (64 bit) floating point number.\n"
"* `Char`: A unicode character.\n"
"* `String`: A sequence of unicode characters.\n"
"* `%World`: A symbolic representation of the current world state.\n"
"  We learned about this when I showed you how `IO` is implemented.\n"
"  Most of the time, you will not handle values of this type in your own\n"
"  code.\n"
"* `Int`: This one is special. It is a fixed precision, signed integer,\n"
"   but the bit size is somewhat dependent on the backend and\n"
"   (maybe) platform we use.\n"
"   For instance, if you use the default Chez Scheme backend, `Int` is\n"
"   a 64 bit signed integer, while on the JavaScript backends it is a\n"
"   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
"   with very few guarantees, and you should use one of the well\n"
"   specified integer types listed above whenever possible.\n"
msgstr ""
"* 有符号、固定精度整数：\n"
"  * `Int8`：[-128,127] 范围内的整数\n"
"  * `Int16`：[-32768,32767] 范围内的整数\n"
"  * `Int32`：[-2147483648,2147483647] 范围内的整数\n"
"  *`Int64`：范围内的整数 [-9223372036854775808,9223372036854775807]\n"
"* 无符号、固定精度整数：\n"
"  * `Bits8`：[0,255] 范围内的整数\n"
"  * `Bits16`：[0,65535] 范围内的整数\n"
"  * `Bits32`：[0,4294967295] 范围内的整数\n"
"  * `Bits64`：[0,18446744073709551615] 范围内的整数\n"
"* `Integer`：有符号的任意精度整数。\n"
"* `Double`：双精度（64 位）浮点数。\n"
"* `Char`：一个 unicode 字符。\n"
"* `String`：Unicode 字符序列。\n"
"* `%World`：当前世界状态的符号表示。\n"
"  当我向您展示如何实现 IO 时，我们了解了这一点。\n"
"  大多数时候，您不会自己处理这种类型的值\n"
"  代码。\n"
"* `Int`：这个比较特殊。它是一个固定精度的有符号整数，\n"
"   但位大小在某种程度上取决于后端和\n"
"   （也许）我们使用的平台。\n"
"   例如，如果您使用默认 Chez Scheme 后端，则 `Int` 是\n"
"   一个 64 位有符号整数，而在 JavaScript 后端它是一个\n"
"   出于性能原因，32 位有符号整数。因此，`Int` 来了\n"
"   很少有保证，你应该使用其中一个\n"
"   尽可能指定上面列出的整数类型。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:104
#, fuzzy
msgid ""
"It can be instructive to learn, where in the compiler's source code the "
"primitive types and functions are defined. This source code can be found in "
"folder `src` of the [Idris project](https://github.com/idris-lang/Idris2)  "
"and the primitive types are the constant constructors of data type `Core.TT."
"Constant`."
msgstr ""
"学习在编译器源代码中定义原始类型和函数的位置可能具有指导意义。此源代码可以在 "
"[Idris 项目](https://github.com/idris-lang/Idris2) 的文件夹 `src` 中找到，"
"原始类型是数据类型 ` 的常量构造函数Core.TT.Constant`。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:106
#, fuzzy
msgid "### Primitive Functions"
msgstr "### 原始函数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:112
#, fuzzy
msgid ""
"All calculations operating on primitives are based on two kinds of primitive "
"functions: The ones built into the compiler (see below) and the ones defined "
"by programmers via the foreign function interface (FFI), about which I'll "
"talk in another chapter."
msgstr "所有对原语进行的计算都基于两种原语函数：编译器内置的（见下文）和程序员通过外"
"部函数接口（FFI）定义的函数，我将在另一章中讨论。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:119
#, fuzzy
msgid ""
"Built-in primitive functions are functions known to the compiler the "
"definition of which can not be found in the *Prelude*. They define the core "
"functionality available for the primitive types. Typically, you do not "
"invoke these directly (although it is perfectly fine to do so in most cases) "
"but via functions and interfaces exported by the *Prelude* or the *base* "
"library."
msgstr ""
"内置原始函数是编译器已知的函数，其定义在 *Prelude* 中找不到。它们定义了可用于"
"原始类型的核心功能。通常，您不会直接调用它们（尽管在大多数情况下这样做非常好"
"），而是通过 *Prelude* 或 *base* 库导出的函数和接口。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:123
#, fuzzy
msgid ""
"For instance, the primitive function for adding two eight bit unsigned "
"integers is `prim__add_Bits8`. You can inspect its type and behavior at the "
"REPL:"
msgstr "例如，将两个八位无符号整数相加的原始函数是 `prim__add_Bits8`。您可以在 REPL "
"中检查其类型和行为："

#. type: Plain text
#: ../src/Tutorial/Prim.md:130
#, fuzzy
msgid ""
"```repl Tutorial.Prim> :t prim__add_Bits8 prim__add_Bits8 : Bits8 -> Bits8 -"
"> Bits8 Tutorial.Prim> prim__add_Bits8 12 100 112 ```"
msgstr ""
"```repl Tutorial.Prim> :t prim__add_Bits8 prim__add_Bits8 : Bits8 -> Bits8 -"
"> Bits8 Tutorial.Prim> prim__add_Bits8 12 100 112 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:148
#, fuzzy
msgid ""
"If you look at the source code implementing interface `Num` for `Bits8`, you "
"will see that the plus operator just invokes `prim__add_Bits8` internally. "
"The same goes for most of the other functions in primitive interface "
"implementations.  For instance, every primitive type with the exception of `"
"%World` comes with primitive comparison functions.  For `Bits8`, these are: "
"`prim__eq_Bits8`, `prim__gt_Bits8`, `prim__lt_Bits8`, `prim__gte_Bits8`, and "
"`prim__lte_Bits8`.  Note, that these functions do not return a `Bool` (which "
"is *not* a primitive type in Idris), but an `Int`. They are therefore not as "
"safe or convenient to use as the corresponding operator implementations form "
"interfaces `Eq` and `Comp`.  On the other hand, they do not go via a "
"conversion to `Bool` and might therefore perform slightly better in "
"performance critical code (which you can only identify after some serious "
"profiling)."
msgstr ""
"如果查看 `Bits8` 的实现接口 `Num` 的源代码，您会看到加号运算符只是在内部调用 "
"`prim__add_Bits8`。原始接口实现中的大多数其他功能也是如此。例如，除了 "
"`%World` 之外的每个原始类型都带有原始比较函数。对于 `Bits8`，它们是：`prim__e"
"q_Bits8`、`prim__gt_Bits8`、`prim__lt_Bits8`、`prim__gte_Bits8` 和 `"
"prim__lte_Bits8 X466X]。请注意，这些函数不返回 `Bool`（在 Idris 中 * 不是 * "
"原始类型），而是 `Int`。因此，它们不像接口 `Eq` 和 `Comp` "
"中的相应运算符实现那样安全或方便。另一方面，它们不会通过转换为 `Bool` 并且因"
"此在性能关键代码中的性能可能会稍好一些（您只能在经过一些认真的分析后才能识别"
"）。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:152
#, fuzzy
msgid ""
"As with primitive types, the primitive functions are listed as constructors "
"in a data type (`Core.TT.PrimFn`) in the compiler sources. We will look at "
"most of these in the following sections."
msgstr ""
"与原始类型一样，原始函数在编译器源代码中被列为数据类型 (`Core.TT.PrimFn`) "
"中的构造函数。我们将在以下部分中介绍其中的大部分内容。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:154
#, fuzzy
msgid "### Consequences of being Primitive"
msgstr "### 原始的后果"

#. type: Plain text
#: ../src/Tutorial/Prim.md:163
#, fuzzy
msgid ""
"Primitive functions and types are opaque to the compiler in most regards: "
"They have to be defined and implemented by each backend individually, "
"therefore, the compiler knows nothing about the inner structure of a "
"primitive value nor about the inner workings of primitive functions. For "
"instance, in the following recursive function, *we* know that the argument "
"in the recursive call must be converging towards the base case (unless there "
"is a bug in the backend we use), but the compiler does not:"
msgstr ""
"在大多数情况下，原始函数和类型对编译器是不透明的：它们必须由每个后端单独定义"
"和实现，因此，编译器对原始值的内部结构和原始函数的内部工作一无所知。例如，在"
"下面的递归函数中，*we* 知道递归调用中的参数必须收敛到基本情况（除非我们使用的"
"后端存在错误），但编译器不知道："

#. type: Plain text
#: ../src/Tutorial/Prim.md:170
#, fuzzy
msgid ""
"```idris covering replicateBits8' : Bits8 -> a -> List a replicateBits8' 0 _ "
"= [] replicateBits8' n v = v :: replicateBits8' (n - 1) v ```"
msgstr ""
"```idris 覆盖 replicateBits8' : Bits8 -> a -> List a replicateBits8' 0 _ = []"
" replicateBits8' n v = v :: replicateBits8' (n - 1) v ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:174
#, fuzzy
msgid ""
"In these cases, we either must be content with just a *covering* function, "
"or we use `assert_smaller` to convince the totality checker (the preferred "
"way):"
msgstr "在这些情况下，我们要么只满足于 *covering* 函数，要么使用 `assert_smaller` "
"来说服整体检查器（首选方式）："

#. type: Plain text
#: ../src/Tutorial/Prim.md:180
#, fuzzy
msgid ""
"```idris replicateBits8 : Bits8 -> a -> List a replicateBits8 0 _ = [] "
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v ```"
msgstr ""
"```idris replicateBits8 : Bits8 -> a -> List a replicateBits8 0 _ = [] "
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:184
#, fuzzy
msgid ""
"I have shown you the risks of using `assert_smaller` before, so we must be "
"extra careful in making sure that the new function argument is indeed "
"smaller with relation to the base case."
msgstr "我之前已经向您展示了使用 `assert_smaller` "
"的风险，因此我们必须格外小心，以确保新函数参数相对于基本情况确实更小。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:189
#, fuzzy
msgid ""
"While Idris knows nothing about the internal workings of primitives and "
"related functions, most of these functions still reduce during evaluation "
"when fed with values known at compile time. For instance, we can trivially "
"proof that for `Bits8` the following equation holds:"
msgstr ""
"虽然 Idris 对原语和相关函数的内部工作原理一无所知，但当输入编译时已知的值时，"
"这些函数中的大多数在评估期间仍然会减少。例如，我们可以简单地证明对于 "
"`Bits8`，以下等式成立："

#. type: Plain text
#: ../src/Tutorial/Prim.md:194
#, fuzzy
msgid "```idris zeroBits8 : the Bits8 0 = 255 + 1 zeroBits8 = Refl ```"
msgstr "```idris zeroBits8 : Bits8 0 = 255 + 1 zeroBits8 = Refl ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:200
#, fuzzy
msgid ""
"Having no clue about the internal structure of a primitive nor about the "
"implementations of primitive functions, Idris can't help us proofing any "
"*general* properties of such functions and values. Here is an example to "
"demonstrate this. Assume we'd like to wrap a list in a data type indexed by "
"the list's length:"
msgstr ""
"由于不了解原始的内部结构或原始函数的实现，Idris "
"无法帮助我们证明此类函数和值的任何 *general* 属性。这是一个例子来证明这一点。"
"假设我们想将一个列表包装在一个由列表长度索引的数据类型中："

#. type: Plain text
#: ../src/Tutorial/Prim.md:205
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"数据 LenList : (n : Nat) -> 类型 -> 类型\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:209
#, fuzzy
msgid ""
"When we concatenate two `LenList`s, the length indices should be added. "
"That's how list concatenation affects the length of lists. We can safely "
"teach Idris that this is true:"
msgstr "当我们连接两个 `LenList` 时，应该添加长度索引。这就是列表连接影响列表长度的方"
"式。我们可以安全地告诉伊德里斯这是真的："

#. type: Plain text
#: ../src/Tutorial/Prim.md:215
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"0 concatLen : (xs,ys : 列表 a) -> 长度 xs + 长度 ys = 长度 (xs ++ ys)\n"
"concatLen [] ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:217
#, fuzzy
msgid "With the above lemma, we can implement concatenation of `LenList`:"
msgstr "通过上述引理，我们可以实现 `LenList` 的串联："

#. type: Plain text
#: ../src/Tutorial/Prim.md:223
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  在 MkLenList (xs ++ ys) 中重写 concatLen xs ys\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:231
#, fuzzy
msgid ""
"The same is not possible for strings. There are applications where pairing a "
"string with its length would be useful (for instance, if we wanted to make "
"sure that strings are getting strictly shorter during parsing and will "
"therefore eventually be wholly consumed), but Idris cannot help us getting "
"these things right.  There is no way to implement and thus proof the "
"following lemma in a safe way:"
msgstr ""
"字符串也是不可能的。在某些应用程序中，将字符串与其长度配对会很有用（例如，如"
"果我们想确保字符串在解析过程中严格缩短，因此最终会被完全消耗掉），但 Idris "
"无法帮助我们正确处理这些事情。没有办法以安全的方式实现并证明以下引理："

#. type: Plain text
#: ../src/Tutorial/Prim.md:235
#, fuzzy
msgid ""
"```idris 0 concatLenStr : (a,b : String) -> length a + length b = length (a +"
"+ b)  ```"
msgstr ""
"```idris 0 concatLenStr : (a,b : String) -> 长度 a + 长度 b = 长度 (a ++ b) "
"```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:239
#, fuzzy
msgid ""
"<!-- markdownlint-disable MD026 --> ### Believe Me! <!-- markdownlint-enable "
"MD026 -->"
msgstr ""
"<!-- markdownlint-disable MD026 --> ### 相信我！ <!-- markdownlint-enable "
"MD026 -->"

#. type: Plain text
#: ../src/Tutorial/Prim.md:245
#, fuzzy
msgid ""
"In order to implement `concatLenStr`, we have to abandon all safety and use "
"the ten ton wrecking ball of type coercion: `believe_me`. This primitive "
"function allows us to freely coerce a value of any type into a value of any "
"other type.  Needless to say, this is only safe if we *really* know what we "
"are doing:"
msgstr ""
"为了实现`concatLenStr`，我们必须放弃所有安全，使用强制类型的十吨破坏球：`beli"
"eve_me`。这个原始函数允许我们自由地将任何类型的值强制转换为任何其他类型的值。"
"不用说，只有当我们 * 真的 * 知道我们在做什么时，这才是安全的："

#. type: Plain text
#: ../src/Tutorial/Prim.md:249
#, fuzzy
msgid ""
"```idris concatLenStr a b = believe_me $ Refl {x = length a + length b} ```"
msgstr "```idris concatLenStr a b = believe_me $ Refl {x = 长度 a + 长度 b} ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:257
#, fuzzy
msgid ""
"The explicit assignment of variable `x` in `{x = length a + length b}` is "
"necessary, because otherwise Idris will complain about an *unsolved hole*: "
"It can't infer the type of parameter `x` in the `Refl` constructor. We could "
"assign any type to `x` here, because we are passing the result to "
"`believe_me` anyway, but I consider it to be good practice to assign one of "
"the two sides of the equality to make our intention clear."
msgstr ""
"在 `{x = 长度 a + 长度 b}` 中显式分配变量 `x` 是必要的，否则 Idris 会抱怨 * "
"未解决的孔 *：它可以' t 在 `Refl` 构造函数中推断参数 `x` 的类型。"
"我们可以在这里为 `x` 分配任何类型，因为无论如何我们都将结果传递给 "
"`believe_me`，但我认为将等式的两侧之一分配给明确我们的意图。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:262
#, fuzzy
msgid ""
"The higher the complexity of a primitive type, the riskier it is to assume "
"even the most basic properties for it to hold.  For instance, we might act "
"under the delusion that floating point addition is associative:"
msgstr "原始类型的复杂性越高，假设它拥有最基本的属性的风险就越大。例如，我们可能会误"
"以为浮点加法是关联的："

#. type: Plain text
#: ../src/Tutorial/Prim.md:267
#, fuzzy
msgid ""
"```idris 0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z "
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)} ```"
msgstr ""
"```idris 0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z "
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)} ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:270
#, fuzzy
msgid ""
"Well, guess what: That's a lie. And lies lead us straight into the `Void`:"
msgstr "好吧，你猜怎么着：那是个谎言。谎言将我们直接带入 `Void`："

#. type: Plain text
#: ../src/Tutorial/Prim.md:274
#, fuzzy
msgid "```idris Tiny : Double Tiny = 0.0000000000000001"
msgstr "```伊德里斯小：双小= 0.0000000000000001"

#. type: Plain text
#: ../src/Tutorial/Prim.md:277
#, fuzzy
msgid "One : Double One = 1.0"
msgstr "一：双一 = 1.0"

#. type: Plain text
#: ../src/Tutorial/Prim.md:280
#, fuzzy
msgid "wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void wrong Refl impossible"
msgstr "错误 : (0 _ : 1.0000000000000002 = 1.0) -> 无效错误 Refl 不可能"

#. type: Plain text
#: ../src/Tutorial/Prim.md:284
#, fuzzy
msgid "boom : Void boom = wrong (doubleAddAssoc One Tiny Tiny)  ```"
msgstr "繁荣：无效繁荣=错误（doubleAddAssoc One Tiny Tiny）```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:291
#, fuzzy
msgid ""
"Here's what happens in the code above: The call to `doubleAddAssoc` returns "
"a proof that `One + (Tiny + Tiny)` is equal to `(One + Tiny) + Tiny`. But "
"`One + (Tiny + Tiny)` equals `1.0000000000000002`, while `(One + Tiny) + "
"Tiny` equals `1.0`.  We can therefore pass our (wrong) proof to `wrong`, "
"because it is of the correct type, and from this follows a proof of `Void`."
msgstr ""
"下面是上面代码中发生的情况：对 `doubleAddAssoc` 的调用返回一个证明 `One + ("
"Tiny + Tiny)` 等于 `(One + Tiny) + Tiny[X143X ]。但是 `One + (Tiny + Tiny)` "
"等于 `1.0000000000000002`，而 `(One + Tiny) + Tiny` 等于 `1."
"0`。因此，我们可以将我们的（错误的）证明传递给 `wrong`，因为它是正确的类型，"
"并由此得出 `Void` 的证明。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:293
#, fuzzy
msgid "## Working with Strings"
msgstr "## 使用字符串"

#. type: Plain text
#: ../src/Tutorial/Prim.md:297
#, fuzzy
msgid ""
"Module `Data.String` in *base* offers a rich set of functions for working "
"with strings. All these are based on the following primitive operations "
"built into the compiler:"
msgstr "*base* 中的模块 `Data.String` "
"提供了一组丰富的函数来处理字符串。所有这些都基于编译器内置的以下原始操作："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, fuzzy
msgid "`prim__strLength`: Returns the length of a string."
msgstr "`prim__strLength`：返回字符串的长度。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, fuzzy
msgid "`prim__strHead`: Extracts the first character from a string."
msgstr "`prim__strHead`：从字符串中提取第一个字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, fuzzy
msgid "`prim__strTail`: Removes the first character from a string."
msgstr "`prim__strTail`：从字符串中删除第一个字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, fuzzy
msgid "`prim__strCons`: Prepends a character to a string."
msgstr "`prim__strCons`：在字符串前面添加一个字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, fuzzy
msgid "`prim__strAppend`: Appends two strings."
msgstr "`prim__strAppend`：追加两个字符串。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, fuzzy
msgid ""
"`prim__strIndex`: Extracts a character at the given position from a string."
msgstr "`prim__strIndex`：从字符串中提取给定位置的字符。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, fuzzy
msgid "`prim__strSubstr`: Extracts the substring between the given positions."
msgstr "`prim__strSubstr`：提取给定位置之间的子字符串。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:311
#, fuzzy
msgid ""
"Needless to say, not all of these functions are total. Therefore, Idris must "
"make sure that invalid calls do not reduce during compile time, as otherwise "
"the compiler would crash. If, however we force the evaluation of a partial "
"primitive function by compiling and running the corresponding program, this "
"program will crash with an error:"
msgstr ""
"不用说，并非所有这些功能都是完整的。因此，Idris 必须确保在编译期间不会减少无"
"效调用，否则编译器会崩溃。但是，如果我们通过编译和运行相应的程序来强制对部分"
"原始函数求值，则该程序将崩溃并出现错误："

#. type: Plain text
#: ../src/Tutorial/Prim.md:318
#, fuzzy
msgid ""
"```repl Tutorial.Prim> prim__strTail \"\" prim__strTail \"\" Tutorial.Prim> :"
"exec putStrLn (prim__strTail \"\")  Exception in substring: 1 and 0 are not "
"valid start/end indices for \"\" ```"
msgstr ""
"```repl Tutorial.Prim> prim__strTail \"\" prim__strTail \"\" Tutorial.Prim> :"
"exec putStrLn (prim__strTail \"\") 子字符串中的异常：1 和 0 不是“”的有效开始/"
"结束索引 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:323
#, fuzzy
msgid ""
"Note, how `prim__strTail \"\"` is not reduced at the REPL and how the same "
"expression leads to a runtime exception if we compile and execute the "
"program. Valid calls to `prim__strTail` are reduced just fine, however:"
msgstr ""
"请注意，`prim__strTail \"\"` 如何在 REPL "
"中没有减少，以及如果我们编译和执行程序，相同的表达式如何导致运行时异常。对 "
"`prim__strTail` 的有效调用减少得很好，但是："

#. type: Plain text
#: ../src/Tutorial/Prim.md:328
#, fuzzy
msgid ""
"```idris tailExample : prim__strTail \"foo\" = \"oo\" tailExample = Refl ```"
msgstr ""
"```idris tailExample : prim__strTail \"foo\" = \"oo\" tailExample = Refl ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:330
#, fuzzy
msgid "### Pack and Unpack"
msgstr "### 打包和解包"

#. type: Plain text
#: ../src/Tutorial/Prim.md:339
#, fuzzy
msgid ""
"Two of the most important functions for working with strings are `unpack` "
"and `pack`, which convert a string to a list of characters and vice versa. "
"This allows us to conveniently implement many string operations by iterating "
"or folding over the list of characters instead. This might not always be the "
"most efficient thing to do, but unless you plan to handle very large amounts "
"of text, they work and perform reasonably well."
msgstr ""
"处理字符串的两个最重要的函数是 `unpack` 和 `pack`，它们将字符串转换为字符列表"
"，反之亦然。这允许我们通过迭代或折叠字符列表来方便地实现许多字符串操作。这可"
"能并不总是最有效的做法，但除非您计划处理大量文本，否则它们的工作和性能相当不"
"错。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:341
#, fuzzy
msgid "### String Interpolation"
msgstr "### 字符串插值"

#. type: Plain text
#: ../src/Tutorial/Prim.md:345
#, fuzzy
msgid ""
"Idris allows us to include arbitrary string expressions in a string literal "
"by wrapping them in curly braces, the first of which has to be escaped with "
"a backslash. For instance:"
msgstr "Idris 允许我们将任意字符串表达式包含在字符串文字中，方法是将它们包裹在花括号"
"中，第一个必须用反斜杠转义。例如："

#. type: Plain text
#: ../src/Tutorial/Prim.md:350
#, fuzzy
msgid ""
"```idris interpEx1 : Bits64 -> Bits64 -> String interpEx1 x y = \"\\{show x} "
"+ \\{show y} = \\{show $ x + y}\" ```"
msgstr ""
"```idris interpEx1 : Bits64 -> Bits64 -> 字符串 interpEx1 x y = \"\\{show x} "
"+ \\{show y} = \\{show $ x + y}\" ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:356
#, fuzzy
msgid ""
"This is a very convenient way to assemble complex strings from values of "
"different types.  In addition, there is interface `Interpolation`, which "
"allows us to use values in interpolated strings without having to convert "
"them to strings first:"
msgstr ""
"这是从不同类型的值组装复杂字符串的一种非常方便的方法。此外，还有接口`Interpol"
"ation`，它允许我们在插值字符串中使用值，而不必先将它们转换为字符串："

#. type: Plain text
#: ../src/Tutorial/Prim.md:359
#, fuzzy
msgid "```idris data Element = H | He | C | N | O | F | Ne"
msgstr "```idris 数据元素 = H |他 | C | N | ○ | F |氖"

#. type: Plain text
#: ../src/Tutorial/Prim.md:362
#, fuzzy
msgid "Formula : Type Formula = List (Element,Nat)"
msgstr "公式：类型公式 = 列表（元素，Nat）"

#. type: Plain text
#: ../src/Tutorial/Prim.md:371
#, fuzzy, no-wrap
msgid ""
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
msgstr ""
"插值元素 where\n"
"  插值 H = \"H\"\n"
"  插值 He = \"He\"\n"
"  插值 C = \"C\"\n"
"  插值 N = \"N\"\n"
"  插值 O = \"O\"\n"
"  插值 F = \"F\"\n"
"  插值 Ne = \"Ne\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:376
#, fuzzy, no-wrap
msgid ""
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
msgstr ""
"插值 (Element,Nat) 其中\n"
"  插值 (_, 0) = \"\"\n"
"  插值 (x, 1) = \"\\{x}\"\n"
"  插值 (x, k) = \"\\{x}\\{显示 k}\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:379
#, fuzzy, no-wrap
msgid ""
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
msgstr ""
"插值公式\n"
"  插值 = foldMap 插值\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:383
#, fuzzy
msgid ""
"ethanol : String ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, "
"the Nat 1)]}\" ```"
msgstr "乙醇 : String ethanol = \"乙醇的公式是：\\{[(C,2),(H,6),(O, the Nat 1)]}\" "
"```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:385
#, fuzzy
msgid "### Raw and Multiline String Literals"
msgstr "### 原始和多行字符串文字"

#. type: Plain text
#: ../src/Tutorial/Prim.md:388
#, fuzzy
msgid ""
"In string literals, we have to escape certain characters like quotes, "
"backslashes or new line characters. For instance:"
msgstr "在字符串文字中，我们必须转义某些字符，如引号、反斜杠或换行符。例如："

#. type: Plain text
#: ../src/Tutorial/Prim.md:393
#, fuzzy
msgid ""
"```idris escapeExample : String escapeExample = \"A quote: \\\". \\nThis is "
"on a new line.\\nA backslash: \\\\\" ```"
msgstr ""
"```idris escapeExample : String escapeExample = \"A quote: \\\"。 \\n"
"这是一个新行。\\n"
"反斜杠：\\\\\" ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:398
#, fuzzy
msgid ""
"Idris allows us to enter raw string literals, where there is no need to "
"escape quotes and backslashes, by pre- and postfixing the wrapping quote "
"characters with the same number of hash characters. For instance:"
msgstr "Idris 允许我们输入原始字符串文字，无需转义引号和反斜杠，方法是使用相同数量的"
"散列字符前后加环绕引号字符。例如："

#. type: Plain text
#: ../src/Tutorial/Prim.md:402
#, fuzzy
msgid ""
"```idris rawExample : String rawExample = #\"A quote: \". A blackslash: \\\"#"
msgstr "```idris rawExample : String rawExample = #\"A quote: \"。黑斜线：\\\"#"

#. type: Plain text
#: ../src/Tutorial/Prim.md:406
#, fuzzy
msgid ""
"rawExample2 : String rawExample2 = ##\"A quote: \". A blackslash: \\\"## ```"
msgstr "rawExample2 : String rawExample2 = ##\"引用：\"。黑斜线：\\\"## ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:411
#, fuzzy
msgid ""
"With raw string literals, it is still possible to use string interpolation, "
"but the opening curly brace has to be prefixed with a backslash and the same "
"number of hashes as are being used for opening and closing the string "
"literal:"
msgstr "对于原始字符串文字，仍然可以使用字符串插值，但开始的花括号必须以反斜杠为前缀"
"，并且散列数与用于打开和关闭字符串文字的哈希数相同："

#. type: Plain text
#: ../src/Tutorial/Prim.md:416
#, fuzzy
msgid ""
"```idris rawInterpolExample : String rawInterpolExample = ##\"An "
"interpolated \"string\": \\##{rawExample}\"## ```"
msgstr ""
"```idris rawInterpolExample : String rawInterpolExample = ##\"一个内插的"
"“字符串”：\\##{rawExample}\"## ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:424
#, fuzzy
msgid ""
"Finally, Idris also allows us to conveniently write multiline strings. These "
"can be pre- and postfixed with hashes if we want raw multiline string "
"literals, and they also can be combined with string interpolation. Multiline "
"literals are opened and closed with triple quote characters. Indenting the "
"closing triple quotes allows us to indent the whole multiline literal. "
"Whitespace used for indentation will not appear in the resulting string. For "
"instance:"
msgstr ""
"最后，Idris 还允许我们方便地编写多行字符串。如果我们想要原始的多行字符串文字"
"，这些可以用哈希前缀和后缀，它们也可以与字符串插值结合使用。多行文字用三引号"
"字符打开和关闭。缩进结束的三引号允许我们缩进整个多行文字。用于缩进的空格不会"
"出现在结果字符串中。例如："

#. type: Plain text
#: ../src/Tutorial/Prim.md:435
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
msgstr ""
"```伊德里斯\n"
"多行1：字符串\n"
"多行 1 = \"\"\"\n"
"  我抬起头凝视\n"
"  在陌生人的眼中\n"
"  我一直都知道镜子从不说谎\n"
"  人们总是转身离开\n"
"  从陌生人的眼中\n"
"  害怕看到凝视背后隐藏的东西\n"
"  \"\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:443
#, fuzzy, no-wrap
msgid ""
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"
"```\n"
msgstr ""
"多行2：字符串\n"
"多行2 = #\"\"\"\n"
"  一个简单表达式的示例：\n"
"  “富”++“酒吧”。\n"
"  这被简化为 \"\\#{\"foo\" ++ \"bar\"}\"。\n"
"  \"\"\"#\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:447
#, fuzzy
msgid ""
"Make sure to look at the example strings at the REPL to see the effect of "
"interpolation and raw string literals and compare it with the syntax we used."
msgstr "请务必查看 REPL 中的示例字符串，以了解插值和原始字符串文字的效果，并将其与我"
"们使用的语法进行比较。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:454
#, fuzzy
msgid ""
"In these exercises, you are supposed to implement a bunch of utility "
"functions for consuming and converting strings.  I don't give the expected "
"types here, because you are supposed to come up with those yourself."
msgstr "在这些练习中，你应该实现一堆用于消费和转换字符串的实用函数。我在这里没有给出"
"预期的类型，因为你应该自己想出那些。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:458
#, fuzzy
msgid ""
"Implement functions similar to `map`, `filter`, and `mapMaybe` for strings. "
"The output type of these should always be a string."
msgstr "为字符串实现类似于 `map`、`filter` 和 `mapMaybe` "
"的函数。这些的输出类型应该始终是一个字符串。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:461
#, fuzzy
msgid "Implement functions similar to `foldl` and `foldMap` for strings."
msgstr "为字符串实现类似于 `foldl` 和 `foldMap` 的函数。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:464
#, fuzzy
msgid ""
"Implement a function similar to `traverse` for strings. The output type "
"should be a wrapped string."
msgstr "为字符串实现类似于 `traverse` 的函数。输出类型应该是一个包装的字符串。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:467
#, fuzzy
msgid ""
"Implement the bind operator for strings. The output type should again be a "
"string."
msgstr "为字符串实现绑定运算符。输出类型应该再次是字符串。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:469
#, fuzzy
msgid "## Integers"
msgstr "## 整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:475
#, fuzzy
msgid ""
"As listed at the beginning of this chapter, Idris provides different fixed-"
"precision signed and unsigned integer types as well as `Integer`, an "
"arbitrary precision signed integer type.  All of them come with the "
"following primitive functions (given here for `Bits8` as an example):"
msgstr ""
"正如本章开头所列出的，Idris 提供了不同的固定精度有符号和无符号整数类型以及 "
"`Integer`，一种任意精度的有符号整数类型。它们都带有以下原始函数（此处以 "
"`Bits8` 为例）："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__add_Bits8`: Integer addition."
msgstr "`prim__add_Bits8`：整数加法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__sub_Bits8`: Integer subtraction."
msgstr "`prim__sub_Bits8`：整数减法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__mul_Bits8`: Integer multiplication."
msgstr "`prim__mul_Bits8`：整数乘法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__div_Bits8`: Integer division."
msgstr "`prim__div_Bits8`：整数除法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__mod_Bits8`: Modulo function."
msgstr "`prim__mod_Bits8`：模函数。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__shl_Bits8`: Bitwise left shift."
msgstr "`prim__shl_Bits8`：按位左移。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__shr_Bits8`: Bitwise right shift."
msgstr "`prim__shr_Bits8`：按位右移。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__and_Bits8`: Bitwise *and*."
msgstr "`prim__and_Bits8`：按位 * 和 *。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__or_Bits8`: Bitwise *or*."
msgstr "`prim__or_Bits8`：按位 * 或 *。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, fuzzy
msgid "`prim__xor_Bits8`: Bitwise *xor*."
msgstr "`prim__xor_Bits8`：按位 *xor*。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:493
#, fuzzy
msgid ""
"Typically, you use the functions for addition and multiplication through the "
"operators from interface `Num`, the function for subtraction through "
"interface `Neg`, and the functions for division (`div` and `mod`) through "
"interface `Integral`.  The bitwise operations are available through "
"interfaces `Data.Bits.Bits` and `Data.Bits.FiniteBits`."
msgstr ""
"通常，您可以通过接口 `Num` 中的运算符使用加法和乘法函数，通过接口 `Neg` "
"使用减法函数，以及除法函数 (`div`和 `mod`) 通过接口 `Integral`。"
"位运算可通过接口 `Data.Bits.Bits` 和 `Data.Bits.FiniteBits` 获得。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:497
#, fuzzy
msgid ""
"For all integral types, the following laws are assumed to hold for numeric "
"operations (`x`, `y`, and `z` are arbitrary value of the same primitive "
"integral type):"
msgstr "对于所有整数类型，假设以下定律适用于数值运算（`x`、`y` 和 `z` "
"是相同原始整数类型的任意值） ："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x + y = y + x`: Addition is commutative."
msgstr "`x + y = y + x`：加法是可交换的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x + (y + z) = (x + y) + z`: Addition is associative."
msgstr "`x + (y + z) = (x + y) + z`：加法是结合的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x + 0 = x`: Zero is the neutral element of addition."
msgstr "`x + 0 = x`：零是加法的中性元素。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x - x = x + (-x) = 0`: `-x` is the additive inverse of `x`."
msgstr "`x - x = x + (-x) = 0`：`-x` 是 `x` 的加法逆。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x * y = y * x`: Multiplication is commutative."
msgstr "`x * y = y * x`：乘法是可交换的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x * (y * z) = (x * y) * z`: Multiplication is associative."
msgstr "`x * (y * z) = (x * y) * z`：乘法是结合的。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x * 1 = x`: One is the neutral element of multiplication."
msgstr "`x * 1 = x`：一个是乘法的中性元素。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "`x * (y + z) = x * y + x * z`: The distributive law holds."
msgstr "`x * (y + z) = x * y + x * z`：分配律成立。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, fuzzy
msgid "``y * (x `div` y) + (x `mod` y) = x`` (for `y /= 0`)."
msgstr "``y * (x `div` y) + (x `mod` y) = x``（对于 `y /= 0`）。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:515
#, fuzzy
msgid ""
"Please note, that the officially supported backends use *Euclidian modulus* "
"for calculating `mod`: For `y /= 0`, ``x `mod` y`` is always a non-negative "
"value strictly smaller than `abs y`, so that the law given above does hold. "
"If `x` or `y` are negative numbers, this is different to what many other "
"languages do but for good reasons as explained in the following [article]"
"(https://www.microsoft.com/en-us/research/publication/division-and-modulus-"
"for-computer-scientists/)."
msgstr ""
"请注意，官方支持的后端使用 *欧几里得模数* 来计算 `mod`： For `y /= 0`, ``x "
"`mod` y``始终是严格小于 `abs y` 的非负值，因此上面给出的定律确实成立。如果 "
"`x` 或 `y` 是负数，这与许多其他语言所做的不同，但出于以下[文章](https://"
"www.microsoft. com/en-us/research/publication/"
"division-and-modulus-for-computer-scientists/）。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:517
#, fuzzy
msgid "### Unsigned Integers"
msgstr "### 无符号整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:526
#, fuzzy
msgid ""
"The unsigned fixed precision integer types (`Bits8`, `Bits16`, `Bits32`, and "
"`Bits64`) come with implementations of all integral interfaces (`Num`, "
"`Neg`, and `Integral`) and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  All functions with the exception of `div` and `mod` are "
"total. Overflows are handled by calculating the remainder modulo "
"`2^bitsize`. For instance, for `Bits8`, all operations calculate their "
"results modulo 256:"
msgstr ""
"无符号固定精度整数类型（`Bits8`、`Bits16`、`Bits32` 和 "
"`Bits64`）带有所有积分接口的实现（[X141X ]Num`、`Neg` 和 "
"`Integral`）以及用于按位运算的两个接口（`Bits` 和 `FiniteBits`）。除了 `div` "
"和 `mod` 之外的所有函数都是总计的。通过计算余数模 `2^bitsize` "
"来处理溢出。例如，对于 `Bits8`，所有操作都以 256 为模计算其结果："

#. type: Plain text
#: ../src/Tutorial/Prim.md:537
#, fuzzy
msgid ""
"```repl Main> the Bits8 255 + 1 0 Main> the Bits8 255 + 255 254 Main> the "
"Bits8 128 * 2 + 7 7 Main> the Bits8 12 - 13 255 ```"
msgstr ""
"```repl Main> Bits8 255 + 1 0 Main> Bits8 255 + 255 254 Main> Bits8 128 * 2 +"
" 7 7 Main> Bits8 12 - 13 255 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:539
#, fuzzy
msgid "### Signed Integers"
msgstr "### 有符号整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:549
#, fuzzy
msgid ""
"Like the unsigned integer types, the signed fixed precision integer types "
"(`Int8`, `Int16`, `Int32`, and `Int64`) come with implementations of all "
"integral interfaces and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  Overflows are handled by calculating the remainder "
"modulo `2^bitsize` and adding the lower bound (a negative number)  if the "
"result is still out of range. For instance, for `Int8`, all operations "
"calculate their results modulo 256, subtracting 128 if the result is still "
"out of bounds:"
msgstr ""
"与无符号整数类型一样，有符号固定精度整数类型（`Int8`、`Int16`、`Int32` 和 "
"`Int64`）具有以下实现所有积分接口和用于按位运算的两个接口（`Bits` 和 "
"`FiniteBits`）。如果结果仍然超出范围，则通过计算余数模 `2^bitsize` "
"并添加下限（负数）来处理溢出。例如，对于 `Int8`，所有操作都以 256 "
"为模计算结果，如果结果仍然超出范围，则减去 128："

#. type: Plain text
#: ../src/Tutorial/Prim.md:556
#, fuzzy
msgid "```repl Main> the Int8 2 * 127 -2 Main> the Int8 3 * 127 125 ```"
msgstr "```repl Main> Int8 2 * 127 -2 Main> Int8 3 * 127 125 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:558
#, fuzzy
msgid "### Bitwise Operations"
msgstr "### 位运算"

#. type: Plain text
#: ../src/Tutorial/Prim.md:568
#, fuzzy
msgid ""
"Module `Data.Bits` exports interfaces for performing bitwise operations on "
"integral types. I'm going to show a couple of examples on unsigned 8-bit "
"numbers (`Bits8`) to explain the concept to readers new to bitwise "
"arithmetics. Note, that this is much easier to grasp for unsigned integer "
"types than for the signed versions.  Those have to include information about "
"the *sign* of numbers in their bit pattern, and it is assumed that signed "
"integers in Idris use a [two's complement representation](https://en."
"wikipedia.org/wiki/Two%27s_complement), about which I will not go into the "
"details here."
msgstr ""
"模块 `Data.Bits` 导出用于对整数类型执行按位运算的接口。"
"我将展示几个关于无符号 8 位数字 (`Bits8`) 的示例，以向不熟悉按位算术的读者解"
"释这个概念。请注意，对于无符号整数类型，这比有符号版本更容易掌握。"
"那些必须在其位模式中包含有关数字的 * 符号 * 的信息，并且假设 Idris "
"中的有符号整数使用 [二进制补码表示]（https://en.wikipedia.org/wiki/ "
"2%27s_complement)，这里不再赘述。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:573
#, fuzzy
msgid ""
"An unsigned 8-bit binary number is represented internally as a sequence of "
"eight bits (with values 0 or 1), each of which corresponds to a power of 2. "
"For instance, the number 23 (= 16 + 4 + 2 + 1) is represented as `0001 0111`:"
msgstr ""
"无符号 8 位二进制数在内部表示为 8 位序列（值为 0 或 1），每个位对应于 2 "
"的幂。例如，数字 23 (= 16 + 4 + 2 + 1)表示为 `0001 0111`："

#. type: Plain text
#: ../src/Tutorial/Prim.md:576
#, fuzzy, no-wrap
msgid ""
"```repl\n"
"23 in binary:    0  0  0  1    0  1  1  1\n"
msgstr ""
"```回复\n"
"23 二进制：0 0 0 1 0 1 1 1\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:580
#, fuzzy, no-wrap
msgid ""
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"
"```\n"
msgstr ""
"位数：7 6 5 4 3 2 1 0\n"
"十进制值：128 64 32 16 8 4 2 1\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:583
#, fuzzy
msgid ""
"We can use function `testBit` to check if the bit at the given position is "
"set or not:"
msgstr "我们可以使用函数 `testBit` 来检查给定位置的位是否已设置："

#. type: Plain text
#: ../src/Tutorial/Prim.md:592
#, fuzzy
msgid ""
"```repl Tutorial.Prim> testBit (the Bits8 23) 0 True Tutorial.Prim> testBit "
"(the Bits8 23) 1 True Tutorial.Prim> testBit (the Bits8 23) 3 False ```"
msgstr ""
"```repl Tutorial.Prim> testBit(Bits8 23) 0 True Tutorial.Prim> testBit(Bits8 "
"23) 1 True Tutorial.Prim> testBit(Bits8 23) 3 False ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:595
#, fuzzy
msgid ""
"Likewise, we can use functions `setBit` and `clearBit` to set or unset a bit "
"at a certain position:"
msgstr "同样，我们可以使用函数 `setBit` 和 `clearBit` 在某个位置设置或取消设置位："

#. type: Plain text
#: ../src/Tutorial/Prim.md:602
#, fuzzy
msgid ""
"```repl Tutorial.Prim> setBit (the Bits8 23) 3 31 Tutorial.Prim> clearBit "
"(the Bits8 23) 2 19 ```"
msgstr ""
"```repl Tutorial.Prim>setBit(Bits8 23) 3 31 Tutorial.Prim>clearBit(Bits8 23)"
"2 19 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:610
#, fuzzy
msgid ""
"There are also operators `(.&.)` (bitwise *and*) and `(.|.)` (bitwise *or*) "
"as well as function `xor` (bitwise *exclusive or*)  for performing boolean "
"operations on integral values.  For instance `x .&. y` has exactly those "
"bits set, which both `x` and `y` have set, while `x .|. y` has all bits set "
"that are either set in `x` or `y` (or both), and ``x `xor` y`` has those "
"bits set that are set in exactly one of the two values:"
msgstr ""
"还有运算符 `(.&.)`（按位 * 和 *）和 `(.|.)`（按位 * 或 *）"
"以及用于对整数值执行布尔运算的函数 `xor`（按位 * 互斥或 *）。例如 `x .&。 y` "
"正好设置了那些位，`x` 和 `y` 都设置了，而 `x .|。 y` 设置了在 `x` 或 "
"`y`（或两者）中设置的所有位，并且 ``x `xor` y`` "
"设置了那些位设置为以下两个值之一："

#. type: Plain text
#: ../src/Tutorial/Prim.md:614
#, fuzzy, no-wrap
msgid ""
"```repl\n"
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
msgstr ""
"```回复\n"
"23 二进制：0 0 0 1 0 1 1 1\n"
"11 二进制：0 0 0 0 1 0 1 1\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:619
#, fuzzy, no-wrap
msgid ""
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"
"```\n"
msgstr ""
"23.&. 11 二进制：0 0 0 0 0 0 1 1\n"
"23 .|。 11 二进制：0 0 0 1 1 1 1 1\n"
"23 `xor` 11 二进制：0 0 0 1 1 1 0 0\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:621
#, fuzzy
msgid "And here are the examples at the REPL:"
msgstr "以下是 REPL 上的示例："

#. type: Plain text
#: ../src/Tutorial/Prim.md:630
#, fuzzy
msgid ""
"```repl Tutorial.Prim> the Bits8 23 .&. 11 3 Tutorial.Prim> the Bits8 23 .|. "
"11 31 Tutorial.Prim> the Bits8 23 `xor` 11 28 ```"
msgstr ""
"```repl Tutorial.Prim> Bits8 23 .&. 11 3 Tutorial.Prim> Bits8 23 .|. 11 31 "
"Tutorial.Prim> Bits8 23 `xor` 11 28 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:637
#, fuzzy
msgid ""
"Finally, it is possible to shift all bits to the right or left by a certain "
"number of steps by using functions `shiftR` and `shiftL`, respectively "
"(overflowing bits will just be dropped).  A left shift can therefore be "
"viewed as a multiplication by a power of two, while a right shift can be "
"seen as a division by a power of two:"
msgstr ""
"最后，可以分别使用函数 `shiftR` 和 `shiftL` "
"将所有位向右或向左移动一定步数（溢出的位将被丢弃）。因此，左移可以看作是乘以 "
"2 的幂，而右移可以看作是除以 2 的幂："

#. type: Plain text
#: ../src/Tutorial/Prim.md:640
#, fuzzy, no-wrap
msgid ""
"```repl\n"
"22 in binary:            0  0  0  1    0  1  1  0\n"
msgstr ""
"```回复\n"
"22 二进制：0 0 0 1 0 1 1 0\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:644
#, fuzzy, no-wrap
msgid ""
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"
"```\n"
msgstr ""
"22 `shiftL` 2 二进制：0 1 0 1 1 0 0 0\n"
"22 `shiftR` 1 二进制：0 0 0 0 1 0 1 1\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:653
#, fuzzy
msgid ""
"```repl Tutorial.Prim> the Bits8 22 `shiftL` 2 88 Tutorial.Prim> the Bits8 "
"22 `shiftR` 1 11 ```"
msgstr ""
"```repl Tutorial.Prim> Bits8 22 `shiftL` 2 88 Tutorial.Prim> Bits8 22 "
"`shiftR` 1 11 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:657
#, fuzzy
msgid ""
"Bitwise operations are often used in specialized code or certain high-"
"performance applications. As programmers, we have to know they exist and how "
"they work."
msgstr "按位运算通常用于专用代码或某些高性能应用程序中。作为程序员，我们必须知道它们"
"的存在以及它们是如何工作的。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:659
#, fuzzy
msgid "### Integer Literals"
msgstr "### 整数字面量"

#. type: Plain text
#: ../src/Tutorial/Prim.md:666
#, fuzzy
msgid ""
"So far, we always required an implementation of `Num` in order to be able to "
"use integer literals for a given type. However, it is actually only "
"necessary to implement a function `fromInteger` converting an `Integer` to "
"the type in question. As we will see in the last section, such a function "
"can even restrict the values allowed as valid literals."
msgstr ""
"到目前为止，我们总是需要 `Num` 的实现，以便能够对给定类型使用整数文字。然而，"
"实际上只需要实现一个函数 `fromInteger` 将 `Integer` 转换为相关类型。正如我们"
"将在最后一节中看到的，这样的函数甚至可以限制允许作为有效文字的值。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:671
#, fuzzy
msgid ""
"For instance, assume we'd like to define a data type for representing the "
"charge of a chemical molecule. Such a value can be positive or negative and "
"(theoretically) of almost arbitrary magnitude:"
msgstr "例如，假设我们想定义一个数据类型来表示化学分子的电荷。这样的值可以是正值或负"
"值，并且（理论上）几乎是任意大小："

#. type: Plain text
#: ../src/Tutorial/Prim.md:677
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"记录充电地点\n"
"  构造函数 MkCharge\n"
"  值：整数\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:683
#, fuzzy
msgid ""
"It makes sense to be able to sum up charges, but not to multiply them. They "
"should therefore have an implementation of `Monoid` but not of `Num`. Still, "
"we'd like to have the convenience of integer literals when using constant "
"charges at compile time. Here's how to do this:"
msgstr ""
"能够对费用求和是有意义的，但不能将它们相乘。因此，它们应该有 `Monoid` "
"的实现，而不是 `Num` 的实现。尽管如此，我们还是希望在编译时使用常量费用时能够"
"方便地使用整数文字。以下是如何执行此操作："

#. type: Plain text
#: ../src/Tutorial/Prim.md:687
#, fuzzy
msgid "```idris fromInteger : Integer -> Charge fromInteger = MkCharge"
msgstr "```idris fromInteger : Integer -> Charge fromInteger = MkCharge"

#. type: Plain text
#: ../src/Tutorial/Prim.md:690
#, fuzzy, no-wrap
msgid ""
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
msgstr ""
"半群电荷在哪里\n"
"  x <+> y = MkCharge $ x.value + y.value\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:694
#, fuzzy, no-wrap
msgid ""
"Monoid Charge where\n"
"  neutral = 0\n"
"```\n"
msgstr ""
"Monoid Charge 在哪里\n"
"  中性 = 0\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:696
#, fuzzy
msgid "#### Alternative Bases"
msgstr "#### 替代基地"

#. type: Plain text
#: ../src/Tutorial/Prim.md:702
#, fuzzy
msgid ""
"In addition to the well known decimal literals, it is also possible to use "
"integer literals in binary, octal, or hexadecimal representation. These have "
"to be prefixed with a zero following by a `b`, `o`, or `x` for binary, "
"octal, and hexadecimal, respectively:"
msgstr ""
"除了众所周知的十进制文字外，还可以使用二进制、八进制或十六进制表示的整数文字"
"。对于二进制、八进制和十六进制，它们必须以零为前缀，后跟 `b`、`o` 或 `x`："

#. type: Plain text
#: ../src/Tutorial/Prim.md:711
#, fuzzy
msgid ""
"```repl Tutorial.Prim> 0b1101 13 Tutorial.Prim> 0o773 507 Tutorial.Prim> "
"0xffa2 65442 ```"
msgstr ""
"```repl Tutorial.Prim> 0b1101 13 Tutorial.Prim> 0o773 507 Tutorial.Prim> "
"0xffa2 65442 ```"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:716
#, fuzzy
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.&.)`."
msgstr "定义整数值的包装记录并实现 `Monoid` 以便 `(<+>)` 对应于 `(.&.)`。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:719
#, fuzzy, no-wrap
msgid ""
"   Hint: Have a look at the functions available from interface\n"
"   `Bits` to find a value suitable as the neutral element.\n"
msgstr ""
"   提示：查看界面中可用的功能\n"
"   `Bits` 找到适合作为中性元素的值。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:722
#, fuzzy
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.|.)`."
msgstr "定义整数值的包装记录并实现 `Monoid` 以便 `(<+>)` 对应于 `(.|.)`。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:725
#, fuzzy
msgid ""
"Use bitwise operations to implement a function, which tests if a given value "
"of type `Bits64` is even or not."
msgstr "使用按位运算来实现一个函数，该函数测试 `Bits64` 类型的给定值是否为偶数。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:727
#, fuzzy
msgid "Convert a value of type `Bits64` to a string in binary representation."
msgstr "将 `Bits64` 类型的值转换为二进制表示的字符串。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:729
#, fuzzy
msgid ""
"Convert a value of type `Bits64` to a string in hexadecimal representation."
msgstr "将 `Bits64` 类型的值转换为十六进制表示的字符串。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:732
#, fuzzy, no-wrap
msgid ""
"   Hint: Use `shiftR` and `(.&. 15)` to access subsequent packages of\n"
"   four bits.\n"
msgstr ""
"   提示：使用 `shiftR` 和 `(.&. 15)` 访问后续包\n"
"   四位。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:734
#, fuzzy
msgid "## Refined Primitives"
msgstr "## 精炼的基元"

#. type: Plain text
#: ../src/Tutorial/Prim.md:741
#, fuzzy
msgid ""
"We often do not want to allow all values of a type in a certain context. For "
"instance, `String` as an arbitrary sequence of UTF-8 characters (several of "
"which are not even printable), is too general most of the time. Therefore, "
"it is usually advisable to rule out invalid values early on, by pairing a "
"value with an erased proof of validity."
msgstr ""
"我们通常不希望在某个上下文中允许某个类型的所有值。例如，`String` 作为 UTF-8 "
"字符的任意序列（其中有几个甚至无法打印），在大多数情况下都过于笼统。因此，通"
"常建议通过将值与已擦除的有效性证明配对，尽早排除无效值。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:749
#, fuzzy
msgid ""
"We have learned how we can write elegant predicates, with which we can proof "
"our functions to be total, and from which we can - in the ideal case - "
"derive other, related predicates. However, when we define predicates on "
"primitives they are to a certain degree doomed to live in isolation, unless "
"we come up with a set of primitive axioms (implemented most likely using "
"`believe_me`), with which we can manipulate our predicates."
msgstr ""
"我们已经学会了如何编写优雅的谓词，用它我们可以证明我们的函数是完全的，并且我"
"们可以从它——在理想情况下——推导出其他相关的谓词。然而，当我们在原语上定义谓词"
"时，它们在某种程度上注定要孤立存在，除非我们提出一组原语公理（最有可能使用 "
"`believe_me` 实现），我们可以用它来操纵我们的谓词。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:751
#, fuzzy
msgid "### Use Case: ASCII Strings"
msgstr "### 用例：ASCII 字符串"

#. type: Plain text
#: ../src/Tutorial/Prim.md:756
#, fuzzy
msgid ""
"String encodings is a difficult topic, so in many low level routines it "
"makes sense to rule out most characters from the beginning. Assume "
"therefore, we'd like to make sure the strings we accept in our application "
"only consist of ASCII characters:"
msgstr ""
"字符串编码是一个困难的话题，因此在许多低级例程中，从一开始就排除大多数字符是"
"有意义的。因此，假设我们希望确保我们在应用程序中接受的字符串仅包含 ASCII "
"字符："

#. type: Plain text
#: ../src/Tutorial/Prim.md:760
#, fuzzy
msgid "```idris isAsciiChar : Char -> Bool isAsciiChar c = ord c <= 127"
msgstr "```idris isAsciiChar : Char -> Bool isAsciiChar c = ord c <= 127"

#. type: Plain text
#: ../src/Tutorial/Prim.md:764
#, fuzzy
msgid ""
"isAsciiString : String -> Bool isAsciiString = all isAsciiChar . unpack ```"
msgstr "isAsciiString : String -> Bool isAsciiString = all isAsciiChar 。解压```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:767
#, fuzzy
msgid ""
"We can now *refine* a string value by pairing it with an erased proof of "
"validity:"
msgstr "我们现在可以 * 细化 * 一个字符串值，方法是将其与已擦除的有效性证明配对："

#. type: Plain text
#: ../src/Tutorial/Prim.md:774
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"在哪里记录 Ascii\n"
"  构造函数 MkAscii\n"
"  值：字符串\n"
"  0 prf : isAsciiString 值 === 真\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:779
#, fuzzy
msgid ""
"It is now *impossible* to at runtime or compile time create a value of type "
"`Ascii` without first validating the wrapped string. With this, it is "
"already pretty easy to safely wrap strings at compile time in a value of "
"type `Ascii`:"
msgstr ""
"现在 * 不可能 * 在运行时或编译时创建 `Ascii` "
"类型的值，而无需首先验证包装的字符串。有了这个，在编译时将字符串安全地包装成 "
"`Ascii` 类型的值已经很容易了："

#. type: Plain text
#: ../src/Tutorial/Prim.md:784
#, fuzzy
msgid "```idris hello : Ascii hello = MkAscii \"Hello World!\" Refl ```"
msgstr "```idris hello : Ascii hello = MkAscii \"Hello World!\"反射 ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:800
#, fuzzy
msgid ""
"And yet, it would be much more convenient to still use string literals for "
"this, without having to sacrifice the comfort of safety. To do so, we can't "
"use interface `FromString`, as its function `fromString` would force us to "
"convert *any* string, even an invalid one. However, we actually don't need "
"an implementation of `FromString` to support string literals, just like we "
"didn't require an implementation of `Num` to support integer literals.  What "
"we really need is a function named `fromString`. Now, when string literals "
"are desugared, they are converted to invocations of `fromString` with the "
"given string value as its argument.  For instance, literal `\"Hello\"` gets "
"desugared to `fromString \"Hello\"`.  This happens before type checking and "
"filling in of (auto) implicit values. It is therefore perfectly fine, to "
"define a custom `fromString` function with an erased auto implicit argument "
"as a proof of validity:"
msgstr ""
"然而，为此仍然使用字符串文字会更方便，而不必牺牲安全的舒适性。为此，"
"我们不能使用接口 `FromString`，因为它的函数 `fromString` 会强制我们转换 *any*"
" 字符串，即使是无效字符串。但是，我们实际上不需要实现 `FromString` "
"来支持字符串文字，就像我们不需要实现 `Num` 来支持整数文字一样。"
"我们真正需要的是一个名为 `fromString` 的函数。现在，当字符串文字被脱糖时，"
"它们被转换为以给定字符串值作为参数的 `fromString` 的调用。例如，文字 `\"Hello"
"\"` 被脱糖为 `fromString \"Hello\""
"`。这发生在类型检查和填充（自动）隐式值之前。因此，"
"使用已擦除的自动隐式参数定义自定义 `fromString` "
"函数作为有效性证明是非常好的："

#. type: Plain text
#: ../src/Tutorial/Prim.md:805
#, fuzzy
msgid ""
"```idris fromString : (s : String) -> {auto 0 prf : isAsciiString s === "
"True} -> Ascii fromString s = MkAscii s prf ```"
msgstr ""
"```idris fromString : (s : String) -> {auto 0 prf : isAsciiString s === True}"
" -> Ascii fromString s = MkAscii s prf ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:808
#, fuzzy
msgid ""
"With this, we can us (valid) string literals for coming up with values of "
"type `Ascii` directly:"
msgstr "有了这个，我们可以使用（有效的）字符串文字直接得出 `Ascii` 类型的值："

#. type: Plain text
#: ../src/Tutorial/Prim.md:813
#, fuzzy
msgid "```idris hello2 : Ascii hello2 = \"Hello World!\" ```"
msgstr "```idris hello2 : Ascii hello2 = \"Hello World!\" ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:817
#, fuzzy
msgid ""
"In order to at runtime create values of type `Ascii` from strings of an "
"unknown source, we can use a refinement function returning some kind of "
"failure type:"
msgstr "为了在运行时从未知来源的字符串中创建 `Ascii` "
"类型的值，我们可以使用返回某种故障类型的细化函数："

#. type: Plain text
#: ../src/Tutorial/Prim.md:822
#, fuzzy
msgid ""
"```idris test : (b : Bool) -> Dec (b === True)  test True = Yes Refl test "
"False = No absurd"
msgstr ""
"```idris 测试 : (b : Bool) -> Dec (b === True) 测试 True = 是 Refl 测试 "
"False = 不荒谬"

#. type: Plain text
#: ../src/Tutorial/Prim.md:828
#, fuzzy, no-wrap
msgid ""
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"
"```\n"
msgstr ""
"ascii : 字符串 -> 也许是 Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  是的 prf => 只是 $ MkAscii x prf\n"
"  没有反对 => 没有\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:830
#, fuzzy
msgid "#### Disadvantages of Boolean Proofs"
msgstr "#### 布尔证明的缺点"

#. type: Plain text
#: ../src/Tutorial/Prim.md:834
#, fuzzy
msgid ""
"For many use cases, what we described above for ASCII strings can take us "
"very far. However, one drawback of this approach is that we can't safely "
"perform any computations with the proofs at hand."
msgstr "对于许多用例，我们上面描述的 ASCII 字符串可以让我们走得很远。然而，这种方法的"
"一个缺点是我们不能使用手头的证明安全地执行任何计算。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:839
#, fuzzy
msgid ""
"For instance, we know it will be perfectly fine to concatenate two ASCII "
"strings, but in order to convince Idris of this, we will have to use "
"`believe_me`, because we will not be able to proof the following lemma "
"otherwise:"
msgstr ""
"例如，我们知道连接两个 ASCII 字符串会非常好，但是为了让 Idris 相信这一点，"
"我们必须使用 `believe_me`，否则我们将无法证明以下引理："

#. type: Plain text
#: ../src/Tutorial/Prim.md:847
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
msgstr ""
"```伊德里斯\n"
"0 allAppend : (f : Char -> Bool)\n"
"            -> (s1,s2 : 字符串)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            ->所有f（解包（s1 ++ s2））===真\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:854
#, fuzzy, no-wrap
msgid ""
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
"```\n"
msgstr ""
"命名空间ASCII\n"
"  出口\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:861
#, fuzzy
msgid ""
"The same goes for all operations extracting a substring from a given string: "
"We will have to implement according rules using `believe_me`. Finding a "
"reasonable set of axioms to conveniently deal with refined primitives can "
"therefore be challenging at times, and whether such axioms are even required "
"very much depends on the use case at hand."
msgstr ""
"从给定字符串中提取子字符串的所有操作也是如此：我们必须使用 `believe_me` 来实"
"现相应的规则。因此，找到一组合理的公理来方便地处理精炼的原语有时可能具有挑战"
"性，而且是否需要这样的公理在很大程度上取决于手头的用例。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:863
#, fuzzy
msgid "### Use Case: Sanitized HTML"
msgstr "### 用例：净化的 HTML"

#. type: Plain text
#: ../src/Tutorial/Prim.md:869
#, fuzzy
msgid ""
"Assume you write a simple web application for scientific discourse between "
"registered users. To keep things simple, we only consider unformatted text "
"input here. Users can write arbitrary text in a text field and upon hitting "
"Enter, the message is displayed to all other registered users."
msgstr ""
"假设您为注册用户之间的科学讨论编写了一个简单的 Web 应用程序。为了简单起见，我"
"们在这里只考虑未格式化的文本输入。用户可以在文本字段中写入任意文本，然后按 "
"Enter 键，该消息将显示给所有其他注册用户。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:871
#, fuzzy
msgid "Assume now a user decides to enter the following text:"
msgstr "假设现在用户决定输入以下文本："

#. type: Plain text
#: ../src/Tutorial/Prim.md:875
#, fuzzy
msgid "```html <script>alert(\"Hello World!\")</script> ```"
msgstr "```html <script>alert(\"Hello World!\")</script> ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:884
#, fuzzy
msgid ""
"Well, it could have been (much) worse. Still, unless we take measures to "
"prevent this from happening, this might embed a JavaScript program in our "
"web page we never intended to have there! What I described here, is a well "
"known security vulnerability called [cross-site scripting](https://en."
"wikipedia.org/wiki/Cross-site_scripting).  It allows users of web pages to "
"enter malicious JavaScript code in text fields, which will then be included "
"in the page's HTML structure and executed when it is being displayed to "
"other users."
msgstr ""
"好吧，它本来可以（很多）更糟。尽管如此，除非我们采取措施防止这种情况发生，"
"否则这可能会在我们的网页中嵌入我们从未打算拥有的 JavaScript "
"程序！我在这里描述的是一个众所周知的安全漏洞，称为 [cross-site "
"scripting](https://en.wikipedia.org/wiki/Cross-site_scripting)。"
"它允许网页用户在文本字段中输入恶意 JavaScript 代码，"
"然后这些代码将包含在页面的 HTML 结构中，并在向其他用户显示时执行。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:891
#, fuzzy
msgid ""
"We want to make sure, that this cannot happen on our own web page.  In order "
"to protect us from this attack, we could for instance disallow certain "
"characters like `'<'` or `'>'` completely (although this might not be "
"enough!), but if our chat service is targeted at programmers, this will be "
"overly restrictive. An alternative is to escape certain characters before "
"rendering them on the page."
msgstr ""
"我们想确保这不会发生在我们自己的网页上。为了保护我们免受这种攻击，我们可以例"
"如完全禁止某些字符，例如 `'<'` 或 `'>'`（尽管这可能还不够！），但是如果我们的"
"聊天服务是针对程序员的，这将是过度限制。另一种方法是在将某些字符呈现在页面上"
"之前对其进行转义。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:903
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"转义：字符串->字符串\n"
"转义 = 连接。地图 ESC。打开包装\n"
"  其中 esc : 字符 -> 字符串\n"
"        esc '<' = \"&lt;\"\n"
"        esc '>' = \"&gt;\"\n"
"        esc '\"' = \"&quot;\"\n"
"        esc '&' = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c = 单例 c\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:910
#, fuzzy
msgid ""
"What we now want to do is to store a string together with a proof that is "
"was properly escaped. This is another form of existential quantification: "
"\"Here is a string, and there once existed another string, which we passed "
"to `escape` and arrived at the string we have now\". Here's how to encode "
"this:"
msgstr ""
"我们现在要做的是将字符串与正确转义的证明一起存储。这是存在量化的另一种形式：“"
"这是一个字符串，曾经存在另一个字符串，我们将其传递给 `escape` "
"并到达我们现在拥有的字符串”。以下是如何对此进行编码："

#. type: Plain text
#: ../src/Tutorial/Prim.md:918
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"记录逃到哪里\n"
"  构造函数 MkEscaped\n"
"  值：字符串\n"
"  0 来源：字符串\n"
"  0 prf : 转义原点 === 值\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:925
#, fuzzy
msgid ""
"Whenever we now embed a string of unknown origin in our web page, we can "
"request a value of type `Escaped` and have the very strong guarantee that we "
"are no longer vulnerable to cross-site scripting attacks. Even better, it is "
"also possible to safely embed string literals known at compile time without "
"the need to escape them first:"
msgstr ""
"每当我们现在在我们的网页中嵌入一个未知来源的字符串时，"
"我们都可以请求一个类型为 `Escaped` 的值，并且非常有力地保证我们不再容易受到跨"
"站点脚本攻击。更好的是，还可以安全地嵌入编译时已知的字符串文字，而无需先转义"
"它们："

#. type: Plain text
#: ../src/Tutorial/Prim.md:931
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
msgstr ""
"```伊德里斯\n"
"命名空间转义\n"
"  出口\n"
"  fromString : (s : String) -> {auto 0 prf : 转义 s === s} -> 转义\n"
"  fromString s = MkEscaped s s prf\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:935
#, fuzzy
msgid "escaped : Escaped escaped = \"Hello World!\" ```"
msgstr "转义：转义转义=“Hello World！” ```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:941
#, fuzzy
msgid ""
"In this massive set of exercises, you are going to build a small library for "
"working with predicates on primitives.  We want to keep the following goals "
"in mind:"
msgstr "在这组庞大的练习中，您将构建一个小型库，用于处理原语上的谓词。我们要牢记以下"
"目标："

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, fuzzy
msgid ""
"We want to use the usual operations of propositional logic to combine "
"predicates: Negation, conjuction (logical *and*), and disjunction (logical "
"*or*)."
msgstr "我们想使用命题逻辑的常用运算来组合谓词：否定、合取（逻辑 * 和 *）和析取（"
"逻辑 * 或 *）。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, fuzzy
msgid ""
"All predicates should be erased at runtime. If we proof something about a "
"primitive number, we want to make sure not to carry around a huge proof of "
"validity."
msgstr "所有谓词都应在运行时擦除。如果我们证明一些关于原始数字的东西，我们要确保不携"
"带大量的有效性证明。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, fuzzy
msgid ""
"Calculations on predicates should make no appearance at runtime (with the "
"exception of `decide`; see below)."
msgstr "谓词的计算不应在运行时出现（`decide` 除外；见下文）。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, fuzzy
msgid ""
"Recursive calculations on predicates should be tail recursive if they are "
"used in implementations of `decide`. This might be tough to achieve. If you "
"can't find a tail recursive solution for a given problem, use what feels "
"most natural instead."
msgstr ""
"如果谓词用于 `decide` 的实现，则谓词的递归计算应该是尾递归的。这可能很难实现"
"。如果您找不到给定问题的尾递归解决方案，请改用感觉最自然的方法。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:980
#, fuzzy
msgid ""
"A note on efficiency: In order to be able to run computations on our "
"predicates, we try to convert primitive values to algebraic data types as "
"often and as soon as possible: Unsigned integers will be converted to `Nat` "
"using `cast`, and strings will be converted to `List Char` using `unpack`.  "
"This allows us to work with proofs on `Nat` and `List` most of the time, and "
"such proofs can be implemented without resorting to `believe_me` or other "
"cheats. However, the one advantage of primitive types over algebraic data "
"types is that they often perform much better. This is especially critical "
"when comparing integral types with `Nat`: Operations on natural numbers "
"often run with `O(n)` time complexity, where `n` is the size of one of the "
"natural numbers involved, while with `Bits64`, for instance, many operations "
"run in fast constant time (`O(1)`). Luckily, the Idris compiler optimizes "
"many functions on natural number to use the corresponding `Integer` "
"operations at runtime. This has the advantage that we can still use proper "
"induction to proof stuff about natural numbers at compile time, while "
"getting the benefit of fast integer operations at runtime. However, "
"operations on `Nat` do run with `O(n)` time complexity and *compile time*. "
"Proofs working on large natural number will therefore drastically slow down "
"the compiler. A way out of this is discussed at the end of this section of "
"exercises."
msgstr ""
"关于效率的说明：为了能够在我们的谓词上运行计算，我们尝试尽快将原始值转换为代"
"数数据类型：无符号整数将转换为 `Nat` 使用 [ X225X]cast`，字符串将使用 "
"`unpack` 转换为 `List Char`。这使我们大部分时间都可以在 `Nat` 和 `List` "
"上使用证明，并且可以在不借助 `believe_me` 或其他作弊手段的情况下实现此类证明"
"。然而，原始类型相对于代数数据类型的一个优势是它们通常执行得更好。"
"在将整数类型与 `Nat` 进行比较时，这一点尤其重要：对自然数的运算通常以 `O(n)` "
"时间复杂度运行，其中 `n` 是 1 的大小所涉及的自然数，而对于 "
"`Bits64`，例如，许多操作在快速常数时间内运行（`O(1)`）。幸运的是，Idris "
"编译器优化了许多自然数函数，以便在运行时使用相应的 `Integer` 操作。这样做的好"
"处是我们仍然可以在编译时使用适当的归纳来证明关于自然数的东西，同时在运行时获"
"得快速整数运算的好处。但是，`Nat` 上的操作确实以 `O(n)` 时间复杂度和 * "
"编译时间* 运行。因此，在大自然数上工作的证明将大大减慢编译器的速度。在本节练"
"习的末尾讨论了解决此问题的方法。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:983
#, fuzzy
msgid ""
"Enough talk, let's begin! To start with, you are given the following "
"utilities:"
msgstr "废话不多说，开始吧！首先，您将获得以下实用程序："

#. type: Plain text
#: ../src/Tutorial/Prim.md:991
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
msgstr ""
"```伊德里斯\n"
"-- 与 `Dec` 类似，但带有擦除的证明。构造函数 `Yes0`\n"
"-- 和 `No0` 将通过以下方式转换为常量 `0` 和 `1`\n"
"——编译器！\n"
"数据 Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0 : (0 contra : prop -> Void) -> Dec0 prop\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1005
#, fuzzy, no-wrap
msgid ""
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
msgstr ""
"-- 对于具有多个参数的接口（`a` 和 `p`\n"
"-- 在本例中）有时可以确定一个参数\n"
"——通过了解对方。例如，如果我们知道 `p` 是什么，\n"
"-- 我们肯定也知道 `a` 是什么。因此我们\n"
"-- 指定在 `Decidable` 上的证明搜索应该只\n"
"-- 基于 `p`，在竖线后列出 `p`：`| p`。\n"
"-- 这就像指定搜索参数\n"
"-- 如本章所示，具有 `[search p]` 的数据类型\n"
"——关于谓词。\n"
"-- 指定单个搜索参数，如这里所示可以\n"
"- 极大地帮助类型推断。\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p 在哪里\n"
"  决定 : (v : a) -> Dec0 (p v)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1011
#, fuzzy
msgid ""
"-- We often have to pass `p` explicitly in order to help Idris with -- type "
"inference. In such cases, it is more convenient to use -- `decideOn pred` "
"instead of `decide {p = pred}`.  decideOn : (0 p : a -> Type) -> Decidable a "
"p => (v : a) -> Dec0 (p v)  decideOn _ = decide"
msgstr ""
"-- 我们经常必须显式传递 `p` 以帮助 Idris 进行 -- 类型推断。在这种情况下，"
"使用 `decideOn pred` 代替 `decide {p = pred}` 更方便。决定：（0 p：a->类型）-"
">可判定a p =>（v：a）->Dec0（p v）decisionOn _ =决定"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1019
#, fuzzy
msgid ""
"-- Some primitive predicates can only be reasonably implemented -- using "
"boolean functions. This utility helps with decidability -- on such proofs.  "
"test0 : (b : Bool) -> Dec0 (b === True)  test0 True = Yes0 Refl test0 False "
"= No0 absurd ```"
msgstr ""
"-- 一些原始谓词只能合理地实现 -- "
"使用布尔函数。这个实用程序有助于可判定性——在这样的证明上。 test0 : (b : Bool)"
" -> Dec0 (b === True) test0 True = Yes0 Refl test0 False = No0 荒谬```"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1025
#, fuzzy
msgid ""
"We also want to run decidable computations at compile time. This is often "
"much more efficient than running a direct proof search on an inductive type. "
"We therefore come up with a predicate witnessing that a `Dec0` value is "
"actually a `Yes0` together with two utility functions:"
msgstr ""
"我们还希望在编译时运行可判定的计算。这通常比在归纳类型上运行直接证明搜索更有"
"效。因此，我们提出了一个谓词，证明 `Dec0` 值实际上是 `Yes0` "
"以及两个实用函数："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1029
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
msgstr ""
"```伊德里斯\n"
"数据 IsYes0 : (d : Dec0 prop) -> 键入 where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1033
#, fuzzy
msgid ""
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop fromYes0 (Yes0 x) "
"= x fromYes0 (No0 contra) impossible"
msgstr ""
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop fromYes0 (Yes0 x) "
"= x fromYes0 (No0 contra) 不可能"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1041
#, fuzzy, no-wrap
msgid ""
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"
"```\n"
msgstr ""
"0 safeDecideOn : (0 p : a -> 类型)\n"
"               -> 可判定的 p\n"
"               => (v:a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ 决定 p v\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1045
#, fuzzy
msgid ""
"Finally, as we are planning to refine mostly primitives, we will at times "
"require some sledge hammer to convince Idris that we know what we are doing:"
msgstr "最后，由于我们计划主要改进原语，我们有时需要一些大锤来说服 Idris "
"我们知道我们在做什么："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1055
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in `unsafeRefineOn`\"\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"-- 仅当您确定 `decideOn p v` 时才使用它\n"
"-- 将返回一个 `Yes0`！\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> 可判定 a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decisionOn p v of\n"
"  是0 prf => prf\n"
"  No0 _ =>\n"
"    assert_total $ idris_crash \"`unsafeRefineOn` 中的意外优化失败\"\n"
"```\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:1058
#, fuzzy
msgid "We start with equality proofs. Implement `Decidable` for `Equal v`."
msgstr "我们从等式证明开始。为 `Equal v` 实现 `Decidable`。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1061
#, fuzzy, no-wrap
msgid ""
"   Hint: Use `DecEq` from module `Decidable.Equality` as a constraint\n"
"         and make sure that `v` is available at runtime.\n"
msgstr ""
"   提示：使用模块 `Decidable.Equality` 中的 `DecEq` 作为约束\n"
"         并确保 `v` 在运行时可用。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:1063
#, fuzzy
msgid "We want to be able to negate a predicate:"
msgstr "我们希望能够否定一个谓词："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1068
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   数据 Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1070
#, fuzzy, no-wrap
msgid "   Implement `Decidable` for `Neg p` using a suitable constraint.\n"
msgstr "   使用合适的约束为 `Neg p` 实现 `Decidable`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:1072
#, fuzzy
msgid "We want to describe the conjunction of two predicates:"
msgstr "我们要描述两个谓词的合取："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1077
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q v\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   数据 (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     两者：{0 p,q : a -> 类型} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q "
"v\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1079
#, fuzzy, no-wrap
msgid "   Implement `Decidable` for `(p && q)` using suitable constraints.\n"
msgstr "   使用合适的约束为 `(p && q)` 实现 `Decidable`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:1083
#, fuzzy
msgid ""
"Come up with a data type called `(||)` for the disjunction (logical *or*) of "
"two predicates and implement `Decidable` using suitable constraints."
msgstr "提出一个名为 `(||)` 的数据类型，用于两个谓词的析取（逻辑 * 或 *），"
"并使用合适的约束实现 `Decidable`。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:1086
#, fuzzy
msgid ""
"Proof [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)  "
"by implementing the following propositions:"
msgstr "通过实施以下命题证明 [德摩根定律](https://en.wikipedia.org/wiki/De_Morgan"
"%27s_laws)："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1089
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
msgstr ""
"   ```伊德里斯\n"
"   negOr : 否定 (p || q) v -> (否定 p && 否定 q) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1091
#, fuzzy, no-wrap
msgid "   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
msgstr "   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1094
#, fuzzy, no-wrap
msgid ""
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
"   ```\n"
msgstr ""
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1100
#, fuzzy, no-wrap
msgid ""
"   The last of De Morgan's implications is harder to type and proof\n"
"   as we need a way to come up with values of type `p v` and `q v`\n"
"   and show that not both can exist. Here is a way to encode this\n"
"   (annotated with quantity 0 as we will need to access an erased\n"
"   contraposition):\n"
msgstr ""
"   德摩根的最后一个含义更难打字和证明\n"
"   因为我们需要一种方法来得出 `p v` 和 `q v` 类型的值\n"
"   并表明并非两者都可以存在。这是一种对此进行编码的方法\n"
"   （用数量 0 注释，因为我们需要访问已擦除的\n"
"   对立）：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1107
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   0 negAnd : 可判定的 p\n"
"            => 可判定的 q\n"
"            => 否定 (p && q) v\n"
"            -> (否定 p || 否定 q) v\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1111
#, fuzzy, no-wrap
msgid ""
"   When you implement `negAnd`, remember that you can freely access\n"
"   erased (implicit) arguments, because `negAnd` itself can only be\n"
"   used in an erased context.\n"
msgstr ""
"   当你实现`negAnd`时，记住你可以自由访问\n"
"   擦除（隐式）参数，因为 `negAnd` 本身只能是\n"
"   在已删除的上下文中使用。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1117
#, fuzzy
msgid ""
"So far, we implemented the tools to algebraically describe and combine "
"several predicate. It is now time to come up with some examples. As a first "
"use case, we will focus on limiting the valid range of natural numbers. For "
"this, we use the following data type:"
msgstr ""
"到目前为止，我们实现了代数描述和组合几个谓词的工具。现在是提出一些例子的时候"
"了。作为第一个用例，我们将专注于限制自然数的有效范围。为此，我们使用以下数据"
"类型："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1124
#, fuzzy, no-wrap
msgid ""
"```idris\n"
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"
"```\n"
msgstr ""
"```伊德里斯\n"
"-- 证明 m <= n\n"
"数据 (<=) : (m,n : Nat) -> 输入其中\n"
"  ZLTE：0 <= n\n"
"  SLTE：m <= n -> S m <= S n\n"
"```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1128
#, fuzzy
msgid ""
"This is similar to `Data.Nat.LTE` but I find operator notation often to be "
"clearer.  We also can define and use the following aliases:"
msgstr "这类似于 `Data.Nat.LTE` "
"但我发现运算符符号通常更清晰。我们还可以定义和使用以下别名："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1132
#, fuzzy
msgid "```repl (>=) : (m,n : Nat) -> Type m >= n = n <= m"
msgstr "```repl (>=) : (m,n : Nat) -> 键入 m >= n = n <= m"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1135
#, fuzzy
msgid "(<) : (m,n : Nat) -> Type m < n = S m <= n"
msgstr "(<) : (m,n : Nat) -> 键入 m < n = S m <= n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1138
#, fuzzy
msgid "(>) : (m,n : Nat) -> Type m > n = n < m"
msgstr "(>) : (m,n : Nat) -> 键入 m > n = n < m"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1141
#, fuzzy
msgid "LessThan : (m,n : Nat) -> Type LessThan m = (< m)"
msgstr "小于 : (m,n : Nat) -> 键入小于 m = (< m)"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1144
#, fuzzy
msgid "To : (m,n : Nat) -> Type To m = (<= m)"
msgstr "To : (m,n : Nat) -> Type To m = (<= m)"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1147
#, fuzzy
msgid "GreaterThan : (m,n : Nat) -> Type GreaterThan m = (> m)"
msgstr "GreaterThan : (m,n : Nat) -> 输入 GreaterThan m = (> m)"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1150
#, fuzzy
msgid "From : (m,n : Nat) -> Type From m = (>= m)"
msgstr "从 : (m,n : Nat) -> 从 m = (>= m) 输入"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1153
#, fuzzy
msgid "FromTo : (lower,upper : Nat) -> Nat -> Type FromTo l u = From l && To u"
msgstr "FromTo : (lower,upper : Nat) -> Nat -> 输入 FromTo l u = From l && To u"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1157
#, fuzzy
msgid ""
"Between : (lower,upper : Nat) -> Nat -> Type Between l u = GreaterThan l && "
"LessThan u ```"
msgstr ""
"之间 : (lower,upper : Nat) -> Nat -> Type Between l u = GreaterThan l && "
"LessThan u ```"

#. type: Bullet: '6. '
#: ../src/Tutorial/Prim.md:1171
#, fuzzy
msgid ""
"Coming up with a value of type `m <= n` by pattern matching on `m` and `n` "
"is highly inefficient for large values of `m`, as it will require `m` "
"iterations to do so. However, while in an erased context, we don't need to "
"hold a value of type `m <= n`. We only need to show, that such a value "
"follows from a more efficient computation. Such a computation is `compare` "
"for natural numbers: Although this is implemented in the *Prelude* with a "
"pattern match on its arguments, it is optimized by the compiler to a "
"comparison of integers which runs in constant time even for very large "
"numbers.  Since `Prelude.(<=)` for natural numbers is implemented in terms "
"of `compare`, it runs just as efficiently."
msgstr ""
"通过在 `m` 和 `n` 上进行模式匹配来得出 `m <= n` 类型的值对于较大的 `m` "
"值非常低效，因为这样做需要 `m` 次迭代。但是，在擦除上下文中，我们不需要保存 `"
"m <= n` 类型的值。我们只需要证明，这样的值来自更有效的计算。对于自然数，"
"这样的计算是 `compare`：尽管这是在 *Prelude* 中实现的，其参数的模式匹配，但编"
"译器将其优化为运行在即使对于非常大的数字也是恒定的时间。由于自然数的 "
"`Prelude.(<=)` 是根据 `compare` 实现的，因此它的运行效率同样高。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1175
#, fuzzy, no-wrap
msgid ""
"   We therefore need to proof the following two lemmas (make\n"
"   sure to not confuse `Prelude.(<=)` with `Prim.(<=)` in\n"
"   these declarations):\n"
msgstr ""
"   因此，我们需要证明以下两个引理（使\n"
"   确保不要将 `Prelude.(<=)` 与 `Prim.(<=)` 混淆\n"
"   这些声明）：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1178
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
msgstr ""
"   ```伊德里斯\n"
"   0 来自LTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1181
#, fuzzy, no-wrap
msgid ""
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
"   ```\n"
msgstr ""
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
"   ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1185
#, fuzzy, no-wrap
msgid ""
"   They come with a quantity of 0, because they are just as inefficient\n"
"   as the other computations we discussed above. We therefore want\n"
"   to make absolutely sure that they will never be used at runtime!\n"
msgstr ""
"   它们的数量为 0，因为它们同样低效\n"
"   正如我们上面讨论的其他计算。因此我们想要\n"
"   绝对确保它们永远不会在运行时使用！\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1190
#, fuzzy, no-wrap
msgid ""
"   Now, implement `Decidable Nat (<= n)`, making use of `test0`,\n"
"   `fromLTE`, and `toLTE`.\n"
"   Likewise, implement `Decidable Nat (m <=)`, because we require\n"
"   both kinds of predicates.\n"
msgstr ""
"   现在，利用 `test0` 实现 `Decidable Nat (<= n)`，\n"
"   `从LTE`和`到LTE`。\n"
"   同样，实现 `Decidable Nat (m <=)`，因为我们需要\n"
"   两种谓词。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1193
#, fuzzy, no-wrap
msgid ""
"   Note: You should by know figure out yourself that `n` must be\n"
"   available at runtime and how to make sure that this is the case.\n"
msgstr ""
"   注意：您应该自己知道 `n` 必须是\n"
"   在运行时可用以及如何确保是这种情况。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Prim.md:1198
#, fuzzy
msgid ""
"Proof that `(<=)` is reflexive and transitive by declaring and implementing "
"corresponding propositions. As we might require the proof of transitivity to "
"chain several values of type `(<=)`, it makes sense to also define a short "
"operator alias for this."
msgstr ""
"通过声明和实现相应的命题证明 `(<=)` 是自反和传递的。"
"由于我们可能需要传递性证明来链接多个类型为 `(<=)` "
"的值，因此也可以为此定义一个简短的运算符别名。"

#. type: Bullet: '8. '
#: ../src/Tutorial/Prim.md:1200
#, fuzzy
msgid "Proof that from `n > 0` follows `IsSucc n` and vise versa."
msgstr "证明从 `n > 0` 遵循 `IsSucc n`，反之亦然。"

#. type: Bullet: '9. '
#: ../src/Tutorial/Prim.md:1207
#, fuzzy
msgid ""
"Declare and implement safe division and modulo functions for `Bits64`, by "
"requesting an erased proof that the denominator is strictly positive when "
"cast to a natural number. In case of the modulo function, return a refined "
"value carrying an erased proof that the result is strictly smaller than the "
"modulus:"
msgstr ""
"声明并实现 `Bits64` 的安全除法和模函数，方法是请求删除证明，证明分母在转换为"
"自然数时严格为正。在模函数的情况下，返回一个精确的值，带有一个删除的证明，证"
"明结果严格小于模数："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1213
#, fuzzy, no-wrap
msgid ""
"   ```idris\n"
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"
"   ```\n"
msgstr ""
"   ```伊德里斯\n"
"   safeMod : (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => 子集 Bits64 (\\v => cast v < cast y)\n"
"   ```\n"

#. type: Bullet: '10. '
#: ../src/Tutorial/Prim.md:1218
#, fuzzy
msgid ""
"We will use the predicates and utilities we defined so far to convert a "
"value of type `Bits64` to a string of digits in base `b` with `2 <= b && b "
"<= 16`.  To do so, implement the following skeleton definitions:"
msgstr ""
"我们将使用到目前为止定义的谓词和实用程序将 `Bits64` 类型的值转换为基数 `b` "
"中的数字字符串，其中 `2 <= b && b <= 16`。为此，请实现以下骨架定义："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1223
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"
msgstr ""
"    ```伊德里斯\n"
"    -- 这需要 `assert_total` 的帮助\n"
"    -- 和 `idris_crash`。\n"
"    数字 : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1228
#, fuzzy, no-wrap
msgid ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"
msgstr ""
"    记录基地在哪里\n"
"      构造函数 MkBase\n"
"      值：Bits64\n"
"      0 prf：FromTo 2 16（转换值）\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1230
#, fuzzy, no-wrap
msgid "    base : Bits64 -> Maybe Base\n"
msgstr "    基数：Bits64 -> 也许基数\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1235
#, fuzzy, no-wrap
msgid ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> Base\n"
"    ```\n"
msgstr ""
"    命名空间基础\n"
"      公共出口\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> "
"Base\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1241
#, fuzzy, no-wrap
msgid ""
"    Finally, implement `digits`, using `safeDiv` and `safeMod`\n"
"    in your implementation. This might be challenging, as you will\n"
"    have to manually transform some proofs to satisfy the type\n"
"    checker. You might also require `assert_smaller` in the\n"
"    recursive step.\n"
msgstr ""
"    最后，使用 `safeDiv` 和 `safeMod` 实现 `digits`\n"
"    在您的实施中。这可能具有挑战性，因为您将\n"
"    必须手动转换一些证明以满足类型\n"
"    检查器。您可能还需要 `assert_smaller` 在\n"
"    递归步骤。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1245
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"
msgstr ""
"    ```伊德里斯\n"
"    数字：Bits64 -> 基数 -> 字符串\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1255
#, fuzzy
msgid ""
"We will now turn our focus on strings. Two of the most obvious ways in which "
"we can restrict the strings we accept are by limiting the set of characters "
"and limiting their lengths. More advanced refinements might require strings "
"to match a certain pattern or regular expression. In such cases, we might "
"either go for a boolean check or use a custom data type representing the "
"different parts of the pattern, but we will not cover these topics here."
msgstr ""
"我们现在将注意力转向字符串。我们可以限制我们接受的字符串的两种最明显的方法是"
"限制字符集和限制它们的长度。更高级的改进可能需要字符串匹配某个模式或正则表达"
"式。在这种情况下，我们可能会进行布尔检查或使用自定义数据类型来表示模式的不同"
"部分，但我们不会在这里讨论这些主题。"

#. type: Bullet: '11. '
#: ../src/Tutorial/Prim.md:1258
#, fuzzy
msgid "Implement the following aliases for useful predicates on characters."
msgstr "为字符上的有用谓词实现以下别名。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1262
#, fuzzy, no-wrap
msgid ""
"    Hint: Use `cast` to convert characters to natural numbers,\n"
"    use `(<=)` and `InRange` to specify regions of characters,\n"
"    and use `(||)` to combine regions of characters.\n"
msgstr ""
"    提示：使用 `cast` 将字符转换为自然数，\n"
"    使用 `(<=)` 和 `InRange` 指定字符区域，\n"
"    并使用 `(||)` 组合字符区域。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1266
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"
msgstr ""
"    ```伊德里斯\n"
"    -- 字符 <= 127\n"
"    IsAscii : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1269
#, fuzzy, no-wrap
msgid ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"
msgstr ""
"    -- 字符 <= 255\n"
"    IsLatin : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1272
#, fuzzy, no-wrap
msgid ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"
msgstr ""
"    -- 区间 ['A','Z'] 中的字符\n"
"    IsUpper : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1275
#, fuzzy, no-wrap
msgid ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"
msgstr ""
"    -- 区间 ['a','z'] 中的字符\n"
"    IsLower : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1278
#, fuzzy, no-wrap
msgid ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"
msgstr ""
"    -- 小写或大写字符\n"
"    IsAlpha : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1281
#, fuzzy, no-wrap
msgid ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"
msgstr ""
"    -- ['0','9'] 范围内的字符\n"
"    IsDigit : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1284
#, fuzzy, no-wrap
msgid ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"
msgstr ""
"    -- 字母表中的数字或字符\n"
"    IsAlphaNum : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1287
#, fuzzy, no-wrap
msgid ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"
msgstr ""
"    -- [0,31] 或 [127,159] 范围内的字符\n"
"    IsControl : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1290
#, fuzzy, no-wrap
msgid ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"
msgstr ""
"    -- 非控制字符的 ASCII 字符\n"
"    IsPlainAscii : 字符 -> 类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1294
#, fuzzy, no-wrap
msgid ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"
msgstr ""
"    -- 不是控制字符的拉丁字符\n"
"    IsPlainLatin : 字符 -> 类型\n"
"    ```\n"

#. type: Bullet: '12. '
#: ../src/Tutorial/Prim.md:1301
#, fuzzy
msgid ""
"The advantage of this more modular approach to predicates on primitives is "
"that we can safely run calculations on our predicates and get the strong "
"guarantees from the existing proofs on inductive types like `Nat` and "
"`List`. Here are some examples of such calculations and conversions, all of "
"which can be implemented without cheating:"
msgstr ""
"这种更模块化的原语谓词方法的优势在于，我们可以安全地对谓词运行计算，并从现有"
"的关于归纳类型（如 `Nat` 和 `List`）的证明中获得强有力的保证。以下是此类计算"
"和转换的一些示例，所有这些都可以在不作弊的情况下实现："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1304
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"
msgstr ""
"    ```伊德里斯\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1306
#, fuzzy, no-wrap
msgid "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"
msgstr "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1308
#, fuzzy, no-wrap
msgid "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"
msgstr "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1310
#, fuzzy, no-wrap
msgid "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"
msgstr "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1312
#, fuzzy, no-wrap
msgid "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"
msgstr "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1314
#, fuzzy, no-wrap
msgid "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"
msgstr "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1317
#, fuzzy, no-wrap
msgid ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"
msgstr ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1324
#, fuzzy, no-wrap
msgid ""
"    The following (`asciiToLatin`) is trickier. Remember that\n"
"    `(<=)` is transitive. However, in your invocation of the proof\n"
"    of transitivity, you will not be able to apply direct proof search using\n"
"    `%search` because the search depth is too small. You could\n"
"    increase the search depth, but it is much more efficient\n"
"    to use `safeDecideOn` instead.\n"
msgstr ""
"    以下 (`asciiToLatin`) 比较棘手。请记住\n"
"    `(<=)` 是传递的。但是，在您调用证明时\n"
"    传递性，您将无法使用直接证明搜索\n"
"    `%search` 因为搜索深度太小。你可以\n"
"    增加搜索深度，但效率更高\n"
"    改为使用 `safeDecideOn`。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1327
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"
msgstr ""
"    ```伊德里斯\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1330
#, fuzzy, no-wrap
msgid ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"
msgstr ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1334
#, fuzzy
msgid ""
"Before we turn our full attention to predicates on strings, we have to cover "
"lists first, because we will often treat strings as lists of characters."
msgstr "在我们将全部注意力转向字符串谓词之前，我们必须先介绍列表，因为我们经常将字符"
"串视为字符列表。"

#. type: Bullet: '13. '
#: ../src/Tutorial/Prim.md:1336
#, fuzzy
msgid "Implement `Decidable` for `Head`:"
msgstr "为 `Head` 实现 `Decidable`："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1341
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"
msgstr ""
"    ```伊德里斯\n"
"    数据头 : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"

#. type: Bullet: '14. '
#: ../src/Tutorial/Prim.md:1343
#, fuzzy
msgid "Implement `Decidable` for `Length`:"
msgstr "为 `Length` 实现 `Decidable`："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1350
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"
msgstr ""
"    ```伊德里斯\n"
"    数据长度 : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength : {0 p : Nat -> 类型}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> 长度 p 与\n"
"    ```\n"

#. type: Bullet: '15. '
#: ../src/Tutorial/Prim.md:1354
#, fuzzy
msgid ""
"The following predicate is a proof that all values in a list of values "
"fulfill the given predicate. We will use this to limit the valid set of "
"characters in a string."
msgstr "以下谓词证明值列表中的所有值都满足给定谓词。我们将使用它来限制字符串中的有效"
"字符集。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1363
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"
msgstr ""
"    ```伊德里斯\n"
"    数据全部 : (p : a -> Type) -> (as : List a) -> Type where\n"
"      无：所有 p []\n"
"      (::) : {0 p : a -> 类型}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : 所有 p vs)\n"
"           -> 所有 p (v :: vs)\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1365
#, fuzzy, no-wrap
msgid "    Implement `Decidable` for `All`.\n"
msgstr "    为 `All` 实现 `Decidable`。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1373
#, fuzzy, no-wrap
msgid ""
"    For a real challenge, try to make your implementation of\n"
"    `decide` tail recursive. This will be important for real world\n"
"    applications on the JavaScript backends, where we might want to\n"
"    refine strings of thousands of characters without overflowing the\n"
"    stack at runtime. In order to come up with a tail recursive implementation,\n"
"    you will need an additional data type `AllSnoc` witnessing that a predicate\n"
"    holds for all elements in a `SnocList`.\n"
msgstr ""
"    对于真正的挑战，请尝试使您的实施\n"
"    `决定`尾递归。这对现实世界很重要\n"
"    JavaScript 后端上的应用程序，我们可能想要的地方\n"
"    精炼数千个字符的字符串而不会溢出\n"
"    在运行时堆栈。为了提出尾递归实现，\n"
"    您将需要一个额外的数据类型 `AllSnoc` 来见证谓词\n"
"    适用于 `SnocList` 中的所有元素。\n"

#. type: Bullet: '16. '
#: ../src/Tutorial/Prim.md:1379
#, fuzzy
msgid ""
"It's time to come to an end here. An identifier in Idris is a sequence of "
"alphanumeric characters, possibly separated by underscore characters (`_`). "
"In addition, all identifiers must start with a letter.  Given this "
"specification, implement predicate `IdentChar`, from which we can define a "
"new wrapper type for identifiers:"
msgstr ""
"是时候在这里结束了。 Idris 中的标识符是一系列字母数字字符，可能由下划线字符 "
"(`_`) 分隔。此外，所有标识符都必须以字母开头。给定这个规范，实现谓词 "
"`IdentChar`，我们可以从中为标识符定义一个新的包装器类型："

#. type: Plain text
#: ../src/Tutorial/Prim.md:1382
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"
msgstr ""
"    ```伊德里斯\n"
"    0 IdentChars：列表字符->类型\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1388
#, fuzzy, no-wrap
msgid ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"
msgstr ""
"    记录标识符在哪里\n"
"      构造函数 MkIdentifier\n"
"      值：字符串\n"
"      0 prf：IdentChars（解包值）\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1391
#, fuzzy, no-wrap
msgid ""
"    Implement a factory method `identifier` for converting strings\n"
"    of unknown source at runtime:\n"
msgstr ""
"    实现一个工厂方法 `identifier` 来转换字符串\n"
"    运行时未知来源：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1395
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"
msgstr ""
"    ```伊德里斯\n"
"    标识符：字符串->可能标识符\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1398
#, fuzzy, no-wrap
msgid ""
"    In addition, implement `fromString` for `Identifier` and verify,\n"
"    that the following is a valid identifier:\n"
msgstr ""
"    此外，为 `Identifier` 实现 `fromString` 并验证，\n"
"    以下是有效的标识符：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1403
#, fuzzy, no-wrap
msgid ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"
msgstr ""
"    ```伊德里斯\n"
"    testIdent : 标识符\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1409
#, fuzzy
msgid ""
"Final remarks: Proofing stuff about the primitives can be challenging, both "
"when deciding on what axioms to use and when trying to make things perform "
"well at runtime and compile time. I'm experimenting with a library, which "
"deals with these issues. It is not yet finished, but you can have a look at "
"it [here](https://github.com/stefan-hoeck/idris2-prim)."
msgstr ""
"最后的评论：在决定使用什么公理以及试图使事情在运行时和编译时表现良好时，证明"
"关于原语的东西可能具有挑战性。我正在尝试一个处理这些问题的库。它尚未完成，"
"但您可以在 [这里](https://github.com/stefan-hoeck/idris2-prim) 看看它。"
